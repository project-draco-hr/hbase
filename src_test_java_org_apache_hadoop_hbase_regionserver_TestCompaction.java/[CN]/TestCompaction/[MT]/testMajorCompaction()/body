{
  createStoreFile(r);
  for (int i=0; i < compactionThreshold; i++) {
    createStoreFile(r);
  }
  addContent(new HRegionIncommon(r),Bytes.toString(COLUMN_FAMILY));
  Result result=r.get(new Get(STARTROW).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  assertEquals(compactionThreshold,result.size());
  for (  Store store : this.r.stores.values()) {
    assertNull(store.getCompactionProgress());
  }
  r.flushcache();
  r.compactStores(true);
  int storeCount=0;
  for (  Store store : this.r.stores.values()) {
    CompactionProgress progress=store.getCompactionProgress();
    if (progress != null) {
      ++storeCount;
      assert(progress.currentCompactedKVs > 0);
      assert(progress.totalCompactingKVs > 0);
    }
    assert(storeCount > 0);
  }
  byte[] secondRowBytes=START_KEY.getBytes(HConstants.UTF8_ENCODING);
  secondRowBytes[START_KEY_BYTES.length - 1]++;
  result=r.get(new Get(secondRowBytes).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  assertEquals(compactionThreshold,result.size());
  Delete delete=new Delete(secondRowBytes,System.currentTimeMillis(),null);
  byte[][] famAndQf={COLUMN_FAMILY,null};
  delete.deleteFamily(famAndQf[0]);
  r.delete(delete,null,true);
  result=r.get(new Get(secondRowBytes).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  assertTrue("Second row should have been deleted",result.isEmpty());
  r.flushcache();
  result=r.get(new Get(secondRowBytes).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  assertTrue("Second row should have been deleted",result.isEmpty());
  createSmallerStoreFile(this.r);
  r.flushcache();
  result=r.get(new Get(secondRowBytes).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  assertTrue("Second row should still be deleted",result.isEmpty());
  r.compactStores(true);
  assertEquals(r.getStore(COLUMN_FAMILY_TEXT).getStorefiles().size(),1);
  result=r.get(new Get(secondRowBytes).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  assertTrue("Second row should still be deleted",result.isEmpty());
  verifyCounts(3,0);
  final int ttl=1000;
  for (  Store store : this.r.stores.values()) {
    Store.ScanInfo old=store.scanInfo;
    Store.ScanInfo si=new Store.ScanInfo(old.getFamily(),old.getMinVersions(),old.getMaxVersions(),ttl,old.getKeepDeletedCells(),old.getComparator());
    store.scanInfo=si;
  }
  Thread.sleep(1000);
  r.compactStores(true);
  int count=count();
  assertTrue("Should not see anything after TTL has expired",count == 0);
}
