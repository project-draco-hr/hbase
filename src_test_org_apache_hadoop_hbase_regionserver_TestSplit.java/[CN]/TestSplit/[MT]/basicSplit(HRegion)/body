{
  addContent(region,COLFAMILY_NAME3);
  region.flushcache();
  byte[] midkey=region.compactStores();
  assertNotNull(midkey);
  HRegion[] regions=split(region,midkey);
  try {
    for (int i=0; i < regions.length; i++) {
      regions[i]=openClosedRegion(regions[i]);
    }
    assertGet(regions[0],COLFAMILY_NAME3,Bytes.toBytes(START_KEY));
    assertGet(regions[1],COLFAMILY_NAME3,midkey);
    assertScan(regions[0],COLFAMILY_NAME3,Bytes.toBytes(START_KEY));
    assertScan(regions[1],COLFAMILY_NAME3,midkey);
    for (int i=0; i < regions.length; i++) {
      for (int j=0; j < 2; j++) {
        addContent(regions[i],COLFAMILY_NAME3);
      }
      addContent(regions[i],COLFAMILY_NAME2);
      addContent(regions[i],COLFAMILY_NAME1);
      regions[i].flushcache();
    }
    byte[][] midkeys=new byte[regions.length][];
    for (int i=0; i < regions.length; i++) {
      midkeys[i]=regions[i].compactStores();
    }
    TreeMap<String,HRegion> sortedMap=new TreeMap<String,HRegion>();
    for (int i=0; i < regions.length; i++) {
      HRegion[] rs=null;
      if (midkeys[i] != null) {
        rs=split(regions[i],midkeys[i]);
        for (int j=0; j < rs.length; j++) {
          sortedMap.put(Bytes.toString(rs[j].getRegionName()),openClosedRegion(rs[j]));
        }
      }
    }
    LOG.info("Made 4 regions");
    int interval=(LAST_CHAR - FIRST_CHAR) / 3;
    byte[] b=Bytes.toBytes(START_KEY);
    for (    HRegion r : sortedMap.values()) {
      assertGet(r,COLFAMILY_NAME3,b);
      b[0]+=interval;
    }
  }
  finally {
    for (int i=0; i < regions.length; i++) {
      try {
        regions[i].close();
      }
 catch (      IOException e) {
      }
    }
  }
}
