{
  int start=-1;
  int end=-1;
  if (candidates.getFilesToCompact().isEmpty()) {
    candidates.emptyFileList();
    return candidates;
  }
  int countOfFiles=candidates.getFilesToCompact().size();
  long[] fileSizes=new long[countOfFiles];
  StoreFile file;
  long[] sumSize=new long[countOfFiles + 1];
  sumSize[countOfFiles]=0;
  for (int i=countOfFiles - 1; i >= 0; --i) {
    file=candidates.getFilesToCompact().get(i);
    fileSizes[i]=file.getReader().length();
    sumSize[i]=fileSizes[i] + sumSize[i + 1];
  }
  int numTiers=tierConf.getNumCompactionTiers();
  TierCompactionConfiguration.CompactionTier tier;
  tierOf=new int[countOfFiles];
  endInTier=new int[numTiers + 1];
  endInTier[numTiers]=0;
  LOG.info("Applying TierCompactionPolicy with " + countOfFiles + " files");
  int i;
  int j=countOfFiles;
  for (i=0; i < numTiers; i++) {
    tier=tierConf.getCompactionTier(i);
    endInTier[i]=j;
    while (j > 0) {
      file=candidates.getFilesToCompact().get(j - 1);
      if (!isInTier(file,tier)) {
        break;
      }
      j--;
      tierOf[j]=i;
    }
  }
  long restSize;
  double ratio;
  for (j=0; j < countOfFiles; j++) {
    start=next(start);
    tier=tierConf.getCompactionTier(tierOf[start]);
    end=endInTier[tier.getEndingIndexForTier()];
    restSize=sumSize[start + 1] - sumSize[end];
    ratio=tier.getCompactionRatio();
    if (fileSizes[start] <= tierConf.getMaxCompactSize() && end - start >= tier.getMinFilesToCompact() && (fileSizes[start] <= tierConf.getMinCompactSize() || (fileSizes[start] <= restSize * ratio))) {
      break;
    }
  }
  String tab="    ";
  for (i=0; i < numTiers; i++) {
    LOG.info("Tier " + i + " : "+ tierConf.getCompactionTier(i).getDescription());
    if (endInTier[i] == endInTier[i + 1]) {
      LOG.info(tab + "No file is assigned to this tier.");
    }
 else {
      LOG.info(tab + (endInTier[i] - endInTier[i + 1]) + " file(s) are assigned to this tier with serial number(s) "+ endInTier[i + 1]+ " to "+ (endInTier[i] - 1));
    }
    for (j=endInTier[i + 1]; j < endInTier[i]; j++) {
      file=candidates.getFilesToCompact().get(j);
      LOG.info(tab + tab + "SeqID = "+ file.getMaxSequenceId()+ ", Age = "+ StringUtils.formatTimeDiff(EnvironmentEdgeManager.currentTimeMillis(),file.getMinFlushTime())+ ", Size = "+ StringUtils.humanReadableInt(fileSizes[j])+ ", Path = "+ file.getPath());
    }
  }
  if (start < countOfFiles) {
    end=Math.min(end,start + tierConf.getCompactionTier(tierOf[start]).getMaxFilesToCompact());
  }
  if (start < end) {
    String strTier=String.valueOf(tierOf[start]);
    if (tierOf[end - 1] != tierOf[start]) {
      strTier+=" to " + tierOf[end - 1];
    }
    LOG.info("Tier Based compaction algorithm has selected " + (end - start) + " files from tier "+ strTier+ " out of "+ countOfFiles+ " candidates");
  }
  candidates=candidates.getSubList(start,end);
  return candidates;
}
