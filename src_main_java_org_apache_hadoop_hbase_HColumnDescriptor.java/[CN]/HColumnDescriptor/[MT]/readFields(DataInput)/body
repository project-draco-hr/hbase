{
  int version=in.readByte();
  if (version < 6) {
    if (version <= 2) {
      Text t=new Text();
      t.readFields(in);
      this.name=t.getBytes();
    }
 else {
      this.name=Bytes.readByteArray(in);
    }
    this.values.clear();
    setMaxVersions(in.readInt());
    int ordinal=in.readInt();
    setCompressionType(Compression.Algorithm.values()[ordinal]);
    setInMemory(in.readBoolean());
    setBloomFilterType(in.readBoolean() ? BloomType.ROW : BloomType.NONE);
    if (getBloomFilterType() != BloomType.NONE && version < 5) {
      throw new UnsupportedClassVersionError(this.getClass().getName() + " does not support backward compatibility with versions older " + "than version 5");
    }
    if (version > 1) {
      setBlockCacheEnabled(in.readBoolean());
    }
    if (version > 2) {
      setTimeToLive(in.readInt());
    }
  }
 else {
    this.name=Bytes.readByteArray(in);
    this.values.clear();
    int numValues=in.readInt();
    for (int i=0; i < numValues; i++) {
      ImmutableBytesWritable key=new ImmutableBytesWritable();
      ImmutableBytesWritable value=new ImmutableBytesWritable();
      key.readFields(in);
      value.readFields(in);
      if (version < 8 && Bytes.toString(key.get()).equals(BLOOMFILTER)) {
        value.set(Bytes.toBytes(Boolean.getBoolean(Bytes.toString(value.get())) ? BloomType.ROW.toString() : BloomType.NONE.toString()));
      }
      values.put(key,value);
    }
    if (version == 6) {
      setValue(COMPRESSION,Compression.Algorithm.NONE.getName());
    }
  }
}
