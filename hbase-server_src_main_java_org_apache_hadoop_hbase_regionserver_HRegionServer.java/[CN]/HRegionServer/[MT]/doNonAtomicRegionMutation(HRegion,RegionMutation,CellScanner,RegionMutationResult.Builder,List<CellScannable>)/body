{
  List<MutationProto> mutations=null;
  for (  ClientProtos.MutationProto m : rm.getMutationList()) {
    ClientProtos.ResultOrException resultOrException=null;
    try {
      Result r=null;
      MutationType type=m.getMutateType();
      if (type != MutationType.PUT && type != MutationType.DELETE && mutations != null && !mutations.isEmpty()) {
        doBatchOp(builder,region,mutations,cellScanner);
        mutations.clear();
      }
switch (type) {
case APPEND:
        r=append(region,m,cellScanner);
      break;
case INCREMENT:
    r=increment(region,m,cellScanner);
  break;
case PUT:
case DELETE:
if (mutations == null) mutations=new ArrayList<MutationProto>(rm.getMutationCount());
mutations.add(m);
break;
default :
throw new DoNotRetryIOException("Unsupported mutate type: " + type.name());
}
if (r != null) {
ClientProtos.Result pbResult=null;
if (isClientCellBlockSupport()) {
pbResult=ProtobufUtil.toResultNoData(r);
if (cellsToReturn == null) cellsToReturn=new ArrayList<CellScannable>(256);
cellsToReturn.add(r);
}
 else {
pbResult=ProtobufUtil.toResult(r);
}
resultOrException=ClientProtos.ResultOrException.newBuilder().setResult(pbResult).build();
}
}
 catch (IOException ie) {
resultOrException=ResultOrException.newBuilder().setException(ResponseConverter.buildException(ie)).build();
}
if (resultOrException != null) {
builder.addResultOrException(resultOrException);
}
}
if (!mutations.isEmpty()) {
doBatchOp(builder,region,mutations,cellScanner);
}
return cellsToReturn;
}
