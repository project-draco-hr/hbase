{
  try {
    checkOpen();
  }
 catch (  IOException ie) {
    throw new ServiceException(ie);
  }
  requestCount.increment();
  OpenRegionResponse.Builder builder=OpenRegionResponse.newBuilder();
  final int regionCount=request.getOpenInfoCount();
  final Map<TableName,HTableDescriptor> htds=new HashMap<TableName,HTableDescriptor>(regionCount);
  final boolean isBulkAssign=regionCount > 1;
  for (  RegionOpenInfo regionOpenInfo : request.getOpenInfoList()) {
    final HRegionInfo region=HRegionInfo.convert(regionOpenInfo.getRegion());
    int versionOfOfflineNode=-1;
    if (regionOpenInfo.hasVersionOfOfflineNode()) {
      versionOfOfflineNode=regionOpenInfo.getVersionOfOfflineNode();
    }
    HTableDescriptor htd;
    try {
      final HRegion onlineRegion=getFromOnlineRegions(region.getEncodedName());
      if (onlineRegion != null) {
        if (onlineRegion.getCoprocessorHost() != null) {
          onlineRegion.getCoprocessorHost().preOpen();
        }
        Pair<HRegionInfo,ServerName> p=MetaReader.getRegion(this.catalogTracker,region.getRegionName());
        if (this.getServerName().equals(p.getSecond())) {
          Boolean closing=regionsInTransitionInRS.get(region.getEncodedNameAsBytes());
          if (!Boolean.FALSE.equals(closing) && getFromOnlineRegions(region.getEncodedName()) != null) {
            LOG.warn("Attempted open of " + region.getEncodedName() + " but already online on this server");
            builder.addOpeningState(RegionOpeningState.ALREADY_OPENED);
            continue;
          }
        }
 else {
          LOG.warn("The region " + region.getEncodedName() + " is online on this server"+ " but hbase:meta does not have this server - continue opening.");
          removeFromOnlineRegions(onlineRegion,null);
        }
      }
      LOG.info("Open " + region.getRegionNameAsString());
      htd=htds.get(region.getTableName());
      if (htd == null) {
        htd=this.tableDescriptors.get(region.getTableName());
        htds.put(region.getTableName(),htd);
      }
      final Boolean previous=this.regionsInTransitionInRS.putIfAbsent(region.getEncodedNameAsBytes(),Boolean.TRUE);
      if (Boolean.FALSE.equals(previous)) {
        OpenRegionHandler.tryTransitionFromOfflineToFailedOpen(this,region,versionOfOfflineNode);
        throw new RegionAlreadyInTransitionException("Received OPEN for the region:" + region.getRegionNameAsString() + " , which we are already trying to CLOSE ");
      }
      if (Boolean.TRUE.equals(previous)) {
        LOG.info("Receiving OPEN for the region:" + region.getRegionNameAsString() + " , which we are already trying to OPEN"+ " - ignoring this new request for this region.");
      }
      removeFromMovedRegions(region.getEncodedName());
      if (previous == null) {
        if (SplitLogManager.isRegionMarkedRecoveringInZK(this.getZooKeeper(),region.getEncodedName())) {
          this.recoveringRegions.put(region.getEncodedName(),null);
        }
        if (region.isMetaRegion()) {
          this.service.submit(new OpenMetaHandler(this,this,region,htd,versionOfOfflineNode));
        }
 else {
          updateRegionFavoredNodesMapping(region.getEncodedName(),regionOpenInfo.getFavoredNodesList());
          this.service.submit(new OpenRegionHandler(this,this,region,htd,versionOfOfflineNode));
        }
      }
      builder.addOpeningState(RegionOpeningState.OPENED);
    }
 catch (    KeeperException zooKeeperEx) {
      LOG.error("Can't retrieve recovering state from zookeeper",zooKeeperEx);
      throw new ServiceException(zooKeeperEx);
    }
catch (    IOException ie) {
      LOG.warn("Failed opening region " + region.getRegionNameAsString(),ie);
      if (isBulkAssign) {
        builder.addOpeningState(RegionOpeningState.FAILED_OPENING);
      }
 else {
        throw new ServiceException(ie);
      }
    }
  }
  return builder.build();
}
