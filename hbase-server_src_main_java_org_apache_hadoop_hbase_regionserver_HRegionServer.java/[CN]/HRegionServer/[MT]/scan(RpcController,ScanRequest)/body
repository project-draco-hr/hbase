{
  String scannerName=null;
  try {
    if (!request.hasScannerId() && !request.hasScan()) {
      throw new DoNotRetryIOException("Missing required input: scannerId or scan");
    }
    long scannerId=-1;
    if (request.hasScannerId()) {
      scannerId=request.getScannerId();
      scannerName=String.valueOf(scannerId);
    }
    try {
      checkOpen();
    }
 catch (    IOException e) {
      if (scannerName != null) {
        try {
          leases.cancelLease(scannerName);
        }
 catch (        LeaseException le) {
          LOG.info("Server shutting down and client tried to access missing scanner " + scannerName);
        }
      }
      throw e;
    }
    requestCount.increment();
    try {
      int ttl=0;
      HRegion region=null;
      RegionScanner scanner=null;
      RegionScannerHolder rsh=null;
      boolean moreResults=true;
      boolean closeScanner=false;
      ScanResponse.Builder builder=ScanResponse.newBuilder();
      if (request.hasCloseScanner()) {
        closeScanner=request.getCloseScanner();
      }
      int rows=1;
      if (request.hasNumberOfRows()) {
        rows=request.getNumberOfRows();
      }
      if (request.hasScannerId()) {
        rsh=scanners.get(scannerName);
        if (rsh == null) {
          throw new UnknownScannerException("Name: " + scannerName + ", already closed?");
        }
        scanner=rsh.scanner;
        region=getRegion(scanner.getRegionInfo().getRegionName());
      }
 else {
        region=getRegion(request.getRegion());
        ClientProtos.Scan protoScan=request.getScan();
        boolean isLoadingCfsOnDemandSet=protoScan.hasLoadColumnFamiliesOnDemand();
        Scan scan=ProtobufUtil.toScan(protoScan);
        if (!isLoadingCfsOnDemandSet) {
          scan.setLoadColumnFamiliesOnDemand(region.isLoadingCfsOnDemandDefault());
        }
        region.prepareScanner(scan);
        if (region.getCoprocessorHost() != null) {
          scanner=region.getCoprocessorHost().preScannerOpen(scan);
        }
        if (scanner == null) {
          scanner=region.getScanner(scan);
        }
        if (region.getCoprocessorHost() != null) {
          scanner=region.getCoprocessorHost().postScannerOpen(scan,scanner);
        }
        rsh=addScanner(scanner,region);
        scannerName=rsh.scannerName;
        scannerId=Long.parseLong(scannerName);
        ttl=this.scannerLeaseTimeoutPeriod;
        if (scan.getPrefetching()) {
          rsh.enablePrefetching(scan.getCaching());
        }
      }
      if (rows > 0) {
        if (request.hasNextCallSeq()) {
          if (request.getNextCallSeq() != rsh.nextCallSeq) {
            throw new OutOfOrderScannerNextException("Expected nextCallSeq: " + rsh.nextCallSeq + " But the nextCallSeq got from client: "+ request.getNextCallSeq()+ "; request="+ TextFormat.shortDebugString(request));
          }
          rsh.nextCallSeq++;
        }
        ttl=this.scannerLeaseTimeoutPeriod;
        ScanResult result=rsh.getScanResult(rows);
        if (result.isException) {
          throw result.ioException;
        }
        moreResults=result.moreResults;
        if (result.results != null) {
          List<CellScannable> cellScannables=new ArrayList<CellScannable>(result.results.size());
          ResultCellMeta.Builder rcmBuilder=ResultCellMeta.newBuilder();
          for (          Result res : result.results) {
            cellScannables.add(res);
            rcmBuilder.addCellsLength(res.size());
          }
          builder.setResultCellMeta(rcmBuilder.build());
          ((PayloadCarryingRpcController)controller).setCellScanner(CellUtil.createCellScanner(cellScannables));
        }
      }
      if (!moreResults || closeScanner) {
        ttl=0;
        moreResults=false;
        if (region != null && region.getCoprocessorHost() != null) {
          if (region.getCoprocessorHost().preScannerClose(scanner)) {
            return builder.build();
          }
        }
        rsh=scanners.remove(scannerName);
        if (rsh != null) {
          rsh.closeScanner();
          try {
            leases.cancelLease(scannerName);
          }
 catch (          LeaseException le) {
          }
          if (region != null && region.getCoprocessorHost() != null) {
            region.getCoprocessorHost().postScannerClose(scanner);
          }
        }
      }
      if (ttl > 0) {
        builder.setTtl(ttl);
      }
      builder.setScannerId(scannerId);
      builder.setMoreResults(moreResults);
      return builder.build();
    }
 catch (    Throwable t) {
      if (scannerName != null && t instanceof NotServingRegionException) {
        scanners.remove(scannerName);
      }
      throw convertThrowableToIOE(cleanup(t));
    }
  }
 catch (  IOException ie) {
    throw new ServiceException(ie);
  }
}
