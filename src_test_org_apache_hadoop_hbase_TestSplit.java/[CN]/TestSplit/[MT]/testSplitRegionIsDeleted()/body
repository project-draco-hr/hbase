{
  final int timeout=60;
  this.conf.set(HConstants.HBASE_DIR,this.testDir.toString());
  MiniHBaseCluster.MasterThread masterThread=MiniHBaseCluster.startMaster(this.conf);
  List<MiniHBaseCluster.RegionServerThread> regionServerThreads=MiniHBaseCluster.startRegionServers(this.conf,1);
  HTable meta=null;
  HTable t=null;
  try {
    HBaseAdmin admin=new HBaseAdmin(this.conf);
    admin.createTable(createTableDescriptor(getName()));
    meta=new HTable(this.conf,HConstants.META_TABLE_NAME);
    int count=count(meta,HConstants.COLUMN_FAMILY_STR);
    t=new HTable(this.conf,new Text(getName()));
    addContent(t,COLFAMILY_NAME3);
    HRegionInfo hri=t.getRegionLocation(HConstants.EMPTY_START_ROW).getRegionInfo();
    HRegion r=null;
synchronized (regionServerThreads) {
      r=regionServerThreads.get(0).getRegionServer().onlineRegions.get(hri.getRegionName());
    }
    r.flushcache(false);
    for (int i=0; i < timeout && (count(meta,HConstants.COLUMN_FAMILY_STR) <= count); i++) {
      Thread.sleep(1000);
    }
    int oldCount=count;
    count=count(meta,HConstants.COLUMN_FAMILY_STR);
    if (count <= oldCount) {
      throw new IOException("Failed waiting on splits to show up");
    }
    HRegionInfo parent=getSplitParent(meta);
    assertTrue(parent.isOffline());
    Path parentDir=HRegion.getRegionDir(this.testDir,parent.getRegionName());
    assertTrue(this.fs.exists(parentDir));
    LOG.info("Split happened and parent " + parent.getRegionName() + " is "+ "offline");
    LOG.info("Starting compaction");
synchronized (regionServerThreads) {
      for (      MiniHBaseCluster.RegionServerThread thread : regionServerThreads) {
        SortedMap<Text,HRegion> regions=thread.getRegionServer().onlineRegions;
        for (int i=0; i < 10; i++) {
          try {
            for (            HRegion online : regions.values()) {
              if (online.getRegionName().toString().startsWith(getName())) {
                online.compactStores();
              }
            }
            break;
          }
 catch (          ConcurrentModificationException e) {
            LOG.warn("Retrying because ..." + e.toString() + " -- one or "+ "two should be fine");
            continue;
          }
        }
      }
    }
    LOG.info("Waiting on parent " + parent.getRegionName() + " to disappear");
    for (int i=0; i < timeout && getSplitParent(meta) != null; i++) {
      Thread.sleep(1000);
    }
    assertTrue(getSplitParent(meta) == null);
    assertFalse(this.fs.exists(parentDir));
  }
  finally {
    MiniHBaseCluster.shutdown(masterThread,regionServerThreads);
  }
}
