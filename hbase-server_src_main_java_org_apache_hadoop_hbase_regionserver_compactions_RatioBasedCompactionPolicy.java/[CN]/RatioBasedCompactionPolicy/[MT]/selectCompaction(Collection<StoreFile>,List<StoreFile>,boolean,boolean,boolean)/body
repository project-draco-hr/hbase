{
  ArrayList<StoreFile> candidateSelection=new ArrayList<StoreFile>(candidateFiles);
  int futureFiles=filesCompacting.isEmpty() ? 0 : 1;
  boolean mayBeStuck=(candidateFiles.size() - filesCompacting.size() + futureFiles) >= storeConfigInfo.getBlockingFileCount();
  candidateSelection=getCurrentEligibleFiles(candidateSelection,filesCompacting);
  LOG.debug("Selecting compaction from " + candidateFiles.size() + " store files, "+ filesCompacting.size()+ " compacting, "+ candidateSelection.size()+ " eligible, "+ storeConfigInfo.getBlockingFileCount()+ " blocking");
  boolean isAllFiles=candidateFiles.size() == candidateSelection.size();
  if (!(forceMajor && isAllFiles)) {
    candidateSelection=skipLargeFiles(candidateSelection);
    isAllFiles=candidateFiles.size() == candidateSelection.size();
  }
  boolean isTryingMajor=(forceMajor && isAllFiles && isUserCompaction) || (((forceMajor && isAllFiles) || isMajorCompaction(candidateSelection)) && (candidateSelection.size() < comConf.getMaxFilesToCompact()));
  boolean isAfterSplit=StoreUtils.hasReferences(candidateSelection);
  if (!isTryingMajor && !isAfterSplit) {
    candidateSelection=filterBulk(candidateSelection);
    candidateSelection=applyCompactionPolicy(candidateSelection,mayUseOffPeak,mayBeStuck);
    candidateSelection=checkMinFilesCriteria(candidateSelection);
  }
  candidateSelection=removeExcessFiles(candidateSelection,isUserCompaction,isTryingMajor);
  isAllFiles=(candidateFiles.size() == candidateSelection.size());
  CompactionRequest result=new CompactionRequest(candidateSelection);
  result.setOffPeak(!candidateSelection.isEmpty() && !isAllFiles && mayUseOffPeak);
  result.setIsMajor(isTryingMajor && isAllFiles,isAllFiles);
  return result;
}
