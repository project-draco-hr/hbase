{
  ArrayList<StoreFile> candidateSelection=new ArrayList<StoreFile>(candidateFiles);
  int futureFiles=filesCompacting.isEmpty() ? 0 : 1;
  boolean mayBeStuck=(candidateFiles.size() - filesCompacting.size() + futureFiles) >= storeConfigInfo.getBlockingFileCount();
  candidateSelection=getCurrentEligibleFiles(candidateSelection,filesCompacting);
  LOG.debug("Selecting compaction from " + candidateFiles.size() + " store files, "+ filesCompacting.size()+ " compacting, "+ candidateSelection.size()+ " eligible, "+ storeConfigInfo.getBlockingFileCount()+ " blocking");
  long cfTtl=this.storeConfigInfo.getStoreFileTtl();
  if (!forceMajor) {
    if (comConf.shouldDeleteExpired() && (cfTtl != Long.MAX_VALUE)) {
      ArrayList<StoreFile> expiredSelection=selectExpiredStoreFiles(candidateSelection,EnvironmentEdgeManager.currentTimeMillis() - cfTtl);
      if (expiredSelection != null) {
        return new CompactionRequest(expiredSelection);
      }
    }
    candidateSelection=skipLargeFiles(candidateSelection);
  }
  boolean majorCompaction=((forceMajor && isUserCompaction) || ((forceMajor || isMajorCompaction(candidateSelection)) && (candidateSelection.size() < comConf.getMaxFilesToCompact())) || StoreUtils.hasReferences(candidateSelection));
  if (!majorCompaction) {
    candidateSelection=filterBulk(candidateSelection);
    candidateSelection=applyCompactionPolicy(candidateSelection,mayUseOffPeak,mayBeStuck);
    candidateSelection=checkMinFilesCriteria(candidateSelection);
  }
  candidateSelection=removeExcessFiles(candidateSelection,isUserCompaction,majorCompaction);
  CompactionRequest result=new CompactionRequest(candidateSelection);
  result.setOffPeak(!candidateSelection.isEmpty() && !majorCompaction && mayUseOffPeak);
  return result;
}
