{
  byte[] cols[]={CONTENTS_FIRSTCOL,ANCHOR_SECONDCOL};
  String[] vals1=new String[1000];
  for (int k=0; k < vals1.length; k++) {
    vals1[k]=Integer.toString(k);
  }
  long startTime=System.currentTimeMillis();
  for (int k=0; k < vals1.length / 2; k++) {
    String kLabel=String.format("%1$03d",k);
    BatchUpdate batchUpdate=new BatchUpdate(Bytes.toBytes("row_vals1_" + kLabel),System.currentTimeMillis());
    batchUpdate.put(cols[0],vals1[k].getBytes(HConstants.UTF8_ENCODING));
    batchUpdate.put(cols[1],vals1[k].getBytes(HConstants.UTF8_ENCODING));
    region.commit(batchUpdate);
    numInserted+=2;
  }
  LOG.info("Write " + (vals1.length / 2) + " elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  InternalScanner s=r.getScanner(cols,HConstants.EMPTY_START_ROW,System.currentTimeMillis(),null);
  int numFetched=0;
  try {
    HStoreKey curKey=new HStoreKey();
    TreeMap<byte[],Cell> curVals=new TreeMap<byte[],Cell>(Bytes.BYTES_COMPARATOR);
    int k=0;
    while (s.next(curKey,curVals)) {
      for (Iterator<byte[]> it=curVals.keySet().iterator(); it.hasNext(); ) {
        byte[] col=it.next();
        byte[] val=curVals.get(col).getValue();
        int curval=Integer.parseInt(new String(val,HConstants.UTF8_ENCODING).trim());
        for (int j=0; j < cols.length; j++) {
          if (Bytes.compareTo(col,cols[j]) == 0) {
            assertEquals("Error at:" + curKey.getRow() + "/"+ curKey.getTimestamp()+ ", Value for "+ col+ " should be: "+ k+ ", but was fetched as: "+ curval,k,curval);
            numFetched++;
          }
        }
      }
      curVals.clear();
      k++;
    }
  }
  finally {
    s.close();
  }
  assertEquals("Inserted " + numInserted + " values, but fetched "+ numFetched,numInserted,numFetched);
  LOG.info("Scanned " + (vals1.length / 2) + " rows from cache. Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  region.flushcache();
  LOG.info("Cache flush elapsed time: " + ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  s=r.getScanner(cols,HConstants.EMPTY_START_ROW,System.currentTimeMillis(),null);
  numFetched=0;
  try {
    HStoreKey curKey=new HStoreKey();
    TreeMap<byte[],Cell> curVals=new TreeMap<byte[],Cell>(Bytes.BYTES_COMPARATOR);
    int k=0;
    while (s.next(curKey,curVals)) {
      for (Iterator<byte[]> it=curVals.keySet().iterator(); it.hasNext(); ) {
        byte[] col=it.next();
        byte[] val=curVals.get(col).getValue();
        int curval=Integer.parseInt(new String(val,HConstants.UTF8_ENCODING).trim());
        for (int j=0; j < cols.length; j++) {
          if (Bytes.compareTo(col,cols[j]) == 0) {
            assertEquals("Error at:" + curKey.getRow() + "/"+ curKey.getTimestamp()+ ", Value for "+ col+ " should be: "+ k+ ", but was fetched as: "+ curval,k,curval);
            numFetched++;
          }
        }
      }
      curVals.clear();
      k++;
    }
  }
  finally {
    s.close();
  }
  assertEquals("Inserted " + numInserted + " values, but fetched "+ numFetched,numInserted,numFetched);
  LOG.info("Scanned " + (vals1.length / 2) + " rows from disk. Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  for (int k=vals1.length / 2; k < vals1.length; k++) {
    String kLabel=String.format("%1$03d",k);
    BatchUpdate batchUpdate=new BatchUpdate(Bytes.toBytes("row_vals1_" + kLabel),System.currentTimeMillis());
    batchUpdate.put(cols[0],vals1[k].getBytes(HConstants.UTF8_ENCODING));
    batchUpdate.put(cols[1],vals1[k].getBytes(HConstants.UTF8_ENCODING));
    region.commit(batchUpdate);
    numInserted+=2;
  }
  LOG.info("Write " + (vals1.length / 2) + " rows (second half). Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  s=r.getScanner(cols,HConstants.EMPTY_START_ROW,System.currentTimeMillis(),null);
  numFetched=0;
  try {
    HStoreKey curKey=new HStoreKey();
    TreeMap<byte[],Cell> curVals=new TreeMap<byte[],Cell>(Bytes.BYTES_COMPARATOR);
    int k=0;
    while (s.next(curKey,curVals)) {
      for (Iterator<byte[]> it=curVals.keySet().iterator(); it.hasNext(); ) {
        byte[] col=it.next();
        byte[] val=curVals.get(col).getValue();
        int curval=Integer.parseInt(new String(val,HConstants.UTF8_ENCODING).trim());
        for (int j=0; j < cols.length; j++) {
          if (Bytes.compareTo(col,cols[j]) == 0) {
            assertEquals("Error at:" + curKey.getRow() + "/"+ curKey.getTimestamp()+ ", Value for "+ col+ " should be: "+ k+ ", but was fetched as: "+ curval,k,curval);
            numFetched++;
          }
        }
      }
      curVals.clear();
      k++;
    }
  }
  finally {
    s.close();
  }
  assertEquals("Inserted " + numInserted + " values, but fetched "+ numFetched,numInserted,numFetched);
  LOG.info("Scanned " + vals1.length + " rows from cache and disk. Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  region.flushcache();
  LOG.info("Cache flush elapsed time: " + ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  s=r.getScanner(cols,HConstants.EMPTY_START_ROW,System.currentTimeMillis(),null);
  numFetched=0;
  try {
    HStoreKey curKey=new HStoreKey();
    TreeMap<byte[],Cell> curVals=new TreeMap<byte[],Cell>(Bytes.BYTES_COMPARATOR);
    int k=0;
    while (s.next(curKey,curVals)) {
      for (Iterator<byte[]> it=curVals.keySet().iterator(); it.hasNext(); ) {
        byte[] col=it.next();
        byte[] val=curVals.get(col).getValue();
        int curval=Integer.parseInt(new String(val,HConstants.UTF8_ENCODING).trim());
        for (int j=0; j < cols.length; j++) {
          if (Bytes.compareTo(col,cols[j]) == 0) {
            assertEquals("Value for " + col + " should be: "+ k+ ", but was fetched as: "+ curval,curval,k);
            numFetched++;
          }
        }
      }
      curVals.clear();
      k++;
    }
  }
  finally {
    s.close();
  }
  assertEquals("Inserted " + numInserted + " values, but fetched "+ numFetched,numInserted,numFetched);
  LOG.info("Scanned " + vals1.length + " rows from disk. Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  s=r.getScanner(cols,Bytes.toBytes("row_vals1_500"),System.currentTimeMillis(),null);
  numFetched=0;
  try {
    HStoreKey curKey=new HStoreKey();
    TreeMap<byte[],Cell> curVals=new TreeMap<byte[],Cell>(Bytes.BYTES_COMPARATOR);
    int k=500;
    while (s.next(curKey,curVals)) {
      for (Iterator<byte[]> it=curVals.keySet().iterator(); it.hasNext(); ) {
        byte[] col=it.next();
        byte[] val=curVals.get(col).getValue();
        int curval=Integer.parseInt(new String(val,HConstants.UTF8_ENCODING).trim());
        for (int j=0; j < cols.length; j++) {
          if (Bytes.compareTo(col,cols[j]) == 0) {
            assertEquals("Value for " + col + " should be: "+ k+ ", but was fetched as: "+ curval,curval,k);
            numFetched++;
          }
        }
      }
      curVals.clear();
      k++;
    }
  }
  finally {
    s.close();
  }
  assertEquals("Should have fetched " + (numInserted / 2) + " values, but fetched "+ numFetched,(numInserted / 2),numFetched);
  LOG.info("Scanned " + (numFetched / 2) + " rows from disk with specified start point. Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  LOG.info("scan completed.");
}
