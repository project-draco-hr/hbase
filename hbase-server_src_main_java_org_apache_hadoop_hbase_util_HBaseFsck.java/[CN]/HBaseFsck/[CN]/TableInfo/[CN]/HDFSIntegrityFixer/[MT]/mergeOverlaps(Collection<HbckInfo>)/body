{
  LOG.info("== Merging regions into one region: " + Joiner.on(",").join(overlap));
  Pair<byte[],byte[]> range=null;
  for (  HbckInfo hi : overlap) {
    if (range == null) {
      range=new Pair<byte[],byte[]>(hi.getStartKey(),hi.getEndKey());
    }
 else {
      if (RegionSplitCalculator.BYTES_COMPARATOR.compare(hi.getStartKey(),range.getFirst()) < 0) {
        range.setFirst(hi.getStartKey());
      }
      if (RegionSplitCalculator.BYTES_COMPARATOR.compare(hi.getEndKey(),range.getSecond()) > 0) {
        range.setSecond(hi.getEndKey());
      }
    }
    LOG.debug("Closing region before moving data around: " + hi);
    LOG.debug("Contained region dir before close");
    debugLsr(hi.getHdfsRegionDir());
    try {
      closeRegion(hi);
    }
 catch (    IOException ioe) {
      LOG.warn("Was unable to close region " + hi.getRegionNameAsString() + ".  Just continuing... ");
    }
catch (    InterruptedException e) {
      LOG.warn("Was unable to close region " + hi.getRegionNameAsString() + ".  Just continuing... ");
    }
    try {
      LOG.info("Offlining region: " + hi);
      offline(hi.getRegionName());
    }
 catch (    IOException ioe) {
      LOG.warn("Unable to offline region from master: " + hi,ioe);
    }
  }
  HTableDescriptor htd=getTableInfo().getHTD();
  HRegionInfo newRegion=new HRegionInfo(htd.getName(),range.getFirst(),range.getSecond());
  HRegion region=HBaseFsckRepair.createHDFSRegionDir(conf,newRegion,htd);
  LOG.info("Created new empty container region: " + newRegion + " to contain regions: "+ Joiner.on(",").join(overlap));
  debugLsr(region.getRegionDir());
  boolean didFix=false;
  Path target=region.getRegionDir();
  for (  HbckInfo contained : overlap) {
    LOG.info("Merging " + contained + " into "+ target);
    int merges=mergeRegionDirs(target,contained);
    if (merges > 0) {
      didFix=true;
    }
  }
  if (didFix) {
    fixes++;
  }
}
