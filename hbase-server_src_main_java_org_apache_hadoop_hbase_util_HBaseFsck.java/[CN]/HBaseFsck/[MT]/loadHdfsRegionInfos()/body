{
  tablesInfo.clear();
  Collection<HbckInfo> hbckInfos=regionInfoMap.values();
  WorkItemHdfsRegionInfo[] hbis=new WorkItemHdfsRegionInfo[hbckInfos.size()];
  int num=0;
  for (  HbckInfo hbi : hbckInfos) {
    hbis[num]=new WorkItemHdfsRegionInfo(hbi,this,errors);
    executor.execute(hbis[num]);
    num++;
  }
  for (int i=0; i < num; i++) {
    WorkItemHdfsRegionInfo hbi=hbis[i];
synchronized (hbi) {
      while (!hbi.isDone()) {
        hbi.wait();
      }
    }
  }
  for (  HbckInfo hbi : hbckInfos) {
    if (hbi.getHdfsHRI() == null) {
      continue;
    }
    String tableName=Bytes.toString(hbi.getTableName());
    if (tableName == null) {
      LOG.warn("tableName was null for: " + hbi);
      continue;
    }
    TableInfo modTInfo=tablesInfo.get(tableName);
    if (modTInfo == null) {
      modTInfo=new TableInfo(tableName);
      Path hbaseRoot=new Path(conf.get(HConstants.HBASE_DIR));
      try {
        HTableDescriptor htd=FSTableDescriptors.getTableDescriptor(hbaseRoot.getFileSystem(conf),hbaseRoot,tableName);
        modTInfo.htds.add(htd);
      }
 catch (      IOException ioe) {
        LOG.error("Unable to read .tableinfo from " + hbaseRoot,ioe);
        throw ioe;
      }
    }
    modTInfo.addRegionInfo(hbi);
    tablesInfo.put(tableName,modTInfo);
  }
  return tablesInfo;
}
