{
  MiniHBaseCluster cluster=UTIL.getHBaseCluster();
  HMaster master=cluster.getMaster();
  MasterCoprocessorHost host=master.getCoprocessorHost();
  CPMasterObserver cp=(CPMasterObserver)host.findCoprocessor(CPMasterObserver.class.getName());
  cp.enableBypass(false);
  cp.resetStates();
  HTable table=UTIL.createTable(TEST_TABLE,TEST_FAMILY);
  try {
    int countOfRegions=UTIL.createMultiRegions(table,TEST_FAMILY);
    UTIL.waitUntilAllRegionsAssigned(countOfRegions);
    NavigableMap<HRegionInfo,ServerName> regions=table.getRegionLocations();
    Map.Entry<HRegionInfo,ServerName> firstGoodPair=null;
    for (    Map.Entry<HRegionInfo,ServerName> e : regions.entrySet()) {
      if (e.getValue() != null) {
        firstGoodPair=e;
        break;
      }
    }
    assertNotNull("Found a non-null entry",firstGoodPair);
    LOG.info("Found " + firstGoodPair.toString());
    Collection<ServerName> servers=master.getClusterStatus().getServers();
    String destName=null;
    String serverNameForFirstRegion=firstGoodPair.getValue().toString();
    LOG.info("serverNameForFirstRegion=" + serverNameForFirstRegion);
    boolean found=false;
    for (    ServerName info : servers) {
      LOG.info("ServerName=" + info);
      if (!serverNameForFirstRegion.equals(info.getServerName())) {
        destName=info.toString();
        found=true;
        break;
      }
    }
    assertTrue("Found server",found);
    LOG.info("Found " + destName);
    master.moveRegion(null,RequestConverter.buildMoveRegionRequest(firstGoodPair.getKey().getEncodedNameAsBytes(),Bytes.toBytes(destName)));
    assertTrue("Coprocessor should have been called on region move",cp.wasMoveCalled());
    master.balanceSwitch(true);
    assertTrue("Coprocessor should have been called on balance switch",cp.wasBalanceSwitchCalled());
    master.balanceSwitch(false);
    AssignmentManager mgr=master.getAssignmentManager();
    Collection<RegionState> transRegions=mgr.getRegionStates().getRegionsInTransition().values();
    for (    RegionState state : transRegions) {
      mgr.getRegionStates().waitOnRegionToClearRegionsInTransition(state.getRegion());
    }
    HRegionServer rs=cluster.getRegionServer(0);
    byte[] destRS=Bytes.toBytes(cluster.getRegionServer(1).getServerName().toString());
    List<HRegionInfo> openRegions=ProtobufUtil.getOnlineRegions(rs);
    int moveCnt=openRegions.size() / 2;
    for (int i=0; i < moveCnt; i++) {
      HRegionInfo info=openRegions.get(i);
      if (!info.isMetaTable()) {
        master.moveRegion(null,RequestConverter.buildMoveRegionRequest(openRegions.get(i).getEncodedNameAsBytes(),destRS));
      }
    }
    transRegions=mgr.getRegionStates().getRegionsInTransition().values();
    for (    RegionState state : transRegions) {
      mgr.getRegionStates().waitOnRegionToClearRegionsInTransition(state.getRegion());
    }
    master.balanceSwitch(true);
    boolean balanceRun=master.balance();
    assertTrue("Coprocessor should be called on region rebalancing",cp.wasBalanceCalled());
    table.close();
  }
  finally {
    UTIL.deleteTable(TEST_TABLE);
  }
}
