{
  while (true) {
    startupStatus.setStatus("Trying to register in ZK as active master");
    try {
      String backupZNode=ZKUtil.joinZNode(this.watcher.backupMasterAddressesZNode,this.sn.toString());
      if (MasterAddressTracker.setMasterAddress(this.watcher,this.watcher.getMasterAddressZNode(),this.sn)) {
        if (ZKUtil.checkExists(this.watcher,backupZNode) != -1) {
          LOG.info("Deleting ZNode for " + backupZNode + " from backup master directory");
          ZKUtil.deleteNodeFailSilent(this.watcher,backupZNode);
        }
        ZNodeClearer.writeMyEphemeralNodeOnDisk(this.sn.toString());
        startupStatus.setStatus("Successfully registered as active master.");
        this.clusterHasActiveMaster.set(true);
        LOG.info("Registered Active Master=" + this.sn);
        return true;
      }
      this.clusterHasActiveMaster.set(true);
      LOG.info("Adding ZNode for " + backupZNode + " in backup master directory");
      MasterAddressTracker.setMasterAddress(this.watcher,backupZNode,this.sn);
      String msg;
      byte[] bytes=ZKUtil.getDataAndWatch(this.watcher,this.watcher.getMasterAddressZNode());
      if (bytes == null) {
        msg=("A master was detected, but went down before its address " + "could be read.  Attempting to become the next active master");
      }
 else {
        ServerName currentMaster;
        try {
          currentMaster=ServerName.parseFrom(bytes);
        }
 catch (        DeserializationException e) {
          LOG.warn("Failed parse",e);
          continue;
        }
        if (ServerName.isSameHostnameAndPort(currentMaster,this.sn)) {
          msg=("Current master has this master's address, " + currentMaster + "; master was restarted? Deleting node.");
          ZKUtil.deleteNode(this.watcher,this.watcher.getMasterAddressZNode());
          ZNodeClearer.deleteMyEphemeralNodeOnDisk();
        }
 else {
          msg="Another master is the active master, " + currentMaster + "; waiting to become the next active master";
        }
      }
      LOG.info(msg);
      startupStatus.setStatus(msg);
    }
 catch (    KeeperException ke) {
      master.abort("Received an unexpected KeeperException, aborting",ke);
      return false;
    }
synchronized (this.clusterHasActiveMaster) {
      while (this.clusterHasActiveMaster.get() && !this.master.isStopped()) {
        try {
          this.clusterHasActiveMaster.wait();
        }
 catch (        InterruptedException e) {
          LOG.debug("Interrupted waiting for master to die",e);
        }
      }
      if (clusterShutDown.get()) {
        this.master.stop("Cluster went down before this master became active");
      }
      if (this.master.isStopped()) {
        return false;
      }
    }
  }
}
