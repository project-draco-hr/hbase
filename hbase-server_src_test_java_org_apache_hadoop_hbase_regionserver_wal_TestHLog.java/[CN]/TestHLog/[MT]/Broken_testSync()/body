{
  TableName tableName=TableName.valueOf(getName());
  Path p=new Path(dir,getName() + ".fsdos");
  FSDataOutputStream out=fs.create(p);
  out.write(tableName.getName());
  Method syncMethod=null;
  try {
    syncMethod=out.getClass().getMethod("hflush",new Class<?>[]{});
  }
 catch (  NoSuchMethodException e) {
    try {
      syncMethod=out.getClass().getMethod("sync",new Class<?>[]{});
    }
 catch (    NoSuchMethodException ex) {
      fail("This version of Hadoop supports neither Syncable.sync() " + "nor Syncable.hflush().");
    }
  }
  syncMethod.invoke(out,new Object[]{});
  FSDataInputStream in=fs.open(p);
  assertTrue(in.available() > 0);
  byte[] buffer=new byte[1024];
  int read=in.read(buffer);
  assertEquals(tableName.getName().length,read);
  out.close();
  in.close();
  HLog wal=HLogFactory.createHLog(fs,dir,"hlogdir",conf);
  final AtomicLong sequenceId=new AtomicLong(1);
  final int total=20;
  HLog.Reader reader=null;
  try {
    HRegionInfo info=new HRegionInfo(tableName,null,null,false);
    HTableDescriptor htd=new HTableDescriptor();
    htd.addFamily(new HColumnDescriptor(tableName.getName()));
    for (int i=0; i < total; i++) {
      WALEdit kvs=new WALEdit();
      kvs.add(new KeyValue(Bytes.toBytes(i),tableName.getName(),tableName.getName()));
      wal.append(info,tableName,kvs,System.currentTimeMillis(),htd,sequenceId);
    }
    wal.sync();
    Path walPath=((FSHLog)wal).computeFilename();
    reader=HLogFactory.createReader(fs,walPath,conf);
    int count=0;
    HLog.Entry entry=new HLog.Entry();
    while ((entry=reader.next(entry)) != null)     count++;
    assertEquals(total,count);
    reader.close();
    for (int i=0; i < total; i++) {
      WALEdit kvs=new WALEdit();
      kvs.add(new KeyValue(Bytes.toBytes(i),tableName.getName(),tableName.getName()));
      wal.append(info,tableName,kvs,System.currentTimeMillis(),htd,sequenceId);
    }
    reader=HLogFactory.createReader(fs,walPath,conf);
    count=0;
    while ((entry=reader.next(entry)) != null)     count++;
    assertTrue(count >= total);
    reader.close();
    wal.sync();
    reader=HLogFactory.createReader(fs,walPath,conf);
    count=0;
    while ((entry=reader.next(entry)) != null)     count++;
    assertEquals(total * 2,count);
    final byte[] value=new byte[1025 * 1024];
    for (int i=0; i < total; i++) {
      WALEdit kvs=new WALEdit();
      kvs.add(new KeyValue(Bytes.toBytes(i),tableName.getName(),value));
      wal.append(info,tableName,kvs,System.currentTimeMillis(),htd,sequenceId);
    }
    wal.sync();
    reader=HLogFactory.createReader(fs,walPath,conf);
    count=0;
    while ((entry=reader.next(entry)) != null)     count++;
    assertEquals(total * 3,count);
    reader.close();
    wal.close();
    reader=HLogFactory.createReader(fs,walPath,conf);
    count=0;
    while ((entry=reader.next(entry)) != null)     count++;
    assertEquals(total * 3,count);
    reader.close();
  }
  finally {
    if (wal != null)     wal.closeAndDelete();
    if (reader != null)     reader.close();
  }
}
