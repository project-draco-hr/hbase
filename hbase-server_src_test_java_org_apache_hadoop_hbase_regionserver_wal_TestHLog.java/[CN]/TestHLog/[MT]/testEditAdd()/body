{
  final int COL_COUNT=10;
  final TableName tableName=TableName.valueOf("tablename");
  final byte[] row=Bytes.toBytes("row");
  HLog.Reader reader=null;
  HLog log=null;
  try {
    log=HLogFactory.createHLog(fs,hbaseDir,getName(),conf);
    final AtomicLong sequenceId=new AtomicLong(1);
    long timestamp=System.currentTimeMillis();
    WALEdit cols=new WALEdit();
    for (int i=0; i < COL_COUNT; i++) {
      cols.add(new KeyValue(row,Bytes.toBytes("column"),Bytes.toBytes(Integer.toString(i)),timestamp,new byte[]{(byte)(i + '0')}));
    }
    HRegionInfo info=new HRegionInfo(tableName,row,Bytes.toBytes(Bytes.toString(row) + "1"),false);
    HTableDescriptor htd=new HTableDescriptor();
    htd.addFamily(new HColumnDescriptor("column"));
    log.append(info,tableName,cols,System.currentTimeMillis(),htd,sequenceId);
    log.startCacheFlush(info.getEncodedNameAsBytes());
    log.completeCacheFlush(info.getEncodedNameAsBytes());
    log.close();
    Path filename=((FSHLog)log).computeFilename();
    log=null;
    reader=HLogFactory.createReader(fs,filename,conf);
    for (int i=0; i < 1; i++) {
      HLog.Entry entry=reader.next(null);
      if (entry == null)       break;
      HLogKey key=entry.getKey();
      WALEdit val=entry.getEdit();
      assertTrue(Bytes.equals(info.getEncodedNameAsBytes(),key.getEncodedRegionName()));
      assertTrue(tableName.equals(key.getTablename()));
      KeyValue kv=val.getKeyValues().get(0);
      assertTrue(Bytes.equals(row,kv.getRow()));
      assertEquals((byte)(i + '0'),kv.getValue()[0]);
      System.out.println(key + " " + val);
    }
  }
  finally {
    if (log != null) {
      log.closeAndDelete();
    }
    if (reader != null) {
      reader.close();
    }
  }
}
