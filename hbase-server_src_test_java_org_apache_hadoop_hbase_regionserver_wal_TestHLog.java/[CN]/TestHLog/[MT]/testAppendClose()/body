{
  byte[] tableName=Bytes.toBytes(getName());
  HRegionInfo regioninfo=new HRegionInfo(tableName,HConstants.EMPTY_START_ROW,HConstants.EMPTY_END_ROW,false);
  HLog wal=HLogFactory.createHLog(fs,dir,"hlogdir","hlogdir_archive",conf);
  final int total=20;
  HTableDescriptor htd=new HTableDescriptor();
  htd.addFamily(new HColumnDescriptor(tableName));
  for (int i=0; i < total; i++) {
    WALEdit kvs=new WALEdit();
    kvs.add(new KeyValue(Bytes.toBytes(i),tableName,tableName));
    wal.append(regioninfo,tableName,kvs,System.currentTimeMillis(),htd);
  }
  wal.sync();
  int namenodePort=cluster.getNameNodePort();
  final Path walPath=((FSHLog)wal).computeFilename();
  try {
    DistributedFileSystem dfs=(DistributedFileSystem)cluster.getFileSystem();
    dfs.setSafeMode(FSConstants.SafeModeAction.SAFEMODE_ENTER);
    TEST_UTIL.shutdownMiniDFSCluster();
    try {
      wal.close();
    }
 catch (    IOException e) {
      LOG.info(e);
    }
    fs.close();
    LOG.info("STOPPED first instance of the cluster");
  }
  finally {
    while (cluster.isClusterUp()) {
      LOG.error("Waiting for cluster to go down");
      Thread.sleep(1000);
    }
    assertFalse(cluster.isClusterUp());
    Thread.sleep(2000);
    LOG.info("Waiting a few seconds before re-starting HDFS");
    Thread.sleep(5000);
    cluster=TEST_UTIL.startMiniDFSClusterForTestHLog(namenodePort);
    cluster.waitActive();
    fs=cluster.getFileSystem();
    LOG.info("STARTED second instance.");
  }
  Method setLeasePeriod=cluster.getClass().getDeclaredMethod("setLeasePeriod",new Class[]{Long.TYPE,Long.TYPE});
  setLeasePeriod.setAccessible(true);
  setLeasePeriod.invoke(cluster,1000L,1000L);
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
    LOG.info(e);
  }
  final FileSystem recoveredFs=fs;
  final Configuration rlConf=conf;
class RecoverLogThread extends Thread {
    public Exception exception=null;
    public void run(){
      try {
        FSUtils.getInstance(fs,rlConf).recoverFileLease(recoveredFs,walPath,rlConf,null);
      }
 catch (      IOException e) {
        exception=e;
      }
    }
  }
  RecoverLogThread t=new RecoverLogThread();
  t.start();
  t.join(60 * 1000);
  if (t.isAlive()) {
    t.interrupt();
    throw new Exception("Timed out waiting for HLog.recoverLog()");
  }
  if (t.exception != null)   throw t.exception;
  HLog.Reader reader=HLogFactory.createReader(this.fs,walPath,this.conf);
  int count=0;
  HLog.Entry entry=new HLog.Entry();
  while (reader.next(entry) != null) {
    count++;
    assertTrue("Should be one KeyValue per WALEdit",entry.getEdit().getKeyValues().size() == 1);
  }
  assertEquals(total,count);
  reader.close();
  setLeasePeriod.invoke(cluster,new Object[]{new Long(60000),new Long(3600000)});
}
