{
  if (inputFileNames.size() != 1) {
    throw new IOException("Need exactly one input file for random reads: " + inputFileNames);
  }
  Path inputPath=new Path(inputFileNames.get(0));
  StoreFile storeFile=openStoreFile(inputPath,true);
  StoreFile.Reader reader=storeFile.createReader();
  LOG.info("First key: " + Bytes.toStringBinary(reader.getFirstKey()));
  LOG.info("Last key: " + Bytes.toStringBinary(reader.getLastKey()));
  KeyValue firstKV=KeyValue.createKeyValueFromKey(reader.getFirstKey());
  firstRow=firstKV.getRow();
  KeyValue lastKV=KeyValue.createKeyValueFromKey(reader.getLastKey());
  lastRow=lastKV.getRow();
  byte[] family=firstKV.getFamily();
  if (!Bytes.equals(family,lastKV.getFamily())) {
    LOG.error("First and last key have different families: " + Bytes.toStringBinary(family) + " and "+ Bytes.toStringBinary(lastKV.getFamily()));
    return false;
  }
  if (Bytes.equals(firstRow,lastRow)) {
    LOG.error("First and last row are the same, cannot run read workload: " + "firstRow=" + Bytes.toStringBinary(firstRow) + ", "+ "lastRow="+ Bytes.toStringBinary(lastRow));
    return false;
  }
  ExecutorService exec=Executors.newFixedThreadPool(numReadThreads + 1);
  int numCompleted=0;
  int numFailed=0;
  try {
    ExecutorCompletionService<Boolean> ecs=new ExecutorCompletionService<Boolean>(exec);
    endTime=System.currentTimeMillis() + 1000 * durationSec;
    boolean pread=true;
    for (int i=0; i < numReadThreads; ++i)     ecs.submit(new RandomReader(i,reader,pread));
    ecs.submit(new StatisticsPrinter());
    Future<Boolean> result;
    while (true) {
      try {
        result=ecs.poll(endTime + 1000 - System.currentTimeMillis(),TimeUnit.MILLISECONDS);
        if (result == null)         break;
        try {
          if (result.get()) {
            ++numCompleted;
          }
 else {
            ++numFailed;
          }
        }
 catch (        ExecutionException e) {
          LOG.error("Worker thread failure",e.getCause());
          ++numFailed;
        }
      }
 catch (      InterruptedException ex) {
        LOG.error("Interrupted after " + numCompleted + " workers completed");
        Thread.currentThread().interrupt();
        continue;
      }
    }
  }
  finally {
    storeFile.closeReader(true);
    exec.shutdown();
    BlockCache c=cacheConf.getBlockCache();
    if (c != null) {
      c.shutdown();
    }
  }
  LOG.info("Worker threads completed: " + numCompleted);
  LOG.info("Worker threads failed: " + numFailed);
  return true;
}
