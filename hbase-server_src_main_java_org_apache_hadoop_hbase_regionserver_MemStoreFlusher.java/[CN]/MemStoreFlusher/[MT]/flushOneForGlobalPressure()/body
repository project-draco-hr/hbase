{
  SortedMap<Long,HRegion> regionsBySize=server.getCopyOfOnlineRegionsSortedBySize();
  Set<HRegion> excludedRegions=new HashSet<HRegion>();
  boolean flushedOne=false;
  while (!flushedOne) {
    HRegion bestFlushableRegion=getBiggestMemstoreRegion(regionsBySize,excludedRegions,true);
    HRegion bestAnyRegion=getBiggestMemstoreRegion(regionsBySize,excludedRegions,false);
    if (bestAnyRegion == null) {
      LOG.error("Above memory mark but there are no flushable regions!");
      return false;
    }
    HRegion regionToFlush;
    if (bestFlushableRegion != null && bestAnyRegion.memstoreSize.get() > 2 * bestFlushableRegion.memstoreSize.get()) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Under global heap pressure: " + "Region " + bestAnyRegion.getRegionNameAsString() + " has too many "+ "store files, but is "+ TraditionalBinaryPrefix.long2String(bestAnyRegion.memstoreSize.get(),"",1)+ " vs best flushable region's "+ TraditionalBinaryPrefix.long2String(bestFlushableRegion.memstoreSize.get(),"",1)+ ". Choosing the bigger.");
      }
      regionToFlush=bestAnyRegion;
    }
 else {
      if (bestFlushableRegion == null) {
        regionToFlush=bestAnyRegion;
      }
 else {
        regionToFlush=bestFlushableRegion;
      }
    }
    Preconditions.checkState(regionToFlush.memstoreSize.get() > 0);
    LOG.info("Flush of region " + regionToFlush + " due to global heap pressure");
    flushedOne=flushRegion(regionToFlush,true,true);
    if (!flushedOne) {
      LOG.info("Excluding unflushable region " + regionToFlush + " - trying to find a different region to flush.");
      excludedRegions.add(regionToFlush);
    }
  }
  return true;
}
