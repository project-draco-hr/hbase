{
  if (isAboveHighWaterMark()) {
    long start=System.currentTimeMillis();
synchronized (this.blockSignal) {
      boolean blocked=false;
      long startTime=0;
      while (isAboveHighWaterMark() && !server.isStopped()) {
        if (!blocked) {
          startTime=EnvironmentEdgeManager.currentTimeMillis();
          LOG.info("Blocking updates on " + server.toString() + ": the global memstore size "+ StringUtils.humanReadableInt(server.getRegionServerAccounting().getGlobalMemstoreSize())+ " is >= than blocking "+ StringUtils.humanReadableInt(globalMemStoreLimit)+ " size");
        }
        blocked=true;
        wakeupFlushThread();
        try {
          blockSignal.wait(5 * 1000);
        }
 catch (        InterruptedException ie) {
          Thread.currentThread().interrupt();
        }
        long took=System.currentTimeMillis() - start;
        LOG.warn("Memstore is above high water mark and block " + took + "ms");
      }
      if (blocked) {
        final long totalTime=EnvironmentEdgeManager.currentTimeMillis() - startTime;
        if (totalTime > 0) {
          this.updatesBlockedMsHighWater.add(totalTime);
        }
        LOG.info("Unblocking updates for server " + server.toString());
      }
    }
  }
 else   if (isAboveLowWaterMark()) {
    wakeupFlushThread();
  }
}
