{
  try {
    HTableInterface table=null;
    this.lock.lock();
    while (!this.stop.get()) {
      this.newData.await(this.threadWakeFrequency,TimeUnit.MILLISECONDS);
      try {
        if (this.lastEditSize == this.editsSize.get()) {
          continue;
        }
        this.reader=HLog.getReader(this.fs,this.path,this.conf);
        if (position != 0) {
          this.reader.seek(position);
        }
        byte[] lastTable=HConstants.EMPTY_BYTE_ARRAY;
        List<Put> puts=new ArrayList<Put>();
        HLog.Entry entry=new HLog.Entry();
        while (this.reader.next(entry) != null) {
          KeyValue kv=entry.getEdit();
          if (kv.isDelete()) {
            Delete delete=new Delete(kv.getRow(),kv.getTimestamp(),null);
            if (kv.isDeleteFamily()) {
              delete.deleteFamily(kv.getFamily());
            }
 else             if (!kv.isEmptyColumn()) {
              delete.deleteColumn(entry.getEdit().getFamily(),kv.getQualifier());
            }
            table=pool.getTable(entry.getKey().getTablename());
            table.delete(delete);
            pool.putTable(table);
          }
 else {
            Put put=new Put(kv.getRow(),kv.getTimestamp(),null);
            put.add(entry.getEdit().getFamily(),kv.getQualifier(),kv.getValue());
            if (!Bytes.equals(lastTable,entry.getKey().getTablename()) && !puts.isEmpty()) {
              table=pool.getTable(lastTable);
              table.put(puts);
              pool.putTable(table);
              puts.clear();
            }
            lastTable=entry.getKey().getTablename();
            puts.add(put);
          }
        }
        if (!puts.isEmpty()) {
          table=pool.getTable(lastTable);
          table.put(puts);
          pool.putTable(table);
        }
        position=this.reader.getPosition();
        if (this.editsSize.get() > this.logrollsize) {
          rollLog();
        }
        this.lastEditSize=editsSize.get();
      }
 catch (      EOFException eof) {
        LOG.warn("Got EOF while reading, will continue on next notify");
      }
catch (      TableNotFoundException ex) {
        LOG.warn("Losing edits because: " + ex);
      }
 finally {
        this.newData.signal();
        if (this.reader != null) {
          this.reader.close();
        }
        this.reader=null;
      }
    }
    close();
  }
 catch (  Exception ex) {
    LOG.error("Unable to accept edit because",ex);
    this.stop.set(true);
  }
 finally {
    this.lock.unlock();
  }
}
