{
  inSync.set(false);
  lock.lock();
  try {
    while (isRunning()) {
      try {
        if (slotIndex == 0) {
          removeInactiveLogs();
          if (LOG.isTraceEnabled()) {
            float rollTsSec=getMillisFromLastRoll() / 1000.0f;
            LOG.trace(String.format("Waiting for data. flushed=%s (%s/sec)",StringUtils.humanSize(totalSynced.get()),StringUtils.humanSize(totalSynced.get() / rollTsSec)));
          }
          waitCond.await(getMillisToNextPeriodicRoll(),TimeUnit.MILLISECONDS);
          if (slotIndex == 0) {
            periodicRoll();
            continue;
          }
        }
        long syncWaitSt=System.currentTimeMillis();
        if (slotIndex != slots.length) {
          slotCond.await(syncWaitMsec,TimeUnit.MILLISECONDS);
        }
        long syncWaitMs=System.currentTimeMillis() - syncWaitSt;
        if (LOG.isTraceEnabled() && (syncWaitMs > 10 || slotIndex < slots.length)) {
          float rollSec=getMillisFromLastRoll() / 1000.0f;
          LOG.trace(String.format("Sync wait %s, slotIndex=%s , totalSynced=%s/sec",StringUtils.humanTimeDiff(syncWaitMs),slotIndex,StringUtils.humanSize(totalSynced.get()),StringUtils.humanSize(totalSynced.get() / rollSec)));
        }
        inSync.set(true);
        totalSynced.addAndGet(syncSlots());
        slotIndex=0;
        inSync.set(false);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        sendAbortProcessSignal();
        syncException.compareAndSet(null,e);
        throw e;
      }
catch (      Throwable t) {
        syncException.compareAndSet(null,t);
        throw t;
      }
 finally {
        syncCond.signalAll();
      }
    }
  }
  finally {
    lock.unlock();
  }
}
