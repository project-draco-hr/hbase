{
  final String tableNameStr="testReplayEditsWrittenIntoWAL";
  final HRegionInfo hri=createBasic3FamilyHRegionInfo(tableNameStr);
  final Path basedir=new Path(hbaseRootDir,tableNameStr);
  deleteDir(basedir);
  fs.mkdirs(new Path(basedir,hri.getEncodedName()));
  final HTableDescriptor htd=createBasic3FamilyHTD(tableNameStr);
  HRegion region2=HRegion.createHRegion(hri,hbaseRootDir,this.conf,htd);
  HRegion.closeHRegion(region2);
  final HLog wal=createWAL(this.conf);
  final byte[] tableName=Bytes.toBytes(tableNameStr);
  final byte[] rowName=tableName;
  final byte[] regionName=hri.getEncodedNameAsBytes();
  final int countPerFamily=1000;
  for (  HColumnDescriptor hcd : htd.getFamilies()) {
    addWALEdits(tableName,hri,rowName,hcd.getName(),countPerFamily,ee,wal,htd);
  }
  long logSeqId=wal.startCacheFlush(regionName);
  wal.completeCacheFlush(regionName,tableName,logSeqId,hri.isMetaRegion());
  WALEdit edit=new WALEdit();
  long now=ee.currentTimeMillis();
  edit.add(new KeyValue(rowName,Bytes.toBytes("another family"),rowName,now,rowName));
  wal.append(hri,tableName,edit,now,htd);
  edit=new WALEdit();
  now=ee.currentTimeMillis();
  edit.add(new KeyValue(rowName,Bytes.toBytes("c"),null,now,KeyValue.Type.DeleteFamily));
  wal.append(hri,tableName,edit,now,htd);
  wal.sync();
  HBaseTestingUtility.setMaxRecoveryErrorCount(((FSHLog)wal).getOutputStream(),1);
  final Configuration newConf=HBaseConfiguration.create(this.conf);
  User user=HBaseTestingUtility.getDifferentUser(newConf,".replay.wal.secondtime");
  user.runAs(new PrivilegedExceptionAction(){
    public Object run() throws Exception {
      runWALSplit(newConf);
      FileSystem newFS=FileSystem.get(newConf);
      newConf.setInt(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,1024 * 100);
      HLog newWal=createWAL(newConf);
      final AtomicInteger flushcount=new AtomicInteger(0);
      try {
        final HRegion region=new HRegion(basedir,newWal,newFS,newConf,hri,htd,null){
          protected boolean internalFlushcache(          final HLog wal,          final long myseqid,          MonitoredTask status) throws IOException {
            LOG.info("InternalFlushCache Invoked");
            boolean b=super.internalFlushcache(wal,myseqid,Mockito.mock(MonitoredTask.class));
            flushcount.incrementAndGet();
            return b;
          }
        }
;
        long seqid=region.initialize();
        assertTrue("Flushcount=" + flushcount.get(),flushcount.get() > 0);
        assertTrue(seqid > wal.getSequenceNumber());
        Get get=new Get(rowName);
        Result result=region.get(get);
        assertEquals(countPerFamily * (htd.getFamilies().size() - 1),result.size());
        region.close();
      }
  finally {
        newWal.closeAndDelete();
      }
      return null;
    }
  }
);
}
