{
  final TableName tableName=TableName.valueOf("testReplayEditsWrittenIntoWAL");
  final HRegionInfo hri=createBasic3FamilyHRegionInfo(tableName);
  final Path basedir=FSUtils.getTableDir(hbaseRootDir,tableName);
  deleteDir(basedir);
  final HTableDescriptor htd=createBasic3FamilyHTD(tableName);
  HRegion region2=HRegion.createHRegion(hri,hbaseRootDir,this.conf,htd);
  HRegion.closeHRegion(region2);
  final HLog wal=createWAL(this.conf);
  final byte[] rowName=tableName.getName();
  final byte[] regionName=hri.getEncodedNameAsBytes();
  final AtomicLong sequenceId=new AtomicLong(1);
  final int countPerFamily=1000;
  for (  HColumnDescriptor hcd : htd.getFamilies()) {
    addWALEdits(tableName,hri,rowName,hcd.getName(),countPerFamily,ee,wal,htd,sequenceId);
  }
  wal.startCacheFlush(regionName);
  wal.completeCacheFlush(regionName);
  WALEdit edit=new WALEdit();
  long now=ee.currentTimeMillis();
  edit.add(new KeyValue(rowName,Bytes.toBytes("another family"),rowName,now,rowName));
  wal.append(hri,tableName,edit,now,htd,sequenceId);
  edit=new WALEdit();
  now=ee.currentTimeMillis();
  edit.add(new KeyValue(rowName,Bytes.toBytes("c"),null,now,KeyValue.Type.DeleteFamily));
  wal.append(hri,tableName,edit,now,htd,sequenceId);
  wal.sync();
  HBaseTestingUtility.setMaxRecoveryErrorCount(((FSHLog)wal).getOutputStream(),1);
  final Configuration newConf=HBaseConfiguration.create(this.conf);
  User user=HBaseTestingUtility.getDifferentUser(newConf,".replay.wal.secondtime");
  user.runAs(new PrivilegedExceptionAction(){
    public Object run() throws Exception {
      runWALSplit(newConf);
      FileSystem newFS=FileSystem.get(newConf);
      newConf.setInt(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,1024 * 100);
      HLog newWal=createWAL(newConf);
      final AtomicInteger flushcount=new AtomicInteger(0);
      try {
        final HRegion region=new HRegion(basedir,newWal,newFS,newConf,hri,htd,null){
          protected FlushResult internalFlushcache(          final HLog wal,          final long myseqid,          MonitoredTask status) throws IOException {
            LOG.info("InternalFlushCache Invoked");
            FlushResult fs=super.internalFlushcache(wal,myseqid,Mockito.mock(MonitoredTask.class));
            flushcount.incrementAndGet();
            return fs;
          }
        }
;
        long seqid=region.initialize();
        assertTrue("Flushcount=" + flushcount.get(),flushcount.get() > 0);
        assertTrue(seqid - 1 == sequenceId.get());
        Get get=new Get(rowName);
        Result result=region.get(get);
        assertEquals(countPerFamily * (htd.getFamilies().size() - 1),result.size());
        region.close();
      }
  finally {
        newWal.closeAndDelete();
      }
      return null;
    }
  }
);
}
