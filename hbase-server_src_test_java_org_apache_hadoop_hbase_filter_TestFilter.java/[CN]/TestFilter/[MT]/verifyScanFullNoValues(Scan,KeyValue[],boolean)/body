{
  InternalScanner scanner=this.region.getScanner(s);
  List<KeyValue> results=new ArrayList<KeyValue>();
  int row=0;
  int idx=0;
  for (boolean more=true; more; row++) {
    more=scanner.next(results);
    Arrays.sort(results.toArray(new KeyValue[results.size()]),KeyValue.COMPARATOR);
    if (results.isEmpty())     break;
    assertTrue("Scanned too many keys! Only expected " + kvs.length + " total but already scanned "+ (results.size() + idx)+ (results.isEmpty() ? "" : "(" + results.get(0).toString() + ")"),kvs.length >= idx + results.size());
    for (    KeyValue kv : results) {
      LOG.info("row=" + row + ", result="+ kv.toString()+ ", match="+ kvs[idx].toString());
      assertTrue("Row mismatch",Bytes.equals(kv.getRow(),kvs[idx].getRow()));
      assertTrue("Family mismatch",Bytes.equals(kv.getFamily(),kvs[idx].getFamily()));
      assertTrue("Qualifier mismatch",Bytes.equals(kv.getQualifier(),kvs[idx].getQualifier()));
      assertFalse("Should not have returned whole value",Bytes.equals(kv.getValue(),kvs[idx].getValue()));
      if (useLen) {
        assertEquals("Value in result is not SIZEOF_INT",kv.getValue().length,Bytes.SIZEOF_INT);
        LOG.info("idx = " + idx + ", len="+ kvs[idx].getValueLength()+ ", actual="+ Bytes.toInt(kv.getValue()));
        assertEquals("Scan value should be the length of the actual value. ",kvs[idx].getValueLength(),Bytes.toInt(kv.getValue()));
        LOG.info("good");
      }
 else {
        assertEquals("Value in result is not empty",kv.getValue().length,0);
      }
      idx++;
    }
    results.clear();
  }
  LOG.info("Looked at " + row + " rows with "+ idx+ " keys");
  assertEquals("Expected " + kvs.length + " total keys but scanned "+ idx,kvs.length,idx);
}
