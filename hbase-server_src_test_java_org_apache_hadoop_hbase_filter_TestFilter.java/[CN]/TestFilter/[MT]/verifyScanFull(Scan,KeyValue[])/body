{
  InternalScanner scanner=this.region.getScanner(s);
  List<KeyValue> results=new ArrayList<KeyValue>();
  int row=0;
  int idx=0;
  for (boolean done=true; done; row++) {
    done=scanner.next(results);
    Arrays.sort(results.toArray(new KeyValue[results.size()]),KeyValue.COMPARATOR);
    if (results.isEmpty())     break;
    assertTrue("Scanned too many keys! Only expected " + kvs.length + " total but already scanned "+ (results.size() + idx)+ (results.isEmpty() ? "" : "(" + results.get(0).toString() + ")"),kvs.length >= idx + results.size());
    for (    KeyValue kv : results) {
      LOG.info("row=" + row + ", result="+ kv.toString()+ ", match="+ kvs[idx].toString());
      assertTrue("Row mismatch",Bytes.equals(kv.getRow(),kvs[idx].getRow()));
      assertTrue("Family mismatch",Bytes.equals(kv.getFamily(),kvs[idx].getFamily()));
      assertTrue("Qualifier mismatch",Bytes.equals(kv.getQualifier(),kvs[idx].getQualifier()));
      assertTrue("Value mismatch",Bytes.equals(kv.getValue(),kvs[idx].getValue()));
      idx++;
    }
    results.clear();
  }
  LOG.info("Looked at " + row + " rows with "+ idx+ " keys");
  assertEquals("Expected " + kvs.length + " total keys but scanned "+ idx,kvs.length,idx);
}
