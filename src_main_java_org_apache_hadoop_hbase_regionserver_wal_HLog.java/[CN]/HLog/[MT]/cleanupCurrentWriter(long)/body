{
  Path oldFile=null;
  if (this.writer != null) {
    try {
      if (this.unflushedEntries.get() != this.syncedTillHere) {
        LOG.debug("cleanupCurrentWriter " + " waiting for transactions to get synced " + " total " + this.unflushedEntries.get() + " synced till here "+ syncedTillHere);
        sync();
      }
      this.writer.close();
      closeErrorCount.set(0);
    }
 catch (    IOException e) {
      LOG.error("Failed close of HLog writer",e);
      int errors=closeErrorCount.incrementAndGet();
      if (errors <= closeErrorsTolerated) {
        LOG.warn("Riding over HLog close failure! error count=" + errors);
      }
 else {
        FailedLogCloseException flce=new FailedLogCloseException("#" + currentfilenum);
        flce.initCause(e);
        throw flce;
      }
    }
    if (currentfilenum >= 0) {
      oldFile=computeFilename(currentfilenum);
      this.outputfiles.put(Long.valueOf(this.logSeqNum.get()),oldFile);
    }
  }
  return oldFile;
}
