{
  if (this.writer != null && this.numEntries.get() <= 0) {
    return null;
  }
  byte[][] regionsToFlush=null;
  try {
    if (this.cacheFlushLock.tryLock(this.cacheFlushLockWaitTime,TimeUnit.MILLISECONDS)) {
      try {
        if (closed) {
          return regionsToFlush;
        }
        this.logRollRequested=true;
        long currentFilenum=this.filenum;
        this.filenum=System.currentTimeMillis();
        Path newPath=computeFilename();
        HLog.Writer nextWriter=this.createWriterInstance(fs,newPath,conf);
        int nextInitialReplication=fs.getFileStatus(newPath).getReplication();
        int nextExpectReplicas=fs.getFileStatus(newPath).getReplication();
        int nextActualReplicas=-1;
        FSDataOutputStream nextHdfsOut=null;
        if (nextWriter instanceof SequenceFileLogWriter) {
          nextHdfsOut=((SequenceFileLogWriter)nextWriter).getWriterFSDataOutputStream();
        }
        if (!this.listeners.isEmpty()) {
          for (          WALObserver i : this.listeners) {
            i.logRolled(newPath);
          }
        }
synchronized (updateLock) {
          Path oldFile=cleanupCurrentWriter(currentFilenum);
          this.writer=nextWriter;
          this.hdfs_out=nextHdfsOut;
          this.initialReplication=nextInitialReplication;
          LOG.info((oldFile != null ? "Roll " + FSUtils.getPath(oldFile) + ", entries="+ this.numEntries.get()+ ", filesize="+ this.fs.getFileStatus(oldFile).getLen()+ ". " : "") + "New hlog " + FSUtils.getPath(newPath));
          this.numEntries.set(0);
          this.logRollRequested=false;
        }
        if (this.outputfiles.size() > 0) {
          if (this.lastSeqWritten.isEmpty()) {
            LOG.debug("Last sequenceid written is empty. Deleting all old hlogs");
            for (            Map.Entry<Long,Path> e : this.outputfiles.entrySet()) {
              archiveLogFile(e.getValue(),e.getKey());
            }
            this.outputfiles.clear();
          }
 else {
            regionsToFlush=cleanOldLogs();
          }
        }
      }
  finally {
        this.cacheFlushLock.unlock();
      }
    }
 else {
      LOG.debug("Didn't obtain cacheFlushLock in time");
    }
  }
 catch (  InterruptedException e) {
    LOG.warn("Interrupted rollWriter",e);
    Thread.currentThread().interrupt();
  }
  return regionsToFlush;
}
