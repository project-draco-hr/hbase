{
  if (!force && this.writer != null && this.numEntries.get() <= 0) {
    return null;
  }
  byte[][] regionsToFlush=null;
  this.cacheFlushLock.lock();
  this.logRollRunning=true;
  try {
    if (closed) {
      LOG.debug("HLog closed.  Skipping rolling of writer");
      return regionsToFlush;
    }
    long currentFilenum=this.filenum;
    Path oldPath=null;
    if (currentFilenum > 0) {
      oldPath=computeFilename(currentFilenum);
    }
    this.filenum=System.currentTimeMillis();
    Path newPath=computeFilename();
    if (LOG.isDebugEnabled()) {
      LOG.debug("Enabling new writer for " + FSUtils.getPath(newPath));
    }
    if (!this.listeners.isEmpty()) {
      for (      WALActionsListener i : this.listeners) {
        i.preLogRoll(oldPath,newPath);
      }
    }
    HLog.Writer nextWriter=this.createWriterInstance(fs,newPath,conf);
    FSDataOutputStream nextHdfsOut=null;
    if (nextWriter instanceof SequenceFileLogWriter) {
      nextHdfsOut=((SequenceFileLogWriter)nextWriter).getWriterFSDataOutputStream();
    }
    if (!this.listeners.isEmpty()) {
      for (      WALActionsListener i : this.listeners) {
        i.postLogRoll(oldPath,newPath);
      }
    }
synchronized (updateLock) {
      Path oldFile=cleanupCurrentWriter(currentFilenum);
      this.writer=nextWriter;
      this.hdfs_out=nextHdfsOut;
      LOG.info((oldFile != null ? "Roll " + FSUtils.getPath(oldFile) + ", entries="+ this.numEntries.get()+ ", filesize="+ this.fs.getFileStatus(oldFile).getLen()+ ". " : "") + "New hlog " + FSUtils.getPath(newPath));
      this.numEntries.set(0);
    }
    if (this.outputfiles.size() > 0) {
      if (this.lastSeqWritten.isEmpty()) {
        LOG.debug("Last sequenceid written is empty. Deleting all old hlogs");
        for (        Map.Entry<Long,Path> e : this.outputfiles.entrySet()) {
          archiveLogFile(e.getValue(),e.getKey());
        }
        this.outputfiles.clear();
      }
 else {
        regionsToFlush=cleanOldLogs();
      }
    }
  }
  finally {
    this.logRollRunning=false;
    this.cacheFlushLock.unlock();
  }
  return regionsToFlush;
}
