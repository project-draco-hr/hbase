{
  return new Callable<Void>(){
    public String getName(){
      return "Split writer thread for region " + Bytes.toStringBinary(region);
    }
    @Override public Void call() throws IOException {
      LinkedList<Entry> entries=logEntries.get(region);
      LOG.debug(this.getName() + " got " + entries.size()+ " to process");
      long threadTime=System.currentTimeMillis();
      try {
        int editsCount=0;
        WriterAndPath wap=logWriters.get(region);
        for (ListIterator<Entry> iterator=entries.listIterator(entries.size()); iterator.hasPrevious(); ) {
          Entry logEntry=iterator.previous();
          if (wap == null) {
            Path logFile=getRegionLogPath(logEntry,rootDir);
            if (fs.exists(logFile)) {
              LOG.warn("Found existing old hlog file. It could be the result of a previous" + "failed split attempt. Deleting " + logFile + ", length="+ fs.getFileStatus(logFile).getLen());
              fs.delete(logFile,false);
            }
            Writer w=createWriter(fs,logFile,conf);
            wap=new WriterAndPath(logFile,w);
            logWriters.put(region,wap);
            LOG.debug("Creating writer path=" + logFile + " region="+ Bytes.toStringBinary(region));
          }
          wap.w.append(logEntry);
          editsCount++;
        }
        LOG.debug(this.getName() + " Applied " + editsCount+ " total edits to "+ Bytes.toStringBinary(region)+ " in "+ (System.currentTimeMillis() - threadTime)+ "ms");
      }
 catch (      IOException e) {
        e=RemoteExceptionHandler.checkIOException(e);
        LOG.fatal(this.getName() + " Got while writing log entry to log",e);
        throw e;
      }
      return null;
    }
  }
;
}
