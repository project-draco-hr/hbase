{
  if (!cacheEnabled)   return;
  if (backingMap.containsKey(cacheKey) || ramCache.containsKey(cacheKey))   return;
  RAMQueueEntry re=new RAMQueueEntry(cacheKey,cachedItem,accessCount.incrementAndGet(),inMemory);
  ramCache.put(cacheKey,re);
  int queueNum=(cacheKey.hashCode() & 0x7FFFFFFF) % writerQueues.size();
  BlockingQueue<RAMQueueEntry> bq=writerQueues.get(queueNum);
  boolean successfulAddition=bq.offer(re);
  if (!successfulAddition && wait) {
synchronized (cacheWaitSignals[queueNum]) {
      try {
        successfulAddition=bq.offer(re);
        if (!successfulAddition)         cacheWaitSignals[queueNum].wait(DEFAULT_CACHE_WAIT_TIME);
      }
 catch (      InterruptedException ie) {
        Thread.currentThread().interrupt();
      }
    }
    successfulAddition=bq.offer(re);
  }
  if (!successfulAddition) {
    ramCache.remove(cacheKey);
    failedBlockAdditions.incrementAndGet();
  }
 else {
    this.blockNumber.incrementAndGet();
    this.heapSize.addAndGet(cachedItem.heapSize());
    blocksByHFile.put(cacheKey.getHfileName(),cacheKey);
  }
}
