{
  if (!cacheEnabled) {
    return null;
  }
  RAMQueueEntry re=ramCache.get(key);
  if (re != null) {
    if (updateCacheMetrics) {
      cacheStats.hit(caching);
    }
    re.access(accessCount.incrementAndGet());
    return re.getData();
  }
  BucketEntry bucketEntry=backingMap.get(key);
  if (bucketEntry != null) {
    long start=System.nanoTime();
    IdLock.Entry lockEntry=null;
    try {
      lockEntry=offsetLock.getLockEntry(bucketEntry.offset());
      if (bucketEntry.equals(backingMap.get(key))) {
        int len=bucketEntry.getLength();
        Pair<ByteBuff,MemoryType> pair=ioEngine.read(bucketEntry.offset(),len);
        ByteBuff bb=pair.getFirst();
        CacheableDeserializer<Cacheable> deserializer=bucketEntry.deserializerReference(this.deserialiserMap);
        Cacheable cachedBlock=deserializer.deserialize(bb,true,pair.getSecond());
        long timeTaken=System.nanoTime() - start;
        if (updateCacheMetrics) {
          cacheStats.hit(caching);
          cacheStats.ioHit(timeTaken);
        }
        if (pair.getSecond() == MemoryType.SHARED) {
          bucketEntry.refCount.incrementAndGet();
        }
        bucketEntry.access(accessCount.incrementAndGet());
        if (this.ioErrorStartTime > 0) {
          ioErrorStartTime=-1;
        }
        return cachedBlock;
      }
    }
 catch (    IOException ioex) {
      LOG.error("Failed reading block " + key + " from bucket cache",ioex);
      checkIOErrorIsTolerated();
    }
 finally {
      if (lockEntry != null) {
        offsetLock.releaseLockEntry(lockEntry);
      }
    }
  }
  if (!repeat && updateCacheMetrics) {
    cacheStats.miss(caching);
  }
  return null;
}
