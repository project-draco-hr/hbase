{
  while (!this.server.isStopped()) {
    FlushQueueEntry fqe=null;
    try {
      wakeupPending.set(false);
      fqe=flushQueue.poll(threadWakeFrequency,TimeUnit.MILLISECONDS);
      if (fqe == null || fqe instanceof WakeupFlushThread) {
        if (isAboveLowWaterMark()) {
          LOG.debug("Flush thread woke up because memory above low water=" + StringUtils.humanReadableInt(this.globalMemStoreLimitLowMark));
          if (!flushOneForGlobalPressure()) {
            lock.lock();
            try {
              Thread.sleep(1000);
              flushOccurred.signalAll();
            }
  finally {
              lock.unlock();
            }
          }
          wakeupFlushThread();
        }
        continue;
      }
      FlushRegionEntry fre=(FlushRegionEntry)fqe;
      if (!flushRegion(fre)) {
        break;
      }
    }
 catch (    InterruptedException ex) {
      continue;
    }
catch (    ConcurrentModificationException ex) {
      continue;
    }
catch (    Exception ex) {
      LOG.error("Cache flusher failed for entry " + fqe,ex);
      if (!server.checkFileSystem()) {
        break;
      }
    }
  }
  this.regionsInQueue.clear();
  this.flushQueue.clear();
  lock.lock();
  try {
    flushOccurred.signalAll();
  }
  finally {
    lock.unlock();
  }
  LOG.info(getName() + " exiting");
}
