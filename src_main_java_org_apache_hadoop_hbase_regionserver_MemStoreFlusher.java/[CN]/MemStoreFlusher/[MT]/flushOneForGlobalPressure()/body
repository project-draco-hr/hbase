{
  SortedMap<Long,HRegion> regionsBySize=server.getCopyOfOnlineRegionsSortedBySize();
  Set<byte[]> excludedRegionNames=new TreeSet<byte[]>(Bytes.BYTES_COMPARATOR);
  boolean flushedOne=false;
  while (!flushedOne) {
    HRegion bestFlushableRegion=getBiggestMemstoreRegion(regionsBySize,excludedRegionNames,true);
    HRegion bestAnyRegion=getBiggestMemstoreRegion(regionsBySize,excludedRegionNames,false);
    if (bestAnyRegion == null) {
      LOG.fatal("Above memory mark but there are no flushable regions!");
      return false;
    }
    HRegion regionToFlush;
    if (bestAnyRegion.memstoreSize.get() > 2 * bestFlushableRegion.memstoreSize.get()) {
      LOG.info("Under global heap pressure: " + "Region " + bestAnyRegion.getRegionNameAsString() + " has too many "+ "store files, but is "+ StringUtils.humanReadableInt(bestAnyRegion.memstoreSize.get())+ " vs best flushable region's "+ StringUtils.humanReadableInt(bestFlushableRegion.memstoreSize.get())+ ". Choosing the bigger.");
      regionToFlush=bestAnyRegion;
    }
 else {
      regionToFlush=bestFlushableRegion;
    }
    Preconditions.checkState(regionToFlush.memstoreSize.get() > 0);
    LOG.info("Flush of region " + regionToFlush + " due to global heap pressure");
    flushedOne=flushRegion(regionToFlush,true);
    if (!flushedOne) {
      LOG.info("Excluding unflushable region " + regionToFlush + " - trying to find a different region to flush.");
      excludedRegionNames.add(regionToFlush.getRegionName());
    }
  }
  return true;
}
