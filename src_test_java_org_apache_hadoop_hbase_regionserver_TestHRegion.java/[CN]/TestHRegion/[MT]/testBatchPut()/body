{
  byte[] b=Bytes.toBytes(getName());
  byte[] cf=Bytes.toBytes(COLUMN_FAMILY);
  byte[] qual=Bytes.toBytes("qual");
  byte[] val=Bytes.toBytes("val");
  initHRegion(b,getName(),cf);
  HLog.getSyncTime();
  assertEquals(0,HLog.getSyncTime().count);
  LOG.info("First a batch put with all valid puts");
  final Put[] puts=new Put[10];
  for (int i=0; i < 10; i++) {
    puts[i]=new Put(Bytes.toBytes("row_" + i));
    puts[i].add(cf,qual,val);
  }
  OperationStatus[] codes=this.region.put(puts);
  assertEquals(10,codes.length);
  for (int i=0; i < 10; i++) {
    assertEquals(OperationStatusCode.SUCCESS,codes[i].getOperationStatusCode());
  }
  assertEquals(1,HLog.getSyncTime().count);
  LOG.info("Next a batch put with one invalid family");
  puts[5].add(Bytes.toBytes("BAD_CF"),qual,val);
  codes=this.region.put(puts);
  assertEquals(10,codes.length);
  for (int i=0; i < 10; i++) {
    assertEquals((i == 5) ? OperationStatusCode.SANITY_CHECK_FAILURE : OperationStatusCode.SUCCESS,codes[i].getOperationStatusCode());
  }
  assertEquals(1,HLog.getSyncTime().count);
  LOG.info("Next a batch put that has to break into two batches to avoid a lock");
  Integer lockedRow=region.obtainRowLock(Bytes.toBytes("row_2"));
  MultithreadedTestUtil.TestContext ctx=new MultithreadedTestUtil.TestContext(HBaseConfiguration.create());
  final AtomicReference<OperationStatus[]> retFromThread=new AtomicReference<OperationStatus[]>();
  TestThread putter=new TestThread(ctx){
    @Override public void doWork() throws IOException {
      retFromThread.set(region.put(puts));
    }
  }
;
  LOG.info("...starting put thread while holding lock");
  ctx.addThread(putter);
  ctx.startThreads();
  LOG.info("...waiting for put thread to sync first time");
  long startWait=System.currentTimeMillis();
  while (HLog.getSyncTime().count == 0) {
    Thread.sleep(100);
    if (System.currentTimeMillis() - startWait > 10000) {
      fail("Timed out waiting for thread to sync first minibatch");
    }
  }
  LOG.info("...releasing row lock, which should let put thread continue");
  region.releaseRowLock(lockedRow);
  LOG.info("...joining on thread");
  ctx.stop();
  LOG.info("...checking that next batch was synced");
  assertEquals(1,HLog.getSyncTime().count);
  codes=retFromThread.get();
  for (int i=0; i < 10; i++) {
    assertEquals((i == 5) ? OperationStatusCode.SANITY_CHECK_FAILURE : OperationStatusCode.SUCCESS,codes[i].getOperationStatusCode());
  }
  LOG.info("Nexta, a batch put which uses an already-held lock");
  lockedRow=region.obtainRowLock(Bytes.toBytes("row_2"));
  LOG.info("...obtained row lock");
  List<Pair<Put,Integer>> putsAndLocks=Lists.newArrayList();
  for (int i=0; i < 10; i++) {
    Pair<Put,Integer> pair=new Pair<Put,Integer>(puts[i],null);
    if (i == 2)     pair.setSecond(lockedRow);
    putsAndLocks.add(pair);
  }
  codes=region.put(putsAndLocks.toArray(new Pair[0]));
  LOG.info("...performed put");
  for (int i=0; i < 10; i++) {
    assertEquals((i == 5) ? OperationStatusCode.SANITY_CHECK_FAILURE : OperationStatusCode.SUCCESS,codes[i].getOperationStatusCode());
  }
  assertEquals(1,HLog.getSyncTime().count);
  assertTrue(region.isRowLocked(lockedRow));
  LOG.info("...releasing lock");
  region.releaseRowLock(lockedRow);
}
