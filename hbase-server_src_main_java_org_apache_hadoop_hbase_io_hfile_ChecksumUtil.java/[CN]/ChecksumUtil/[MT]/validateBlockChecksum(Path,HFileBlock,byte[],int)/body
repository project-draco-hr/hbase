{
  if (!block.getHFileContext().isUseHBaseChecksum()) {
    return false;
  }
  ChecksumType cktype=ChecksumType.codeToType(block.getChecksumType());
  if (cktype == ChecksumType.NULL) {
    return true;
  }
  Checksum checksumObject=cktype.getChecksumObject();
  checksumObject.reset();
  int bytesPerChecksum=block.getBytesPerChecksum();
  if (bytesPerChecksum < hdrSize) {
    String msg="Unsupported value of bytesPerChecksum. " + " Minimum is " + hdrSize + " but the configured value is "+ bytesPerChecksum;
    HFile.LOG.warn(msg);
    return false;
  }
  ByteBuffer hdr=block.getBufferWithHeader();
  if (hdr.hasArray()) {
    checksumObject.update(hdr.array(),hdr.arrayOffset(),hdrSize);
  }
 else {
    checksumObject.update(ByteBufferUtils.toBytes(hdr,0,hdrSize),0,hdrSize);
  }
  int off=hdrSize;
  int consumed=hdrSize;
  int bytesLeft=block.getOnDiskDataSizeWithHeader() - off;
  int cksumOffset=block.getOnDiskDataSizeWithHeader();
  while (bytesLeft > 0) {
    int thisChunkSize=bytesPerChecksum - consumed;
    int count=Math.min(bytesLeft,thisChunkSize);
    checksumObject.update(data,off,count);
    int storedChecksum=Bytes.toInt(data,cksumOffset);
    if (storedChecksum != (int)checksumObject.getValue()) {
      String msg="File " + path + " Stored checksum value of "+ storedChecksum+ " at offset "+ cksumOffset+ " does not match computed checksum "+ checksumObject.getValue()+ ", total data size "+ data.length+ " Checksum data range offset "+ off+ " len "+ count+ HFileBlock.toStringHeader(block.getBufferReadOnly());
      HFile.LOG.warn(msg);
      if (generateExceptions) {
        throw new IOException(msg);
      }
 else {
        return false;
      }
    }
    cksumOffset+=HFileBlock.CHECKSUM_SIZE;
    bytesLeft-=count;
    off+=count;
    consumed=0;
    checksumObject.reset();
  }
  return true;
}
