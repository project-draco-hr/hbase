{
  boolean quiesceRequested=false;
  Sleeper sleeper=new Sleeper(this.msgInterval,this.stopRequested);
  try {
    init(reportForDuty(sleeper));
    long lastMsg=0;
    for (int tries=0; !stopRequested.get() && isHealthy(); ) {
      long now=System.currentTimeMillis();
      if (lastMsg != 0 && (now - lastMsg) >= serverLeaseTimeout) {
        LOG.fatal("unable to report to master for " + (now - lastMsg) + " milliseconds - aborting server");
        abort();
        break;
      }
      if ((now - lastMsg) >= msgInterval) {
        HMsg outboundArray[]=null;
synchronized (this.outboundMsgs) {
          outboundArray=this.outboundMsgs.toArray(new HMsg[outboundMsgs.size()]);
          this.outboundMsgs.clear();
        }
        try {
          this.serverInfo.setLoad(new HServerLoad(requestCount.get(),onlineRegions.size()));
          this.requestCount.set(0);
          HMsg msgs[]=hbaseMaster.regionServerReport(serverInfo,outboundArray,getMostLoadedRegions());
          lastMsg=System.currentTimeMillis();
          if (this.quiesced.get() && onlineRegions.size() == 0) {
            LOG.info("Server quiesced and not serving any regions. " + "Starting shutdown");
            stopRequested.set(true);
            this.outboundMsgs.clear();
            continue;
          }
          boolean restart=false;
          for (int i=0; !restart && !stopRequested.get() && i < msgs.length; i++) {
            LOG.info(msgs[i].toString());
switch (msgs[i].getType()) {
case MSG_CALL_SERVER_STARTUP:
              if (checkFileSystem()) {
                closeAllRegions();
                try {
                  log.closeAndDelete();
                }
 catch (                Exception e) {
                  LOG.error("error closing and deleting HLog",e);
                }
                try {
                  serverInfo.setStartCode(System.currentTimeMillis());
                  log=setupHLog();
                }
 catch (                IOException e) {
                  this.abortRequested=true;
                  this.stopRequested.set(true);
                  e=RemoteExceptionHandler.checkIOException(e);
                  LOG.fatal("error restarting server",e);
                  break;
                }
                reportForDuty(sleeper);
                restart=true;
              }
 else {
                LOG.fatal("file system available check failed. " + "Shutting down server.");
              }
            break;
case MSG_REGIONSERVER_STOP:
          stopRequested.set(true);
        break;
case MSG_REGIONSERVER_QUIESCE:
      if (!quiesceRequested) {
        try {
          toDo.put(new ToDoEntry(msgs[i]));
        }
 catch (        InterruptedException e) {
          throw new RuntimeException("Putting into msgQueue was " + "interrupted.",e);
        }
        quiesceRequested=true;
      }
    break;
default :
  if (fsOk) {
    try {
      toDo.put(new ToDoEntry(msgs[i]));
    }
 catch (    InterruptedException e) {
      throw new RuntimeException("Putting into msgQueue was " + "interrupted.",e);
    }
  }
}
}
tries=0;
if (restart || this.stopRequested.get()) {
toDo.clear();
continue;
}
}
 catch (Exception e) {
if (e instanceof IOException) {
e=RemoteExceptionHandler.checkIOException((IOException)e);
}
if (tries < this.numRetries) {
LOG.warn("Processing message (Retry: " + tries + ")",e);
tries++;
}
 else {
LOG.fatal("Exceeded max retries: " + this.numRetries,e);
if (!checkFileSystem()) {
continue;
}
stop();
}
}
}
housekeeping();
sleeper.sleep(lastMsg);
}
}
 catch (OutOfMemoryError error) {
abort();
LOG.fatal("Ran out of memory",error);
}
catch (Throwable t) {
LOG.fatal("Unhandled exception. Aborting...",t);
abort();
}
RegionHistorian.getInstance().offline();
this.leases.closeAfterLeasesExpire();
this.worker.stop();
this.server.stop();
if (this.infoServer != null) {
LOG.info("Stopping infoServer");
try {
this.infoServer.stop();
}
 catch (InterruptedException ex) {
ex.printStackTrace();
}
}
cacheFlusher.interruptIfNecessary();
compactSplitThread.interruptIfNecessary();
this.logRoller.interruptIfNecessary();
if (abortRequested) {
if (this.fsOk) {
try {
if (this.log != null) {
this.log.close();
LOG.info("On abort, closed hlog");
}
}
 catch (IOException e) {
LOG.error("Unable to close log in abort",RemoteExceptionHandler.checkIOException(e));
}
closeAllRegions();
}
LOG.info("aborting server at: " + serverInfo.getServerAddress().toString());
}
 else {
ArrayList<HRegion> closedRegions=closeAllRegions();
try {
log.closeAndDelete();
}
 catch (IOException e) {
LOG.error("Close and delete failed",RemoteExceptionHandler.checkIOException(e));
}
try {
HMsg[] exitMsg=new HMsg[closedRegions.size() + 1];
exitMsg[0]=HMsg.REPORT_EXITING;
int i=1;
for (HRegion region : closedRegions) {
exitMsg[i++]=new HMsg(HMsg.Type.MSG_REPORT_CLOSE,region.getRegionInfo());
}
LOG.info("telling master that region server is shutting down at: " + serverInfo.getServerAddress().toString());
hbaseMaster.regionServerReport(serverInfo,exitMsg,(HRegionInfo[])null);
}
 catch (IOException e) {
LOG.warn("Failed to send exiting message to master: ",RemoteExceptionHandler.checkIOException(e));
}
LOG.info("stopping server at: " + serverInfo.getServerAddress().toString());
}
if (this.hbaseMaster != null) {
HbaseRPC.stopProxy(this.hbaseMaster);
this.hbaseMaster=null;
}
join();
LOG.info(Thread.currentThread().getName() + " exiting");
}
