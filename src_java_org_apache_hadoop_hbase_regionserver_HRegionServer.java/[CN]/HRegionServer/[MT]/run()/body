{
  boolean quiesceRequested=false;
  Sleeper sleeper=new Sleeper(this.msgInterval,this.stopRequested);
  try {
    init(reportForDuty(sleeper));
    long lastMsg=0;
    for (int tries=0; !stopRequested.get() && isHealthy(); ) {
      if (!haveRootRegion.get()) {
        HServerAddress rootServer=hbaseMaster.getRootRegionLocation();
        if (rootServer != null) {
          this.connection.setRootRegionLocation(new HRegionLocation(HRegionInfo.ROOT_REGIONINFO,rootServer));
          haveRootRegion.set(true);
        }
      }
      long now=System.currentTimeMillis();
      if (lastMsg != 0 && (now - lastMsg) >= serverLeaseTimeout) {
        LOG.warn("unable to report to master for " + (now - lastMsg) + " milliseconds - retrying");
      }
      if ((now - lastMsg) >= msgInterval) {
        HMsg outboundArray[]=null;
synchronized (this.outboundMsgs) {
          outboundArray=this.outboundMsgs.toArray(new HMsg[outboundMsgs.size()]);
          this.outboundMsgs.clear();
        }
        try {
          doMetrics();
          MemoryUsage memory=ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();
          HServerLoad hsl=new HServerLoad(requestCount.get(),(int)(memory.getUsed() / 1024 / 1024),(int)(memory.getMax() / 1024 / 1024));
          for (          HRegion r : onlineRegions.values()) {
            hsl.addRegionInfo(createRegionLoad(r));
          }
          this.serverInfo.setLoad(hsl);
          this.requestCount.set(0);
          HMsg msgs[]=hbaseMaster.regionServerReport(serverInfo,outboundArray,getMostLoadedRegions());
          lastMsg=System.currentTimeMillis();
          if (this.quiesced.get() && onlineRegions.size() == 0) {
            LOG.info("Server quiesced and not serving any regions. " + "Starting shutdown");
            stopRequested.set(true);
            this.outboundMsgs.clear();
            continue;
          }
          boolean restart=false;
          for (int i=0; !restart && !stopRequested.get() && i < msgs.length; i++) {
            LOG.info(msgs[i].toString());
switch (msgs[i].getType()) {
case MSG_CALL_SERVER_STARTUP:
              if (checkFileSystem()) {
                closeAllRegions();
                try {
                  log.closeAndDelete();
                }
 catch (                Exception e) {
                  LOG.error("error closing and deleting HLog",e);
                }
                try {
                  serverInfo.setStartCode(System.currentTimeMillis());
                  log=setupHLog();
                  this.logFlusher.setHLog(log);
                }
 catch (                IOException e) {
                  this.abortRequested=true;
                  this.stopRequested.set(true);
                  e=RemoteExceptionHandler.checkIOException(e);
                  LOG.fatal("error restarting server",e);
                  break;
                }
                reportForDuty(sleeper);
                restart=true;
              }
 else {
                LOG.fatal("file system available check failed. " + "Shutting down server.");
              }
            break;
case MSG_REGIONSERVER_STOP:
          stopRequested.set(true);
        break;
case MSG_REGIONSERVER_QUIESCE:
      if (!quiesceRequested) {
        try {
          toDo.put(new ToDoEntry(msgs[i]));
        }
 catch (        InterruptedException e) {
          throw new RuntimeException("Putting into msgQueue was " + "interrupted.",e);
        }
        quiesceRequested=true;
      }
    break;
default :
  if (fsOk) {
    try {
      toDo.put(new ToDoEntry(msgs[i]));
    }
 catch (    InterruptedException e) {
      throw new RuntimeException("Putting into msgQueue was " + "interrupted.",e);
    }
  }
}
}
tries=0;
if (restart || this.stopRequested.get()) {
toDo.clear();
continue;
}
}
 catch (Exception e) {
if (e instanceof IOException) {
e=RemoteExceptionHandler.checkIOException((IOException)e);
}
if (tries < this.numRetries) {
LOG.warn("Processing message (Retry: " + tries + ")",e);
tries++;
}
 else {
LOG.error("Exceeded max retries: " + this.numRetries,e);
checkFileSystem();
}
if (this.stopRequested.get()) {
LOG.info("Stop was requested, clearing the toDo " + "despite of the exception");
toDo.clear();
continue;
}
}
}
housekeeping();
sleeper.sleep(lastMsg);
}
}
 catch (Throwable t) {
if (!checkOOME(t)) {
LOG.fatal("Unhandled exception. Aborting...",t);
abort();
}
}
RegionHistorian.getInstance().offline();
this.leases.closeAfterLeasesExpire();
this.worker.stop();
this.server.stop();
if (this.infoServer != null) {
LOG.info("Stopping infoServer");
try {
this.infoServer.stop();
}
 catch (InterruptedException ex) {
ex.printStackTrace();
}
}
cacheFlusher.interruptIfNecessary();
logFlusher.interrupt();
compactSplitThread.interruptIfNecessary();
logRoller.interruptIfNecessary();
this.majorCompactionChecker.interrupt();
if (abortRequested) {
if (this.fsOk) {
try {
if (this.log != null) {
this.log.close();
LOG.info("On abort, closed hlog");
}
}
 catch (Throwable e) {
LOG.error("Unable to close log in abort",RemoteExceptionHandler.checkThrowable(e));
}
closeAllRegions();
}
LOG.info("aborting server at: " + serverInfo.getServerAddress().toString());
}
 else {
ArrayList<HRegion> closedRegions=closeAllRegions();
try {
log.closeAndDelete();
}
 catch (Throwable e) {
LOG.error("Close and delete failed",RemoteExceptionHandler.checkThrowable(e));
}
try {
HMsg[] exitMsg=new HMsg[closedRegions.size() + 1];
exitMsg[0]=HMsg.REPORT_EXITING;
int i=1;
for (HRegion region : closedRegions) {
exitMsg[i++]=new HMsg(HMsg.Type.MSG_REPORT_CLOSE,region.getRegionInfo());
}
LOG.info("telling master that region server is shutting down at: " + serverInfo.getServerAddress().toString());
hbaseMaster.regionServerReport(serverInfo,exitMsg,(HRegionInfo[])null);
}
 catch (Throwable e) {
LOG.warn("Failed to send exiting message to master: ",RemoteExceptionHandler.checkThrowable(e));
}
LOG.info("stopping server at: " + serverInfo.getServerAddress().toString());
}
if (this.hbaseMaster != null) {
HBaseRPC.stopProxy(this.hbaseMaster);
this.hbaseMaster=null;
}
join();
LOG.info("Running hdfs shutdown thread");
hdfsShutdownThread.start();
try {
hdfsShutdownThread.join();
LOG.info("Hdfs shutdown thread completed.");
}
 catch (InterruptedException e) {
LOG.warn("hdfsShutdownThread.join() was interrupted",e);
}
LOG.info(Thread.currentThread().getName() + " exiting");
}
