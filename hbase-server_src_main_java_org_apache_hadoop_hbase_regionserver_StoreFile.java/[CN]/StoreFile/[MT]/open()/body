{
  if (this.reader != null) {
    throw new IllegalAccessError("Already open");
  }
  if (isReference()) {
    this.reader=new HalfStoreFileReader(this.fs,this.referencePath,this.cacheConf,this.reference,dataBlockEncoder.getEncodingInCache());
  }
 else   if (isLink()) {
    try {
      long size=link.getFileStatus(fs).getLen();
      this.reader=new Reader(this.fs,this.path,link,size,this.cacheConf,dataBlockEncoder.getEncodingInCache(),true);
    }
 catch (    FileNotFoundException fnfe) {
      FileStatus actualRef=fs.getFileStatus(path);
      long actualLen=actualRef.getLen();
      if (actualLen == 0) {
        LOG.error(path + " is a 0-len file, and actually an hfilelink missing target file!",fnfe);
        throw fnfe;
      }
      LOG.debug("Size of link file is " + actualLen + "!= 0; treating as a reference to"+ " HFileLink "+ path+ "!");
      this.reference=Reference.read(fs,this.path);
      this.referencePath=getReferredToLink(this.path);
      LOG.debug("Reference file " + path + " referred to "+ referencePath+ "!");
      link=new HFileLink(fs.getConf(),referencePath);
      this.reader=new HalfStoreFileReader(this.fs,this.referencePath,link,this.cacheConf,this.reference,dataBlockEncoder.getEncodingInCache());
      LOG.debug("Store file " + path + " is loaded "+ referencePath+ " as a half store file"+ " reader to an HFileLink!");
    }
  }
 else {
    this.reader=new Reader(this.fs,this.path,this.cacheConf,dataBlockEncoder.getEncodingInCache());
  }
  computeHDFSBlockDistribution();
  metadataMap=Collections.unmodifiableMap(this.reader.loadFileInfo());
  byte[] b=metadataMap.get(MAX_SEQ_ID_KEY);
  if (b != null) {
    this.sequenceid=Bytes.toLong(b);
    if (isReference()) {
      if (Reference.isTopFileRegion(this.reference.getFileRegion())) {
        this.sequenceid+=1;
      }
    }
  }
  if (isBulkLoadResult()) {
    String fileName=this.path.getName();
    int startPos=fileName.indexOf("SeqId_");
    if (startPos != -1) {
      this.sequenceid=Long.parseLong(fileName.substring(startPos + 6,fileName.indexOf('_',startPos + 6)));
      if (isReference()) {
        if (Reference.isTopFileRegion(this.reference.getFileRegion())) {
          this.sequenceid+=1;
        }
      }
    }
  }
  this.reader.setSequenceID(this.sequenceid);
  b=metadataMap.get(HFileWriterV2.MAX_MEMSTORE_TS_KEY);
  if (b != null) {
    this.maxMemstoreTS=Bytes.toLong(b);
  }
  b=metadataMap.get(MAJOR_COMPACTION_KEY);
  if (b != null) {
    boolean mc=Bytes.toBoolean(b);
    if (this.majorCompaction == null) {
      this.majorCompaction=new AtomicBoolean(mc);
    }
 else {
      this.majorCompaction.set(mc);
    }
  }
 else {
    this.majorCompaction=new AtomicBoolean(false);
  }
  b=metadataMap.get(EXCLUDE_FROM_MINOR_COMPACTION_KEY);
  this.excludeFromMinorCompaction=(b != null && Bytes.toBoolean(b));
  BloomType hfileBloomType=reader.getBloomFilterType();
  if (cfBloomType != BloomType.NONE) {
    reader.loadBloomfilter(BlockType.GENERAL_BLOOM_META);
    if (hfileBloomType != cfBloomType) {
      LOG.info("HFile Bloom filter type for " + reader.getHFileReader().getName() + ": "+ hfileBloomType+ ", but "+ cfBloomType+ " specified in column family "+ "configuration");
    }
  }
 else   if (hfileBloomType != BloomType.NONE) {
    LOG.info("Bloom filter turned off by CF config for " + reader.getHFileReader().getName());
  }
  reader.loadBloomfilter(BlockType.DELETE_FAMILY_BLOOM_META);
  try {
    byte[] timerangeBytes=metadataMap.get(TIMERANGE_KEY);
    if (timerangeBytes != null) {
      this.reader.timeRangeTracker=new TimeRangeTracker();
      Writables.copyWritable(timerangeBytes,this.reader.timeRangeTracker);
    }
  }
 catch (  IllegalArgumentException e) {
    LOG.error("Error reading timestamp range data from meta -- " + "proceeding without",e);
    this.reader.timeRangeTracker=null;
  }
  return this.reader;
}
