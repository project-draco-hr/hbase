{
  if (this.reader != null) {
    throw new IllegalAccessError("Already open");
  }
  if (isReference()) {
    this.reader=new HalfStoreFileReader(this.fs,this.referencePath,this.cacheConf,this.reference,dataBlockEncoder.getEncodingInCache());
  }
 else {
    this.reader=new Reader(this.fs,this.path,this.cacheConf,dataBlockEncoder.getEncodingInCache());
  }
  if (isSchemaConfigured()) {
    SchemaConfigured.resetSchemaMetricsConf(reader);
    passSchemaMetricsTo(reader);
  }
  computeHDFSBlockDistribution();
  metadataMap=Collections.unmodifiableMap(this.reader.loadFileInfo());
  byte[] b=metadataMap.get(MAX_SEQ_ID_KEY);
  if (b != null) {
    this.sequenceid=Bytes.toLong(b);
    if (isReference()) {
      if (Reference.isTopFileRegion(this.reference.getFileRegion())) {
        this.sequenceid+=1;
      }
    }
  }
  this.reader.setSequenceID(this.sequenceid);
  b=metadataMap.get(HFileWriterV2.MAX_MEMSTORE_TS_KEY);
  if (b != null) {
    this.maxMemstoreTS=Bytes.toLong(b);
  }
  b=metadataMap.get(MAJOR_COMPACTION_KEY);
  if (b != null) {
    boolean mc=Bytes.toBoolean(b);
    if (this.majorCompaction == null) {
      this.majorCompaction=new AtomicBoolean(mc);
    }
 else {
      this.majorCompaction.set(mc);
    }
  }
 else {
    this.majorCompaction=new AtomicBoolean(false);
  }
  b=metadataMap.get(EXCLUDE_FROM_MINOR_COMPACTION_KEY);
  this.excludeFromMinorCompaction=(b != null && Bytes.toBoolean(b));
  BloomType hfileBloomType=reader.getBloomFilterType();
  if (cfBloomType != BloomType.NONE) {
    reader.loadBloomfilter(BlockType.GENERAL_BLOOM_META);
    if (hfileBloomType != cfBloomType) {
      LOG.info("HFile Bloom filter type for " + reader.getHFileReader().getName() + ": "+ hfileBloomType+ ", but "+ cfBloomType+ " specified in column family "+ "configuration");
    }
  }
 else   if (hfileBloomType != BloomType.NONE) {
    LOG.info("Bloom filter turned off by CF config for " + reader.getHFileReader().getName());
  }
  reader.loadBloomfilter(BlockType.DELETE_FAMILY_BLOOM_META);
  try {
    byte[] timerangeBytes=metadataMap.get(TIMERANGE_KEY);
    if (timerangeBytes != null) {
      this.reader.timeRangeTracker=new TimeRangeTracker();
      Writables.copyWritable(timerangeBytes,this.reader.timeRangeTracker);
    }
  }
 catch (  IllegalArgumentException e) {
    LOG.error("Error reading timestamp range data from meta -- " + "proceeding without",e);
    this.reader.timeRangeTracker=null;
  }
  return this.reader;
}
