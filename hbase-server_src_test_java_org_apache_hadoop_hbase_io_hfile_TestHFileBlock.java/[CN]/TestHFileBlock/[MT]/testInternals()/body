{
  final int numBlocks=5;
  if (includesTag) {
    TEST_UTIL.getConfiguration().setInt("hfile.format.version",3);
  }
  for (  Compression.Algorithm algo : COMPRESSION_ALGORITHMS) {
    for (    boolean pread : new boolean[]{false,true}) {
      for (      DataBlockEncoding encoding : DataBlockEncoding.values()) {
        Path path=new Path(TEST_UTIL.getDataTestDir(),"blocks_v2_" + algo + "_"+ encoding.toString());
        FSDataOutputStream os=fs.create(path);
        HFileDataBlockEncoder dataBlockEncoder=(encoding != DataBlockEncoding.NONE) ? new HFileDataBlockEncoderImpl(encoding) : NoOpDataBlockEncoder.INSTANCE;
        HFileContext meta=new HFileContextBuilder().withCompression(algo).withIncludesMvcc(includesMemstoreTS).withIncludesTags(includesTag).withBytesPerCheckSum(HFile.DEFAULT_BYTES_PER_CHECKSUM).withChecksumType(HFile.DEFAULT_CHECKSUM_TYPE).build();
        HFileBlock.Writer hbw=new HFileBlock.Writer(dataBlockEncoder,meta);
        long totalSize=0;
        final List<Integer> encodedSizes=new ArrayList<Integer>();
        final List<ByteBuffer> encodedBlocks=new ArrayList<ByteBuffer>();
        for (int blockId=0; blockId < numBlocks; ++blockId) {
          hbw.startWriting(BlockType.DATA);
          writeTestKeyValues(hbw,blockId,includesMemstoreTS,includesTag);
          hbw.writeHeaderAndData(os);
          int headerLen=HConstants.HFILEBLOCK_HEADER_SIZE;
          byte[] encodedResultWithHeader=hbw.getUncompressedBufferWithHeader().array();
          final int encodedSize=encodedResultWithHeader.length - headerLen;
          if (encoding != DataBlockEncoding.NONE) {
            headerLen+=DataBlockEncoding.ID_SIZE;
          }
          byte[] encodedDataSection=new byte[encodedResultWithHeader.length - headerLen];
          System.arraycopy(encodedResultWithHeader,headerLen,encodedDataSection,0,encodedDataSection.length);
          final ByteBuffer encodedBuf=ByteBuffer.wrap(encodedDataSection);
          encodedSizes.add(encodedSize);
          encodedBlocks.add(encodedBuf);
          totalSize+=hbw.getOnDiskSizeWithHeader();
        }
        os.close();
        FSDataInputStream is=fs.open(path);
        meta=new HFileContextBuilder().withHBaseCheckSum(true).withCompression(algo).withIncludesMvcc(includesMemstoreTS).withIncludesTags(includesTag).build();
        HFileBlock.FSReaderV2 hbr=new HFileBlock.FSReaderV2(is,totalSize,meta);
        hbr.setDataBlockEncoder(dataBlockEncoder);
        hbr.setIncludesMemstoreTS(includesMemstoreTS);
        HFileBlock b;
        int pos=0;
        for (int blockId=0; blockId < numBlocks; ++blockId) {
          b=hbr.readBlockData(pos,-1,-1,pread);
          assertEquals(0,HFile.getChecksumFailuresCount());
          b.sanityCheck();
          pos+=b.getOnDiskSizeWithHeader();
          assertEquals((int)encodedSizes.get(blockId),b.getUncompressedSizeWithoutHeader());
          ByteBuffer actualBuffer=b.getBufferWithoutHeader();
          if (encoding != DataBlockEncoding.NONE) {
            assertEquals(0,actualBuffer.get(0));
            assertEquals(encoding.getId(),actualBuffer.get(1));
            actualBuffer.position(2);
            actualBuffer=actualBuffer.slice();
          }
          ByteBuffer expectedBuffer=encodedBlocks.get(blockId);
          expectedBuffer.rewind();
          assertBuffersEqual(expectedBuffer,actualBuffer,algo,encoding,pread);
        }
        is.close();
      }
    }
  }
}
