{
  try {
    while (!this.isInterrupted()) {
synchronized (this.syncLock) {
        while (this.writtenTxid <= this.lastSyncedTxid) {
          this.syncLock.wait();
        }
        this.txidToSync=this.writtenTxid;
      }
      long now=EnvironmentEdgeManager.currentTimeMillis();
      try {
        if (writer == null) {
          if (this.txidToSync > syncedTillHere.get()) {
            LOG.fatal("should never happen: has unsynced writes but writer is null!");
            asyncIOE=new IOException("has unsynced writes but writer is null!");
            failedTxid.set(this.txidToSync);
          }
        }
 else {
          this.isSyncing=true;
          writer.sync();
          this.isSyncing=false;
        }
        postSync();
      }
 catch (      IOException e) {
        LOG.fatal("Error while AsyncSyncer sync, request close of hlog ",e);
        requestLogRoll();
        asyncIOE=e;
        failedTxid.set(this.txidToSync);
        this.isSyncing=false;
      }
      metrics.finishSync(EnvironmentEdgeManager.currentTimeMillis() - now);
      this.lastSyncedTxid=this.txidToSync;
      asyncNotifier.setFlushedTxid(this.lastSyncedTxid);
      boolean logRollNeeded=false;
      if (rollWriterLock.tryLock()) {
        try {
          logRollNeeded=checkLowReplication();
        }
  finally {
          rollWriterLock.unlock();
        }
        try {
          if (logRollNeeded || writer != null && writer.getLength() > logrollsize) {
            requestLogRoll();
          }
        }
 catch (        IOException e) {
          LOG.warn("writer.getLength() failed,this failure won't block here");
        }
      }
    }
  }
 catch (  InterruptedException e) {
    LOG.debug(getName() + " interrupted while waiting for " + "notification from AsyncWriter thread");
  }
catch (  Exception e) {
    LOG.error("UNEXPECTED",e);
  }
 finally {
    LOG.info(getName() + " exiting");
  }
}
