{
  SyncFuture syncFuture=null;
  SafePointZigZagLatch zigzagLatch=(this.ringBufferEventHandler == null) ? null : this.ringBufferEventHandler.attainSafePoint();
  TraceScope scope=Trace.startSpan("FSHFile.replaceWriter");
  try {
    try {
      if (zigzagLatch != null) {
        Trace.addTimelineAnnotation("awaiting safepoint");
        syncFuture=zigzagLatch.waitSafePoint(publishSyncOnRingBuffer());
      }
    }
 catch (    FailedSyncBeforeLogCloseException e) {
      if (isUnflushedEntries())       throw e;
      LOG.warn("Failed last sync but no outstanding unsync edits so falling through to close; " + e.getMessage());
    }
    try {
      if (this.writer != null) {
        Trace.addTimelineAnnotation("closing writer");
        this.writer.close();
        Trace.addTimelineAnnotation("writer closed");
      }
      this.closeErrorCount.set(0);
    }
 catch (    IOException ioe) {
      int errors=closeErrorCount.incrementAndGet();
      if (!isUnflushedEntries() && (errors <= this.closeErrorsTolerated)) {
        LOG.warn("Riding over failed WAL close of " + oldPath + ", cause=\""+ ioe.getMessage()+ "\", errors="+ errors+ "; THIS FILE WAS NOT CLOSED BUT ALL EDITS SYNCED SO SHOULD BE OK");
      }
 else {
        throw ioe;
      }
    }
    this.writer=nextWriter;
    this.hdfs_out=nextHdfsOut;
    int oldNumEntries=this.numEntries.get();
    this.numEntries.set(0);
    final String newPathString=(null == newPath ? null : FSUtils.getPath(newPath));
    if (oldPath != null) {
      this.byWalRegionSequenceIds.put(oldPath,this.highestRegionSequenceIds);
      this.highestRegionSequenceIds=new HashMap<byte[],Long>();
      long oldFileLen=this.fs.getFileStatus(oldPath).getLen();
      this.totalLogSize.addAndGet(oldFileLen);
      LOG.info("Rolled WAL " + FSUtils.getPath(oldPath) + " with entries="+ oldNumEntries+ ", filesize="+ StringUtils.byteDesc(oldFileLen)+ "; new WAL "+ newPathString);
    }
 else {
      LOG.info("New WAL " + newPathString);
    }
  }
 catch (  InterruptedException ie) {
    Thread.currentThread().interrupt();
  }
catch (  IOException e) {
    long count=getUnflushedEntriesCount();
    LOG.error("Failed close of HLog writer " + oldPath + ", unflushedEntries="+ count,e);
    throw new FailedLogCloseException(oldPath + ", unflushedEntries=" + count,e);
  }
 finally {
    try {
      if (zigzagLatch != null) {
        zigzagLatch.releaseSafePoint();
        if (syncFuture != null)         blockOnSync(syncFuture);
      }
    }
  finally {
      scope.close();
    }
  }
  return newPath;
}
