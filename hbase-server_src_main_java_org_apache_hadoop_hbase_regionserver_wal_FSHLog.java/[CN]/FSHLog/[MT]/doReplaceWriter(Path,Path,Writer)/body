{
  SyncFuture syncFuture=null;
  SafePointZigZagLatch zigzagLatch=(this.ringBufferEventHandler == null) ? null : this.ringBufferEventHandler.attainSafePoint();
  afterCreatingZigZagLatch();
  long oldFileLen=0L;
  try {
    try {
      if (zigzagLatch != null) {
        Trace.addTimelineAnnotation("awaiting safepoint");
        syncFuture=zigzagLatch.waitSafePoint(publishSyncOnRingBuffer());
      }
    }
 catch (    FailedSyncBeforeLogCloseException e) {
      if (isUnflushedEntries()) {
        throw e;
      }
      LOG.warn("Failed sync-before-close but no outstanding appends; closing WAL" + e.getMessage());
    }
    if (this.writer != null) {
      oldFileLen=this.writer.getLength();
      try {
        Trace.addTimelineAnnotation("closing writer");
        this.writer.close();
        Trace.addTimelineAnnotation("writer closed");
        this.closeErrorCount.set(0);
      }
 catch (      IOException ioe) {
        int errors=closeErrorCount.incrementAndGet();
        if (!isUnflushedEntries() && (errors <= this.closeErrorsTolerated)) {
          LOG.warn("Riding over failed WAL close of " + oldPath + ", cause=\""+ ioe.getMessage()+ "\", errors="+ errors+ "; THIS FILE WAS NOT CLOSED BUT ALL EDITS SYNCED SO SHOULD BE OK");
        }
 else {
          throw ioe;
        }
      }
    }
    this.writer=nextWriter;
    if (nextWriter != null && nextWriter instanceof ProtobufLogWriter) {
      this.hdfs_out=((ProtobufLogWriter)nextWriter).getStream();
    }
 else {
      this.hdfs_out=null;
    }
  }
 catch (  InterruptedException ie) {
    Thread.currentThread().interrupt();
  }
catch (  IOException e) {
    long count=getUnflushedEntriesCount();
    LOG.error("Failed close of WAL writer " + oldPath + ", unflushedEntries="+ count,e);
    throw new FailedLogCloseException(oldPath + ", unflushedEntries=" + count,e);
  }
 finally {
    if (zigzagLatch != null) {
      zigzagLatch.releaseSafePoint();
      if (syncFuture != null) {
        try {
          blockOnSync(syncFuture);
        }
 catch (        IOException ioe) {
          if (LOG.isTraceEnabled()) {
            LOG.trace("Stale sync exception",ioe);
          }
        }
      }
    }
  }
  return oldFileLen;
}
