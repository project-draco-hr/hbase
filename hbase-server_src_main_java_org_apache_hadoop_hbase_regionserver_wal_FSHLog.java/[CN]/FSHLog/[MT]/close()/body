{
  if (this.closed) {
    return;
  }
  try {
    asyncNotifier.interrupt();
    asyncNotifier.join();
  }
 catch (  InterruptedException e) {
    LOG.error("Exception while waiting for " + asyncNotifier.getName() + " threads to die",e);
  }
  for (int i=0; i < asyncSyncers.length; ++i) {
    try {
      asyncSyncers[i].interrupt();
      asyncSyncers[i].join();
    }
 catch (    InterruptedException e) {
      LOG.error("Exception while waiting for " + asyncSyncers[i].getName() + " threads to die",e);
    }
  }
  try {
    asyncWriter.interrupt();
    asyncWriter.join();
  }
 catch (  InterruptedException e) {
    LOG.error("Exception while waiting for " + asyncWriter.getName() + " thread to die",e);
  }
  try {
    closeBarrier.stopAndDrainOps();
  }
 catch (  InterruptedException e) {
    LOG.error("Exception while waiting for cache flushes and log rolls",e);
    Thread.currentThread().interrupt();
  }
  if (!this.listeners.isEmpty()) {
    for (    WALActionsListener i : this.listeners) {
      i.logCloseRequested();
    }
  }
synchronized (updateLock) {
    this.closed=true;
    if (LOG.isDebugEnabled()) {
      LOG.debug("Closing WAL writer in " + this.dir.toString());
    }
    if (this.writer != null) {
      this.writer.close();
      this.writer=null;
    }
  }
}
