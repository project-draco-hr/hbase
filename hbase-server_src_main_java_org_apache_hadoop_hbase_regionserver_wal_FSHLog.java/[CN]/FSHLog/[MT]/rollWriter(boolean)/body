{
synchronized (rollWriterLock) {
    if (!force && this.writer != null && this.numEntries.get() <= 0) {
      return null;
    }
    byte[][] regionsToFlush=null;
    try {
      this.logRollRunning=true;
      boolean isClosed=closed;
      if (isClosed || !closeBarrier.beginOp()) {
        LOG.debug("HLog " + (isClosed ? "closed" : "closing") + ". Skipping rolling of writer");
        return regionsToFlush;
      }
      long currentFilenum=this.filenum;
      Path oldPath=null;
      if (currentFilenum > 0) {
        oldPath=computeFilename(currentFilenum);
      }
      this.filenum=System.currentTimeMillis();
      Path newPath=computeFilename();
      if (!this.listeners.isEmpty()) {
        for (        WALActionsListener i : this.listeners) {
          i.preLogRoll(oldPath,newPath);
        }
      }
      FSHLog.Writer nextWriter=this.createWriterInstance(fs,newPath,conf);
      FSDataOutputStream nextHdfsOut=null;
      if (nextWriter instanceof SequenceFileLogWriter) {
        nextHdfsOut=((SequenceFileLogWriter)nextWriter).getWriterFSDataOutputStream();
      }
      Path oldFile=null;
      int oldNumEntries=0;
synchronized (updateLock) {
        oldNumEntries=this.numEntries.get();
        oldFile=cleanupCurrentWriter(currentFilenum);
        this.writer=nextWriter;
        this.hdfs_out=nextHdfsOut;
        this.numEntries.set(0);
      }
      LOG.info("Rolled log" + (oldFile != null ? " for file=" + FSUtils.getPath(oldFile) + ", entries="+ oldNumEntries+ ", filesize="+ this.fs.getFileStatus(oldFile).getLen() : "") + "; new path="+ FSUtils.getPath(newPath));
      if (!this.listeners.isEmpty()) {
        for (        WALActionsListener i : this.listeners) {
          i.postLogRoll(oldPath,newPath);
        }
      }
      if (getNumLogFiles() > 0) {
        cleanOldLogs();
        regionsToFlush=getRegionsToForceFlush();
      }
    }
  finally {
      this.logRollRunning=false;
      closeBarrier.endOp();
    }
    return regionsToFlush;
  }
}
