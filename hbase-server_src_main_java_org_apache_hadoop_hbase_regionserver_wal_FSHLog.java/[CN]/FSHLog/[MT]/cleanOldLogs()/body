{
  long oldestOutstandingSeqNum=Long.MAX_VALUE;
synchronized (oldestSeqNumsLock) {
    Long oldestFlushing=(oldestFlushingSeqNums.size() > 0) ? Collections.min(oldestFlushingSeqNums.values()) : Long.MAX_VALUE;
    Long oldestUnflushed=(oldestUnflushedSeqNums.size() > 0) ? Collections.min(oldestUnflushedSeqNums.values()) : Long.MAX_VALUE;
    oldestOutstandingSeqNum=Math.min(oldestFlushing,oldestUnflushed);
  }
  TreeSet<Long> sequenceNumbers=new TreeSet<Long>(this.outputfiles.headMap(oldestOutstandingSeqNum).keySet());
  if (LOG.isDebugEnabled()) {
    if (sequenceNumbers.size() > 0) {
      LOG.debug("Found " + sequenceNumbers.size() + " hlogs to remove"+ " out of total "+ this.outputfiles.size()+ ";"+ " oldest outstanding sequenceid is "+ oldestOutstandingSeqNum);
    }
  }
  for (  Long seq : sequenceNumbers) {
    archiveLogFile(this.outputfiles.remove(seq),seq);
  }
}
