{
  super();
  this.fs=fs;
  this.fullPathLogDir=new Path(rootDir,logDir);
  this.fullPathOldLogDir=new Path(rootDir,oldLogDir);
  this.forMeta=forMeta;
  this.conf=conf;
  if (listeners != null) {
    for (    WALActionsListener i : listeners) {
      registerWALActionsListener(i);
    }
  }
  long blocksize=this.conf.getLong("hbase.regionserver.hlog.blocksize",FSUtils.getDefaultBlockSize(this.fs,this.fullPathLogDir));
  this.logrollsize=(long)(blocksize * conf.getFloat("hbase.regionserver.logroll.multiplier",0.95f));
  this.maxLogs=conf.getInt("hbase.regionserver.maxlogs",32);
  this.minTolerableReplication=conf.getInt("hbase.regionserver.hlog.tolerable.lowreplication",FSUtils.getDefaultReplication(fs,this.fullPathLogDir));
  this.lowReplicationRollLimit=conf.getInt("hbase.regionserver.hlog.lowreplication.rolllimit",5);
  this.enabled=conf.getBoolean("hbase.regionserver.hlog.enabled",true);
  this.closeErrorsTolerated=conf.getInt("hbase.regionserver.logroll.errors.tolerated",0);
  this.logFilePrefix=prefix == null || prefix.isEmpty() ? "hlog" : URLEncoder.encode(prefix,"UTF8");
  int maxHandlersCount=conf.getInt(HConstants.REGION_SERVER_HANDLER_COUNT,200);
  LOG.info("WAL configuration: blocksize=" + StringUtils.byteDesc(blocksize) + ", rollsize="+ StringUtils.byteDesc(this.logrollsize)+ ", enabled="+ this.enabled+ ", prefix="+ this.logFilePrefix+ ", logDir="+ this.fullPathLogDir+ ", oldLogDir="+ this.fullPathOldLogDir);
  boolean dirExists=false;
  if (failIfLogDirExists && (dirExists=this.fs.exists(fullPathLogDir))) {
    throw new IOException("Target HLog directory already exists: " + fullPathLogDir);
  }
  if (!dirExists && !fs.mkdirs(fullPathLogDir)) {
    throw new IOException("Unable to mkdir " + fullPathLogDir);
  }
  if (!fs.exists(this.fullPathOldLogDir)) {
    if (!fs.mkdirs(this.fullPathOldLogDir)) {
      throw new IOException("Unable to mkdir " + this.fullPathOldLogDir);
    }
  }
  rollWriter();
  this.getNumCurrentReplicas=getGetNumCurrentReplicas(this.hdfs_out);
  this.coprocessorHost=new WALCoprocessorHost(this,conf);
  this.metrics=new MetricsWAL();
  String hostingThreadName=Thread.currentThread().getName();
  this.appendExecutor=Executors.newSingleThreadExecutor(Threads.getNamedThreadFactory(hostingThreadName + ".append"));
  final int preallocatedEventCount=this.conf.getInt("hbase.regionserver.wal.disruptor.event.count",1024 * 16);
  this.disruptor=new Disruptor<RingBufferTruck>(RingBufferTruck.EVENT_FACTORY,preallocatedEventCount,this.appendExecutor,ProducerType.MULTI,new BlockingWaitStrategy());
  this.disruptor.getRingBuffer().next();
  this.ringBufferEventHandler=new RingBufferEventHandler(conf.getInt("hbase.regionserver.hlog.syncer.count",5),maxHandlersCount);
  this.disruptor.handleExceptionsWith(new RingBufferExceptionHandler());
  this.disruptor.handleEventsWith(new RingBufferEventHandler[]{this.ringBufferEventHandler});
  this.syncFuturesByHandler=new ConcurrentHashMap<Thread,SyncFuture>(maxHandlersCount);
  this.disruptor.start();
}
