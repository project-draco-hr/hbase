{
  checkClosing();
  String key=String.valueOf(transactionId);
  if (transactionsById.get(key) != null) {
    TransactionState alias=getTransactionState(transactionId);
    if (alias != null) {
      alias.setStatus(Status.ABORTED);
      retireTransaction(alias);
    }
    LOG.error("Existing trasaction with id [" + key + "] in region ["+ super.getRegionInfo().getRegionNameAsString()+ "]");
    throw new IOException("Already exiting transaction id: " + key);
  }
  TransactionState state=new TransactionState(transactionId,super.getLog().getSequenceNumber(),super.getRegionInfo());
  List<TransactionState> commitPendingCopy=new LinkedList<TransactionState>(commitPendingTransactions);
  for (  TransactionState commitPending : commitPendingCopy) {
    state.addTransactionToCheck(commitPending);
  }
  state.setStartSequenceNumber(nextSequenceId.get());
synchronized (transactionsById) {
    transactionsById.put(key,state);
  }
  try {
    transactionLeases.createLease(getLeaseId(transactionId),new TransactionLeaseListener(key));
  }
 catch (  LeaseStillHeldException e) {
    LOG.error("Lease still held for [" + key + "] in region ["+ super.getRegionInfo().getRegionNameAsString()+ "]");
    throw new RuntimeException(e);
  }
  LOG.debug("Begining transaction " + key + " in region "+ super.getRegionInfo().getRegionNameAsString());
  this.hlog.writeStartToLog(super.getRegionInfo(),transactionId);
  maybeTriggerOldTransactionFlush();
}
