{
  ByteBuf inBuffer=(ByteBuf)msg;
  ByteBufInputStream in=new ByteBufInputStream(inBuffer);
  if (channel.shouldCloseConnection) {
    return;
  }
  int totalSize=inBuffer.readableBytes();
  try {
    RPCProtos.ResponseHeader responseHeader=RPCProtos.ResponseHeader.parseDelimitedFrom(in);
    int id=responseHeader.getCallId();
    AsyncCall call=channel.calls.get(id);
    if (call == null) {
      int readSoFar=IPCUtil.getTotalSizeWhenWrittenDelimited(responseHeader);
      int whatIsLeftToRead=totalSize - readSoFar;
      inBuffer.skipBytes(whatIsLeftToRead);
      return;
    }
    if (responseHeader.hasException()) {
      RPCProtos.ExceptionResponse exceptionResponse=responseHeader.getException();
      RemoteException re=createRemoteException(exceptionResponse);
      if (exceptionResponse.getExceptionClassName().equals(FatalConnectionException.class.getName())) {
        channel.close(re);
      }
 else {
        channel.failCall(call,re);
      }
    }
 else {
      Message value=null;
      if (call.responseDefaultType != null) {
        Message.Builder builder=call.responseDefaultType.newBuilderForType();
        builder.mergeDelimitedFrom(in);
        value=builder.build();
      }
      CellScanner cellBlockScanner=null;
      if (responseHeader.hasCellBlockMeta()) {
        int size=responseHeader.getCellBlockMeta().getLength();
        byte[] cellBlock=new byte[size];
        inBuffer.readBytes(cellBlock,0,cellBlock.length);
        cellBlockScanner=channel.client.createCellScanner(cellBlock);
      }
      call.setSuccess(value,cellBlockScanner);
    }
    channel.calls.remove(id);
  }
 catch (  IOException e) {
    channel.close(e);
  }
 finally {
    inBuffer.release();
    channel.cleanupCalls(false);
  }
}
