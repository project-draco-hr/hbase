{
  int index=-1;
  ChoreService choreService=null;
  for (int i=0; i < args.length; i++) {
    String cmd=args[i];
    if (cmd.startsWith("-")) {
      if (index >= 0) {
        System.err.println("Invalid command line options");
        printUsageAndExit();
      }
      if (cmd.equals("-help")) {
        printUsageAndExit();
      }
 else       if (cmd.equals("-daemon") && interval == 0) {
        interval=DEFAULT_INTERVAL;
      }
 else       if (cmd.equals("-interval")) {
        i++;
        if (i == args.length) {
          System.err.println("-interval needs a numeric value argument.");
          printUsageAndExit();
        }
        try {
          interval=Long.parseLong(args[i]) * 1000;
        }
 catch (        NumberFormatException e) {
          System.err.println("-interval needs a numeric value argument.");
          printUsageAndExit();
        }
      }
 else       if (cmd.equals("-regionserver")) {
        this.regionServerMode=true;
      }
 else       if (cmd.equals("-e")) {
        this.useRegExp=true;
      }
 else       if (cmd.equals("-t")) {
        i++;
        if (i == args.length) {
          System.err.println("-t needs a numeric value argument.");
          printUsageAndExit();
        }
        try {
          this.timeout=Long.parseLong(args[i]);
        }
 catch (        NumberFormatException e) {
          System.err.println("-t needs a numeric value argument.");
          printUsageAndExit();
        }
      }
 else       if (cmd.equals("-f")) {
        i++;
        if (i == args.length) {
          System.err.println("-f needs a boolean value argument (true|false).");
          printUsageAndExit();
        }
        this.failOnError=Boolean.parseBoolean(args[i]);
      }
 else {
        System.err.println(cmd + " options is invalid.");
        printUsageAndExit();
      }
    }
 else     if (index < 0) {
      index=i;
    }
  }
  final ScheduledChore authChore=AuthUtil.getAuthChore(conf);
  if (authChore != null) {
    choreService=new ChoreService("CANARY_TOOL");
    choreService.scheduleChore(authChore);
  }
  Monitor monitor=null;
  Thread monitorThread=null;
  long startTime=0;
  long currentTimeLength=0;
  try (Connection connection=ConnectionFactory.createConnection(this.conf)){
    do {
      try {
        monitor=this.newMonitor(connection,index,args);
        monitorThread=new Thread(monitor);
        startTime=System.currentTimeMillis();
        monitorThread.start();
        while (!monitor.isDone()) {
          Thread.sleep(1000);
          if (this.failOnError && monitor.hasError()) {
            monitorThread.interrupt();
            if (monitor.initialized) {
              System.exit(monitor.errorCode);
            }
 else {
              System.exit(INIT_ERROR_EXIT_CODE);
            }
          }
          currentTimeLength=System.currentTimeMillis() - startTime;
          if (currentTimeLength > this.timeout) {
            LOG.error("The monitor is running too long (" + currentTimeLength + ") after timeout limit:"+ this.timeout+ " will be killed itself !!");
            if (monitor.initialized) {
              System.exit(TIMEOUT_ERROR_EXIT_CODE);
            }
 else {
              System.exit(INIT_ERROR_EXIT_CODE);
            }
            break;
          }
        }
        if (this.failOnError && monitor.hasError()) {
          monitorThread.interrupt();
          System.exit(monitor.errorCode);
        }
      }
  finally {
        if (monitor != null)         monitor.close();
      }
      Thread.sleep(interval);
    }
 while (interval > 0);
  }
   if (choreService != null) {
    choreService.shutdown();
  }
  return (monitor.errorCode);
}
