{
  if (shouldCloseConnection.get())   return;
  Call call=null;
  boolean expectedCall=false;
  try {
    int totalSize=in.readInt();
    ResponseHeader responseHeader=ResponseHeader.parseDelimitedFrom(in);
    int id=responseHeader.getCallId();
    if (LOG.isDebugEnabled()) {
      LOG.debug(getName() + ": got response header " + TextFormat.shortDebugString(responseHeader)+ ", totalSize: "+ totalSize+ " bytes");
    }
    call=calls.remove(id);
    expectedCall=(call != null && !call.done);
    if (!expectedCall) {
      int readSoFar=IPCUtil.getTotalSizeWhenWrittenDelimited(responseHeader);
      int whatIsLeftToRead=totalSize - readSoFar;
      LOG.debug("Unknown callId: " + id + ", skipping over this response of "+ whatIsLeftToRead+ " bytes");
      IOUtils.skipFully(in,whatIsLeftToRead);
    }
    if (responseHeader.hasException()) {
      ExceptionResponse exceptionResponse=responseHeader.getException();
      RemoteException re=createRemoteException(exceptionResponse);
      if (expectedCall)       call.setException(re);
      if (isFatalConnectionException(exceptionResponse)) {
        markClosed(re);
      }
    }
 else {
      Message value=null;
      if (expectedCall && call.responseDefaultType != null) {
        Builder builder=call.responseDefaultType.newBuilderForType();
        builder.mergeDelimitedFrom(in);
        value=builder.build();
      }
      CellScanner cellBlockScanner=null;
      if (responseHeader.hasCellBlockMeta()) {
        int size=responseHeader.getCellBlockMeta().getLength();
        byte[] cellBlock=new byte[size];
        IOUtils.readFully(this.in,cellBlock,0,cellBlock.length);
        cellBlockScanner=ipcUtil.createCellScanner(this.codec,this.compressor,cellBlock);
      }
      if (expectedCall)       call.setResponse(value,cellBlockScanner);
    }
  }
 catch (  IOException e) {
    if (expectedCall)     call.setException(e);
    if (e instanceof SocketTimeoutException) {
    }
 else {
      markClosed(e);
    }
  }
 finally {
    cleanupCalls(false);
    if (expectedCall && !call.done) {
      LOG.warn("Coding error: code should be true for callId=" + call.id + ", server="+ getRemoteAddress()+ ", shouldCloseConnection="+ shouldCloseConnection.get());
    }
  }
}
