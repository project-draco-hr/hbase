{
  if (shouldCloseConnection.get())   return;
  int totalSize;
  try {
    totalSize=in.readInt();
    ResponseHeader responseHeader=ResponseHeader.parseDelimitedFrom(in);
    int id=responseHeader.getCallId();
    if (LOG.isDebugEnabled()) {
      LOG.debug(getName() + ": got response header " + TextFormat.shortDebugString(responseHeader)+ ", totalSize: "+ totalSize+ " bytes");
    }
    Call call=calls.remove(id);
    boolean expectedCall=(call != null && !call.done);
    if (!expectedCall) {
      int readSoFar=IPCUtil.getTotalSizeWhenWrittenDelimited(responseHeader);
      int whatIsLeftToRead=totalSize - readSoFar;
      LOG.debug("Unknown callId: " + id + ", skipping over this response of "+ whatIsLeftToRead+ " bytes");
      IOUtils.skipFully(in,whatIsLeftToRead);
    }
    if (responseHeader.hasException()) {
      ExceptionResponse exceptionResponse=responseHeader.getException();
      RemoteException re=createRemoteException(exceptionResponse);
      if (isFatalConnectionException(exceptionResponse)) {
        markClosed(re);
      }
 else {
        if (expectedCall)         call.setException(re);
      }
    }
 else {
      Message value=null;
      if (expectedCall && call.responseDefaultType != null) {
        Builder builder=call.responseDefaultType.newBuilderForType();
        builder.mergeDelimitedFrom(in);
        value=builder.build();
      }
      CellScanner cellBlockScanner=null;
      if (responseHeader.hasCellBlockMeta()) {
        int size=responseHeader.getCellBlockMeta().getLength();
        byte[] cellBlock=new byte[size];
        IOUtils.readFully(this.in,cellBlock,0,cellBlock.length);
        cellBlockScanner=ipcUtil.createCellScanner(this.codec,this.compressor,cellBlock);
      }
      if (expectedCall)       call.setResponse(value,cellBlockScanner);
    }
  }
 catch (  IOException e) {
    if (e instanceof SocketTimeoutException && remoteId.rpcTimeout > 0) {
    }
 else {
      markClosed(e);
    }
  }
 finally {
    cleanupCalls(remoteId.rpcTimeout);
  }
}
