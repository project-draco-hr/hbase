{
  long splitTime=0, splitLogSize=0;
  List<Path> logDirs=new ArrayList<Path>();
  for (  ServerName serverName : serverNames) {
    Path logDir=new Path(this.rootdir,HLog.getHLogDirectoryName(serverName.toString()));
    Path splitDir=logDir.suffix(HLog.SPLITTING_EXT);
    if (fs.exists(logDir)) {
      if (!this.fs.rename(logDir,splitDir)) {
        throw new IOException("Failed fs.rename for log split: " + logDir);
      }
      logDir=splitDir;
      LOG.debug("Renamed region directory: " + splitDir);
    }
 else     if (!fs.exists(splitDir)) {
      LOG.info("Log dir for server " + serverName + " does not exist");
      continue;
    }
    logDirs.add(splitDir);
  }
  if (logDirs.isEmpty()) {
    LOG.info("No logs to split");
    return;
  }
  if (distributedLogSplitting) {
    splitLogManager.handleDeadWorkers(serverNames);
    splitTime=EnvironmentEdgeManager.currentTimeMillis();
    try {
      splitLogSize=splitLogManager.splitLogDistributed(logDirs);
    }
 catch (    OrphanHLogAfterSplitException e) {
      LOG.warn("Retrying distributed splitting for " + serverNames,e);
      splitLogManager.splitLogDistributed(logDirs);
    }
    splitTime=EnvironmentEdgeManager.currentTimeMillis() - splitTime;
  }
 else {
    for (    Path logDir : logDirs) {
      this.splitLogLock.lock();
      try {
        HLogSplitter splitter=HLogSplitter.createLogSplitter(conf,rootdir,logDir,oldLogDir,this.fs);
        try {
          FSUtils.waitOnSafeMode(conf,conf.getInt(HConstants.THREAD_WAKE_FREQUENCY,1000));
          splitter.splitLog();
        }
 catch (        OrphanHLogAfterSplitException e) {
          LOG.warn("Retrying splitting because of:",e);
          splitter=HLogSplitter.createLogSplitter(conf,rootdir,logDir,oldLogDir,this.fs);
          splitter.splitLog();
        }
        splitTime=splitter.getTime();
        splitLogSize=splitter.getSize();
      }
  finally {
        this.splitLogLock.unlock();
      }
    }
  }
  if (this.metrics != null) {
    this.metrics.addSplit(splitTime,splitLogSize);
  }
}
