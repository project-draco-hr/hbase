{
  Set<HStoreKey> deletes=new HashSet<HStoreKey>();
  this.lock.readLock().lock();
  try {
    List<HStoreKey> keys=this.memcache.getKeys(origin,versions,deletes,now,columnPattern);
    if (keys.size() >= versions) {
      return keys;
    }
    Map<Long,StoreFile> m=this.storefiles.descendingMap();
    for (Iterator<Map.Entry<Long,StoreFile>> i=m.entrySet().iterator(); i.hasNext() && keys.size() < versions; ) {
      StoreFile f=i.next().getValue();
      HFileScanner scanner=f.getReader().getScanner();
      if (!getClosest(scanner,origin.getBytes())) {
        continue;
      }
      do {
        HStoreKey readkey=HStoreKey.create(scanner.getKey());
        if (rowMatches(origin,readkey)) {
          if (columnPattern != null) {
            if (!(columnPattern.matcher(Bytes.toString(readkey.getColumn())).matches())) {
              continue;
            }
          }
          if (cellMatches(origin,readkey)) {
            ByteBuffer readval=scanner.getValue();
            if (!HLogEdit.isDeleted(readval)) {
              if (notExpiredAndNotInDeletes(this.ttl,readkey,now,deletes)) {
                keys.add(readkey);
              }
              if (keys.size() >= versions) {
                break;
              }
            }
 else {
              deletes.add(readkey);
            }
          }
 else {
            continue;
          }
        }
 else {
          break;
        }
      }
 while (scanner.next());
    }
    return keys;
  }
  finally {
    this.lock.readLock().unlock();
  }
}
