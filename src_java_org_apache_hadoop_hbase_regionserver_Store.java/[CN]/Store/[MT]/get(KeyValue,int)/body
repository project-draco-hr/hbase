{
  long now=System.currentTimeMillis();
  int versions=versionsToReturn(numVersions);
  NavigableSet<KeyValue> deletes=new TreeSet<KeyValue>(this.comparatorIgnoringType);
  List<KeyValue> keyvalues=new ArrayList<KeyValue>();
  this.lock.readLock().lock();
  try {
    if (this.memcache.get(key,versions,keyvalues,deletes,now)) {
      return keyvalues;
    }
    Map<Long,StoreFile> m=this.storefiles.descendingMap();
    boolean hasEnough=false;
    for (    Map.Entry<Long,StoreFile> e : m.entrySet()) {
      StoreFile f=e.getValue();
      HFileScanner scanner=f.getReader().getScanner();
      if (!getClosest(scanner,key)) {
        continue;
      }
      do {
        KeyValue kv=scanner.getKeyValue();
        if (this.comparator.matchingRowColumn(kv,key)) {
          if (doKeyValue(kv,versions,deletes,now,this.ttl,keyvalues,null)) {
            hasEnough=true;
            break;
          }
        }
 else {
          break;
        }
      }
 while (scanner.next());
      if (hasEnough) {
        break;
      }
    }
    return keyvalues.isEmpty() ? null : keyvalues;
  }
  finally {
    this.lock.readLock().unlock();
  }
}
