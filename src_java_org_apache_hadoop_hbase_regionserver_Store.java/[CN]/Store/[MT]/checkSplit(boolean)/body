{
  this.lock.readLock().lock();
  try {
    if (this.storefiles.size() <= 0) {
      return null;
    }
    if (!force && (storeSize < this.desiredMaxFileSize)) {
      return null;
    }
    boolean splitable=true;
    long maxSize=0L;
    Long mapIndex=Long.valueOf(0L);
    for (    Map.Entry<Long,StoreFile> e : storefiles.entrySet()) {
      StoreFile curHSF=e.getValue();
      if (splitable) {
        splitable=!curHSF.isReference();
        if (!splitable) {
          if (LOG.isDebugEnabled()) {
            LOG.debug(curHSF + " is not splittable");
          }
          return null;
        }
      }
      long size=curHSF.getReader().length();
      if (size > maxSize) {
        maxSize=size;
        mapIndex=e.getKey();
      }
    }
    HFile.Reader r=this.storefiles.get(mapIndex).getReader();
    byte[] midkey=r.midkey();
    if (midkey != null) {
      HStoreKey mk=HStoreKey.create(midkey);
      HStoreKey firstKey=HStoreKey.create(r.getFirstKey());
      HStoreKey lastKey=HStoreKey.create(r.getLastKey());
      if (HStoreKey.equalsTwoRowKeys(mk.getRow(),firstKey.getRow()) && HStoreKey.equalsTwoRowKeys(mk.getRow(),lastKey.getRow())) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("cannot split because midkey is the same as first or " + "last row");
        }
        return null;
      }
      return new StoreSize(maxSize,mk.getRow());
    }
  }
 catch (  IOException e) {
    LOG.warn("Failed getting store size for " + this.storeNameStr,e);
  }
 finally {
    this.lock.readLock().unlock();
  }
  return null;
}
