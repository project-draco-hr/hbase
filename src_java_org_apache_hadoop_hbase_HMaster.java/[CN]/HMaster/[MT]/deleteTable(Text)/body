{
  if (!isMasterRunning()) {
    throw new IllegalStateException(MASTER_NOT_RUNNING);
  }
  metaScanner.waitForMetaScan();
  Text firstMetaRegion=null;
  if (knownMetaRegions.size() == 1) {
    firstMetaRegion=knownMetaRegions.firstKey();
  }
 else   if (knownMetaRegions.containsKey(tableName)) {
    firstMetaRegion=tableName;
  }
 else {
    firstMetaRegion=knownMetaRegions.headMap(tableName).lastKey();
  }
  for (Iterator<MetaRegion> it=knownMetaRegions.tailMap(firstMetaRegion).values().iterator(); it.hasNext(); ) {
    MetaRegion m=it.next();
    HRegionInterface server=client.getHRegionConnection(m.server);
    Vector<Text> rowsToDelete=new Vector<Text>();
    long scannerId=-1L;
    try {
      scannerId=server.openScanner(m.regionName,METACOLUMNS,tableName);
      DataInputBuffer inbuf=new DataInputBuffer();
      byte[] bytes;
      while (true) {
        LabelledData[] values=null;
        HStoreKey key=new HStoreKey();
        values=server.next(scannerId,key);
        if (values == null || values.length == 0) {
          break;
        }
        TreeMap<Text,byte[]> results=new TreeMap<Text,byte[]>();
        for (int i=0; i < values.length; i++) {
          bytes=new byte[values[i].getData().getSize()];
          System.arraycopy(values[i].getData().get(),0,bytes,0,bytes.length);
          results.put(values[i].getLabel(),bytes);
        }
        bytes=results.get(COL_REGIONINFO);
        if (bytes == null || bytes.length == 0) {
          break;
        }
        inbuf.reset(bytes,bytes.length);
        HRegionInfo info=new HRegionInfo();
        info.readFields(inbuf);
        if (info.tableDesc.getName().compareTo(tableName) > 0) {
          break;
        }
        rowsToDelete.add(info.regionName);
        bytes=results.get(COL_SERVER);
        if (bytes != null && bytes.length != 0) {
          String serverName=new String(bytes,UTF8_ENCODING);
          bytes=results.get(COL_STARTCODE);
          if (bytes != null && bytes.length != 0) {
            long startCode=Long.valueOf(new String(bytes,UTF8_ENCODING));
            HServerInfo s=serversToServerInfo.get(serverName);
            if (s != null && s.getStartCode() == startCode) {
              TreeMap<Text,HRegionInfo> regionsToKill=killList.get(serverName);
              if (regionsToKill == null) {
                regionsToKill=new TreeMap<Text,HRegionInfo>();
              }
              regionsToKill.put(info.regionName,info);
              killList.put(serverName,regionsToKill);
            }
          }
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
 finally {
      if (scannerId != -1L) {
        try {
          server.close(scannerId);
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      scannerId=-1L;
    }
    for (Iterator<Text> row=rowsToDelete.iterator(); row.hasNext(); ) {
      Text rowName=row.next();
      if (LOG.isDebugEnabled()) {
        LOG.debug("deleting columns in row: " + rowName);
      }
      try {
        long clientId=rand.nextLong();
        long lockid=server.startUpdate(m.regionName,clientId,rowName);
        server.delete(m.regionName,clientId,lockid,COL_REGIONINFO);
        server.delete(m.regionName,clientId,lockid,COL_SERVER);
        server.delete(m.regionName,clientId,lockid,COL_STARTCODE);
        server.commit(m.regionName,clientId,lockid);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("deleted table: " + tableName);
  }
}
