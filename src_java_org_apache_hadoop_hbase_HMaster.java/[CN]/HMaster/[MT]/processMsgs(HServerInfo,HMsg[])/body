{
  ArrayList<HMsg> returnMsgs=new ArrayList<HMsg>();
  String serverName=info.getServerAddress().toString();
  HashMap<Text,HRegionInfo> regionsToKill=killList.remove(serverName);
  for (int i=0; i < incomingMsgs.length; i++) {
    HRegionInfo region=incomingMsgs[i].getRegionInfo();
switch (incomingMsgs[i].getMsg()) {
case HMsg.MSG_REPORT_OPEN:
      HRegionInfo regionInfo=unassignedRegions.get(region.regionName);
    if (regionInfo == null) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("region server " + info.getServerAddress().toString() + " should not have opened region "+ region.regionName);
      }
      returnMsgs.add(new HMsg(HMsg.MSG_REGION_CLOSE_WITHOUT_REPORT,region));
    }
 else {
      LOG.info(info.getServerAddress().toString() + " serving " + region.regionName);
      unassignedRegions.remove(region.regionName);
      assignAttempts.remove(region.regionName);
      if (region.regionName.compareTo(HGlobals.rootRegionInfo.regionName) == 0) {
synchronized (rootRegionLocation) {
          rootRegionLocation.set(new HServerAddress(info.getServerAddress()));
          rootRegionLocation.notifyAll();
        }
        break;
      }
      pendingRegions.add(region.regionName);
      try {
        msgQueue.put(new PendingOpenReport(info,region));
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("Putting into msgQueue was interrupted.",e);
      }
    }
  break;
case HMsg.MSG_REPORT_CLOSE:
LOG.info(info.getServerAddress().toString() + " no longer serving " + region.regionName);
if (region.regionName.compareTo(HGlobals.rootRegionInfo.regionName) == 0) {
rootRegionLocation.set(null);
unassignedRegions.put(region.regionName,region);
assignAttempts.put(region.regionName,Long.valueOf(0L));
}
 else {
boolean reassignRegion=true;
boolean deleteRegion=false;
if (killedRegions.remove(region.regionName)) {
  reassignRegion=false;
}
if (regionsToDelete.remove(region.regionName)) {
  reassignRegion=false;
  deleteRegion=true;
}
unassignedRegions.remove(region.regionName);
assignAttempts.remove(region.regionName);
try {
  msgQueue.put(new PendingCloseReport(region,reassignRegion,deleteRegion));
}
 catch (InterruptedException e) {
  throw new RuntimeException("Putting into msgQueue was interrupted.",e);
}
}
break;
case HMsg.MSG_REPORT_SPLIT:
HRegionInfo newRegionA=incomingMsgs[++i].getRegionInfo();
HRegionInfo newRegionB=incomingMsgs[++i].getRegionInfo();
LOG.info("region " + region.regionName + " split. New regions are: "+ newRegionA.regionName+ ", "+ newRegionB.regionName);
if (region.tableDesc.getName().equals(META_TABLE_NAME)) {
onlineMetaRegions.remove(region.getStartKey());
onlineMetaRegions.put(newRegionA.getStartKey(),new MetaRegion(info.getServerAddress(),newRegionA.getRegionName(),newRegionA.getStartKey()));
onlineMetaRegions.put(newRegionB.getStartKey(),new MetaRegion(info.getServerAddress(),newRegionB.getRegionName(),newRegionB.getStartKey()));
numberOfMetaRegions.incrementAndGet();
}
break;
default :
throw new IOException("Impossible state during msg processing.  Instruction: " + incomingMsgs[i].getMsg());
}
}
if (regionsToKill != null) {
for (HRegionInfo i : regionsToKill.values()) {
returnMsgs.add(new HMsg(HMsg.MSG_REGION_CLOSE,i));
killedRegions.add(i.regionName);
}
}
assignRegions(info,serverName,returnMsgs);
return returnMsgs.toArray(new HMsg[returnMsgs.size()]);
}
