{
  ArrayList<HMsg> returnMsgs=new ArrayList<HMsg>();
  String serverName=info.getServerAddress().toString();
  HashMap<Text,HRegionInfo> regionsToKill=null;
  regionsToKill=killList.remove(serverName);
  for (int i=0; i < incomingMsgs.length; i++) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Received " + incomingMsgs[i].toString() + " from "+ serverName);
    }
    HRegionInfo region=incomingMsgs[i].getRegionInfo();
switch (incomingMsgs[i].getMsg()) {
case HMsg.MSG_REPORT_PROCESS_OPEN:
synchronized (unassignedRegions) {
        unassignedRegions.put(region,System.currentTimeMillis() + this.maxRegionOpenTime);
      }
    break;
case HMsg.MSG_REPORT_OPEN:
  boolean duplicateAssignment=false;
synchronized (unassignedRegions) {
  if (unassignedRegions.remove(region) == null) {
    if (region.getRegionName().compareTo(HRegionInfo.rootRegionInfo.getRegionName()) == 0) {
      HServerAddress rootServer=rootRegionLocation.get();
      if (rootServer != null) {
        if (rootServer.toString().compareTo(serverName) == 0) {
          break;
        }
        duplicateAssignment=true;
      }
    }
 else {
      if (pendingRegions.contains(region.getRegionName())) {
        break;
      }
      duplicateAssignment=true;
    }
  }
  if (duplicateAssignment) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("region server " + info.getServerAddress().toString() + " should not have opened region "+ region.getRegionName());
    }
    returnMsgs.add(new HMsg(HMsg.MSG_REGION_CLOSE_WITHOUT_REPORT,region));
  }
 else {
    LOG.info(info.getServerAddress().toString() + " serving " + region.getRegionName());
    if (region.getRegionName().compareTo(HRegionInfo.rootRegionInfo.getRegionName()) == 0) {
synchronized (rootRegionLocation) {
        this.rootRegionLocation.set(new HServerAddress(info.getServerAddress()));
        this.rootRegionLocation.notifyAll();
      }
    }
 else {
      pendingRegions.add(region.getRegionName());
      try {
        toDoQueue.put(new ProcessRegionOpen(info,region));
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("Putting into toDoQueue was interrupted.",e);
      }
    }
  }
}
break;
case HMsg.MSG_REPORT_CLOSE:
LOG.info(info.getServerAddress().toString() + " no longer serving " + region.getRegionName());
if (region.getRegionName().compareTo(HRegionInfo.rootRegionInfo.getRegionName()) == 0) {
unassignRootRegion();
}
 else {
boolean reassignRegion=true;
boolean deleteRegion=false;
if (killedRegions.remove(region.getRegionName())) {
reassignRegion=false;
}
if (regionsToDelete.remove(region.getRegionName())) {
reassignRegion=false;
deleteRegion=true;
}
if (region.isMetaTable()) {
onlineMetaRegions.remove(region.getStartKey());
}
unassignedRegions.remove(region);
try {
toDoQueue.put(new ProcessRegionClose(region,reassignRegion,deleteRegion));
}
 catch (InterruptedException e) {
throw new RuntimeException("Putting into toDoQueue was interrupted.",e);
}
}
break;
case HMsg.MSG_REPORT_SPLIT:
HRegionInfo newRegionA=incomingMsgs[++i].getRegionInfo();
unassignedRegions.put(newRegionA,ZERO_L);
HRegionInfo newRegionB=incomingMsgs[++i].getRegionInfo();
unassignedRegions.put(newRegionB,ZERO_L);
LOG.info("region " + region.getRegionName() + " split. New regions are: "+ newRegionA.getRegionName()+ ", "+ newRegionB.getRegionName());
if (region.getTableDesc().getName().equals(META_TABLE_NAME)) {
onlineMetaRegions.remove(region.getStartKey());
numberOfMetaRegions.incrementAndGet();
}
break;
default :
throw new IOException("Impossible state during msg processing.  Instruction: " + incomingMsgs[i].getMsg());
}
}
if (regionsToKill != null) {
for (HRegionInfo i : regionsToKill.values()) {
returnMsgs.add(new HMsg(HMsg.MSG_REGION_CLOSE,i));
killedRegions.add(i.getRegionName());
}
}
assignRegions(info,serverName,returnMsgs);
return returnMsgs.toArray(new HMsg[returnMsgs.size()]);
}
