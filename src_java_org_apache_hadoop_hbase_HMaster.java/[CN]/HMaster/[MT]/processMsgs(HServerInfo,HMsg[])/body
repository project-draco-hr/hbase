{
  ArrayList<HMsg> returnMsgs=new ArrayList<HMsg>();
  TreeMap<Text,HRegionInfo> regionsToKill=killList.remove(info.getServerAddress().toString());
  for (int i=0; i < incomingMsgs.length; i++) {
    HRegionInfo region=incomingMsgs[i].getRegionInfo();
switch (incomingMsgs[i].getMsg()) {
case HMsg.MSG_REPORT_OPEN:
      HRegionInfo regionInfo=unassignedRegions.get(region.regionName);
    if (regionInfo == null) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("region server " + info.getServerAddress().toString() + " should not have opened region "+ region.regionName);
      }
      returnMsgs.add(new HMsg(HMsg.MSG_REGION_CLOSE_WITHOUT_REPORT,region));
    }
 else {
      LOG.info(info.getServerAddress().toString() + " serving " + region.regionName);
      unassignedRegions.remove(region.regionName);
      assignAttempts.remove(region.regionName);
      if (region.regionName.compareTo(HGlobals.rootRegionInfo.regionName) == 0) {
        rootRegionLocation=new HServerAddress(info.getServerAddress());
        break;
      }
      pendingRegions.add(region.regionName);
      try {
        msgQueue.put(new PendingOpenReport(info,region));
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("Putting into msgQueue was interrupted.",e);
      }
    }
  break;
case HMsg.MSG_REPORT_CLOSE:
LOG.info(info.getServerAddress().toString() + " no longer serving " + region.regionName);
if (region.regionName.compareTo(HGlobals.rootRegionInfo.regionName) == 0) {
rootRegionLocation=null;
unassignedRegions.put(region.regionName,region);
assignAttempts.put(region.regionName,Long.valueOf(0L));
}
 else {
boolean reassignRegion=true;
boolean deleteRegion=false;
if (killedRegions.remove(region.regionName)) {
  reassignRegion=false;
}
if (regionsToDelete.remove(region.regionName)) {
  reassignRegion=false;
  deleteRegion=true;
}
unassignedRegions.remove(region.regionName);
assignAttempts.remove(region.regionName);
try {
  msgQueue.put(new PendingCloseReport(region,reassignRegion,deleteRegion));
}
 catch (InterruptedException e) {
  throw new RuntimeException("Putting into msgQueue was interrupted.",e);
}
}
break;
case HMsg.MSG_REPORT_SPLIT:
HRegionInfo newRegionA=incomingMsgs[++i].getRegionInfo();
HRegionInfo newRegionB=incomingMsgs[++i].getRegionInfo();
LOG.info("region " + region.regionName + " split. New regions are: "+ newRegionA.regionName+ ", "+ newRegionB.regionName);
if (region.tableDesc.getName().equals(META_TABLE_NAME)) {
onlineMetaRegions.remove(region.getStartKey());
onlineMetaRegions.put(newRegionA.getStartKey(),new MetaRegion(info.getServerAddress(),newRegionA.getRegionName(),newRegionA.getStartKey()));
onlineMetaRegions.put(newRegionB.getStartKey(),new MetaRegion(info.getServerAddress(),newRegionB.getRegionName(),newRegionB.getStartKey()));
numberOfMetaRegions.incrementAndGet();
}
break;
default :
throw new IOException("Impossible state during msg processing.  Instruction: " + incomingMsgs[i].getMsg());
}
}
if (regionsToKill != null) {
for (HRegionInfo i : regionsToKill.values()) {
returnMsgs.add(new HMsg(HMsg.MSG_REGION_CLOSE,i));
killedRegions.add(i.regionName);
}
}
if (unassignedRegions.size() > 0) {
int targetForServer=(int)Math.ceil(unassignedRegions.size() / (1.0 * serversToServerInfo.size()));
int counter=0;
long now=System.currentTimeMillis();
for (Text curRegionName : unassignedRegions.keySet()) {
HRegionInfo regionInfo=unassignedRegions.get(curRegionName);
long assignedTime=assignAttempts.get(curRegionName);
if (now - assignedTime > maxRegionOpenTime) {
LOG.info("assigning region " + regionInfo.regionName + " to server "+ info.getServerAddress().toString());
returnMsgs.add(new HMsg(HMsg.MSG_REGION_OPEN,regionInfo));
assignAttempts.put(curRegionName,Long.valueOf(now));
counter++;
}
if (counter >= targetForServer) {
break;
}
}
}
return returnMsgs.toArray(new HMsg[returnMsgs.size()]);
}
