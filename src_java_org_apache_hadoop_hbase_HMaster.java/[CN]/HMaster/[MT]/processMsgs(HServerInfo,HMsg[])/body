{
  ArrayList<HMsg> returnMsgs=new ArrayList<HMsg>();
  String serverName=info.getServerAddress().toString();
  HashMap<Text,HRegionInfo> regionsToKill=null;
  regionsToKill=killList.remove(serverName);
  for (int i=0; i < incomingMsgs.length; i++) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Received " + incomingMsgs[i].toString() + "from "+ serverName);
    }
    HRegionInfo region=incomingMsgs[i].getRegionInfo();
switch (incomingMsgs[i].getMsg()) {
case HMsg.MSG_REPORT_PROCESS_OPEN:
synchronized (this.assignAttempts) {
        assignAttempts.put(region.getRegionName(),Long.valueOf(assignAttempts.get(region.getRegionName()).longValue() + (this.maxRegionOpenTime / 2)));
      }
    break;
case HMsg.MSG_REPORT_OPEN:
  HRegionInfo regionInfo=unassignedRegions.get(region.getRegionName());
if (regionInfo == null) {
  if (LOG.isDebugEnabled()) {
    LOG.debug("region server " + info.getServerAddress().toString() + " should not have opened region "+ region.getRegionName());
  }
  returnMsgs.add(new HMsg(HMsg.MSG_REGION_CLOSE_WITHOUT_REPORT,region));
}
 else {
  LOG.info(info.getServerAddress().toString() + " serving " + region.getRegionName());
  if (region.getRegionName().compareTo(HRegionInfo.rootRegionInfo.getRegionName()) == 0) {
synchronized (rootRegionLocation) {
      this.rootRegionLocation.set(new HServerAddress(info.getServerAddress()));
      this.rootRegionLocation.notifyAll();
    }
  }
 else {
    pendingRegions.add(region.getRegionName());
    try {
      msgQueue.put(new ProcessRegionOpen(info,region));
    }
 catch (    InterruptedException e) {
      throw new RuntimeException("Putting into msgQueue was interrupted.",e);
    }
  }
  this.unassignedRegions.remove(region.getRegionName());
  this.assignAttempts.remove(region.getRegionName());
}
break;
case HMsg.MSG_REPORT_CLOSE:
LOG.info(info.getServerAddress().toString() + " no longer serving " + region.getRegionName());
if (region.getRegionName().compareTo(HRegionInfo.rootRegionInfo.getRegionName()) == 0) {
unassignRootRegion();
}
 else {
boolean reassignRegion=true;
boolean deleteRegion=false;
if (killedRegions.remove(region.getRegionName())) {
reassignRegion=false;
}
if (regionsToDelete.remove(region.getRegionName())) {
reassignRegion=false;
deleteRegion=true;
}
unassignedRegions.remove(region.getRegionName());
assignAttempts.remove(region.getRegionName());
try {
msgQueue.put(new ProcessRegionClose(region,reassignRegion,deleteRegion));
}
 catch (InterruptedException e) {
throw new RuntimeException("Putting into msgQueue was interrupted.",e);
}
}
break;
case HMsg.MSG_REPORT_SPLIT:
HRegionInfo newRegionA=incomingMsgs[++i].getRegionInfo();
unassignedRegions.put(newRegionA.getRegionName(),newRegionA);
assignAttempts.put(newRegionA.getRegionName(),Long.valueOf(0L));
HRegionInfo newRegionB=incomingMsgs[++i].getRegionInfo();
unassignedRegions.put(newRegionB.getRegionName(),newRegionB);
assignAttempts.put(newRegionB.getRegionName(),Long.valueOf(0L));
LOG.info("region " + region.getRegionName() + " split. New regions are: "+ newRegionA.getRegionName()+ ", "+ newRegionB.getRegionName());
if (region.getTableDesc().getName().equals(META_TABLE_NAME)) {
onlineMetaRegions.remove(region.getStartKey());
numberOfMetaRegions.incrementAndGet();
}
break;
default :
throw new IOException("Impossible state during msg processing.  Instruction: " + incomingMsgs[i].getMsg());
}
}
if (regionsToKill != null) {
for (HRegionInfo i : regionsToKill.values()) {
returnMsgs.add(new HMsg(HMsg.MSG_REGION_CLOSE,i));
killedRegions.add(i.getRegionName());
}
}
assignRegions(info,serverName,returnMsgs);
return returnMsgs.toArray(new HMsg[returnMsgs.size()]);
}
