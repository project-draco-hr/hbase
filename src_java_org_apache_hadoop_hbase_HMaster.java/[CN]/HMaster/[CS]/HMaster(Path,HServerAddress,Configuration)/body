{
  this.fsOk=true;
  this.dir=dir;
  this.conf=conf;
  this.fs=FileSystem.get(conf);
  this.rand=new Random();
  Path rootRegionDir=HRegion.getRegionDir(dir,HGlobals.rootRegionInfo.regionName);
  LOG.info("Root region dir: " + rootRegionDir.toString());
  try {
    if (!fs.exists(dir)) {
      fs.mkdirs(dir);
    }
    if (!fs.exists(rootRegionDir)) {
      LOG.info("bootstrap: creating ROOT and first META regions");
      try {
        HRegion root=HRegion.createHRegion(HGlobals.rootRegionInfo,this.dir,this.conf,null);
        HRegion meta=HRegion.createHRegion(new HRegionInfo(1L,HGlobals.metaTableDesc,null,null),this.dir,this.conf,null);
        HRegion.addRegionToMETA(root,meta);
        root.close();
        root.getLog().closeAndDelete();
        meta.close();
        meta.getLog().closeAndDelete();
      }
 catch (      IOException e) {
        e=RemoteExceptionHandler.checkIOException(e);
        LOG.error("bootstrap",e);
        throw e;
      }
    }
  }
 catch (  IOException e) {
    LOG.fatal("Not starting HMaster because:",e);
    throw e;
  }
  this.threadWakeFrequency=conf.getInt(THREAD_WAKE_FREQUENCY,10 * 1000);
  this.numRetries=conf.getInt("hbase.client.retries.number",2);
  this.maxRegionOpenTime=conf.getLong("hbase.hbasemaster.maxregionopen",30 * 1000);
  this.shutdownQueue=new DelayQueue<PendingServerShutdown>();
  this.msgQueue=new LinkedBlockingQueue<PendingOperation>();
  this.leaseTimeout=conf.getInt("hbase.master.lease.period",30 * 1000);
  this.serverLeases=new Leases(this.leaseTimeout,conf.getInt("hbase.master.lease.thread.wakefrequency",15 * 1000));
  this.server=RPC.getServer(this,address.getBindAddress(),address.getPort(),conf.getInt("hbase.regionserver.handler.count",10),false,conf);
  this.address=new HServerAddress(server.getListenerAddress());
  conf.set(MASTER_ADDRESS,address.toString());
  this.connection=HConnectionManager.getConnection(conf);
  this.metaRescanInterval=conf.getInt("hbase.master.meta.thread.rescanfrequency",60 * 1000);
  this.rootScanned=false;
  this.rootScannerThread=new RootScanner();
  this.numberOfMetaRegions=new AtomicInteger();
  this.metaRegionsToScan=new LinkedBlockingQueue<MetaRegion>();
  this.onlineMetaRegions=Collections.synchronizedSortedMap(new TreeMap<Text,MetaRegion>());
  this.initialMetaScanComplete=false;
  this.metaScannerThread=new MetaScanner();
  this.unassignedRegions=Collections.synchronizedSortedMap(new TreeMap<Text,HRegionInfo>());
  this.unassignedRegions.put(HGlobals.rootRegionInfo.regionName,HGlobals.rootRegionInfo);
  this.assignAttempts=Collections.synchronizedMap(new HashMap<Text,Long>());
  this.assignAttempts.put(HGlobals.rootRegionInfo.regionName,Long.valueOf(0L));
  this.pendingRegions=Collections.synchronizedSet(new HashSet<Text>());
  this.killList=Collections.synchronizedMap(new HashMap<String,HashMap<Text,HRegionInfo>>());
  this.killedRegions=Collections.synchronizedSet(new HashSet<Text>());
  this.regionsToDelete=Collections.synchronizedSet(new HashSet<Text>());
  this.serversToServerInfo=new HashMap<String,HServerInfo>();
  this.loadToServers=new TreeMap<HServerLoad,Set<String>>();
  this.serversToLoad=new HashMap<String,HServerLoad>();
  this.sleeper=new Sleeper(this.threadWakeFrequency,this.closed);
  this.closed.set(false);
  LOG.info("HMaster initialized on " + this.address.toString());
}
