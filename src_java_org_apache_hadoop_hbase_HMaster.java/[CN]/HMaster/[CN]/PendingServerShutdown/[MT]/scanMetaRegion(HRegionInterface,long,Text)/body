{
  Vector<HStoreKey> toDoList=new Vector<HStoreKey>();
  TreeMap<Text,HRegionInfo> regions=new TreeMap<Text,HRegionInfo>();
  DataInputBuffer inbuf=new DataInputBuffer();
  try {
    while (true) {
      LabelledData[] values=null;
      HStoreKey key=new HStoreKey();
      try {
        values=server.next(scannerId,key);
      }
 catch (      NotServingRegionException e) {
        throw e;
      }
catch (      IOException e) {
        LOG.error(e);
        break;
      }
      if (values == null || values.length == 0) {
        break;
      }
      TreeMap<Text,byte[]> results=new TreeMap<Text,byte[]>();
      for (int i=0; i < values.length; i++) {
        results.put(values[i].getLabel(),values[i].getData().get());
      }
      byte[] bytes=results.get(COL_SERVER);
      String serverName=null;
      if (bytes == null || bytes.length == 0) {
        continue;
      }
      try {
        serverName=new String(bytes,UTF8_ENCODING);
      }
 catch (      UnsupportedEncodingException e) {
        LOG.error(e);
        break;
      }
      if (deadServer.compareTo(serverName) != 0) {
        continue;
      }
      bytes=results.get(COL_STARTCODE);
      if (bytes == null || bytes.length == 0) {
        continue;
      }
      long startCode=-1L;
      try {
        startCode=Long.valueOf(new String(bytes,UTF8_ENCODING));
      }
 catch (      UnsupportedEncodingException e) {
        LOG.error(e);
        break;
      }
      if (oldStartCode != startCode) {
        continue;
      }
      bytes=results.get(COL_REGIONINFO);
      if (bytes == null || bytes.length == 0) {
        throw new IOException("no value for " + COL_REGIONINFO);
      }
      inbuf.reset(bytes,bytes.length);
      HRegionInfo info=new HRegionInfo();
      try {
        info.readFields(inbuf);
      }
 catch (      IOException e) {
        LOG.error(e);
        break;
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug(serverName + " was serving " + info.regionName);
      }
      toDoList.add(key);
      regions.put(info.regionName,info);
    }
  }
  finally {
    if (scannerId != -1L) {
      try {
        server.close(scannerId);
      }
 catch (      IOException e) {
        LOG.error(e);
      }
    }
  }
  for (int i=0; i < toDoList.size(); i++) {
    long lockid=server.startUpdate(regionName,clientId,toDoList.get(i).getRow());
    server.delete(regionName,clientId,lockid,COL_SERVER);
    server.delete(regionName,clientId,lockid,COL_STARTCODE);
    server.commit(regionName,clientId,lockid);
  }
  for (Iterator<Map.Entry<Text,HRegionInfo>> i=regions.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry<Text,HRegionInfo> e=i.next();
    Text region=e.getKey();
    HRegionInfo regionInfo=e.getValue();
    unassignedRegions.put(region,regionInfo);
    assignAttempts.put(region,0L);
  }
}
