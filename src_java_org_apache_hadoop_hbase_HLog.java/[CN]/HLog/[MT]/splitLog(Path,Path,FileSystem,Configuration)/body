{
  Path logfiles[]=fs.listPaths(new Path[]{srcDir});
  LOG.info("splitting " + logfiles.length + " log(s) in "+ srcDir.toString());
  Map<Text,SequenceFile.Writer> logWriters=new HashMap<Text,SequenceFile.Writer>();
  try {
    for (int i=0; i < logfiles.length; i++) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Splitting " + logfiles[i]);
      }
      if (fs.getFileStatus(logfiles[i]).getLen() <= 0) {
        LOG.warn("Skipping " + logfiles[i].toString() + " because zero length");
        continue;
      }
      SequenceFile.Reader in=new SequenceFile.Reader(fs,logfiles[i],conf);
      try {
        HLogKey key=new HLogKey();
        HLogEdit val=new HLogEdit();
        while (in.next(key,val)) {
          Text regionName=key.getRegionName();
          SequenceFile.Writer w=logWriters.get(regionName);
          if (w == null) {
            Path logfile=new Path(HRegion.getRegionDir(rootDir,HRegionInfo.rootRegionInfo.getEncodedName()),HREGION_OLDLOGFILE_NAME);
            if (LOG.isDebugEnabled()) {
              LOG.debug("getting new log file writer for path " + logfile);
            }
            w=SequenceFile.createWriter(fs,conf,logfile,HLogKey.class,HLogEdit.class);
            logWriters.put(regionName,w);
          }
          if (LOG.isDebugEnabled()) {
            LOG.debug("Edit " + key.toString() + "="+ val.toString());
          }
          w.append(key,val);
        }
      }
  finally {
        in.close();
      }
    }
  }
  finally {
    for (    SequenceFile.Writer w : logWriters.values()) {
      w.close();
    }
  }
  if (fs.exists(srcDir)) {
    if (!fs.delete(srcDir)) {
      LOG.error("Cannot delete: " + srcDir);
      if (!FileUtil.fullyDelete(new File(srcDir.toString()))) {
        throw new IOException("Cannot delete: " + srcDir);
      }
    }
  }
  LOG.info("log file splitting completed for " + srcDir.toString());
}
