{
  if (closed) {
    throw new IOException("Cannot roll log; log is closed");
  }
  cacheFlushLock.lock();
  try {
synchronized (this) {
      if (writer != null) {
        writer.close();
        Path p=computeFilename(filenum - 1);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Closing current log writer " + p.toString() + " to get a new one");
        }
        if (filenum > 0) {
          outputfiles.put(logSeqNum.get() - 1,p);
        }
      }
      Path newPath=computeFilename(filenum++);
      this.writer=SequenceFile.createWriter(fs,conf,newPath,HLogKey.class,HLogEdit.class);
      if (LOG.isDebugEnabled()) {
        LOG.debug("new log writer created at " + newPath);
      }
      long oldestOutstandingSeqNum=Long.MAX_VALUE;
      for (      Long l : lastSeqWritten.values()) {
        long curSeqNum=l.longValue();
        if (curSeqNum < oldestOutstandingSeqNum) {
          oldestOutstandingSeqNum=curSeqNum;
        }
      }
      TreeSet<Long> sequenceNumbers=new TreeSet<Long>();
      sequenceNumbers.addAll(outputfiles.headMap(oldestOutstandingSeqNum).keySet());
      for (      Long seq : sequenceNumbers) {
        Path p=outputfiles.remove(seq);
        if (LOG.isDebugEnabled()) {
          LOG.debug("removing old log file " + p.toString());
        }
        fs.delete(p);
      }
      this.numEntries.set(0);
    }
  }
  finally {
    cacheFlushLock.unlock();
  }
}
