{
  boolean locked=false;
  while (!locked && !closed) {
    if (cacheFlushLock.tryLock()) {
      locked=true;
      break;
    }
    try {
      this.wait(threadWakeFrequency);
    }
 catch (    InterruptedException e) {
    }
  }
  if (closed) {
    if (locked) {
      cacheFlushLock.unlock();
    }
    throw new IOException("Cannot roll log; log is closed");
  }
  try {
    if (writer != null) {
      writer.close();
      Path p=computeFilename(filenum - 1);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Closing current log writer " + p.toString() + " to get a new one");
      }
      if (filenum > 0) {
synchronized (sequenceLock) {
          outputfiles.put(logSeqNum - 1,p);
        }
      }
    }
    Path newPath=computeFilename(filenum++);
    this.writer=SequenceFile.createWriter(fs,conf,newPath,HLogKey.class,HLogEdit.class);
    LOG.info("new log writer created at " + newPath);
    TreeSet<Long> sequenceNumbers=new TreeSet<Long>(lastSeqWritten.values());
    if (sequenceNumbers.size() > 0) {
      long oldestOutstandingSeqNum=sequenceNumbers.first();
      sequenceNumbers.clear();
      sequenceNumbers.addAll(outputfiles.headMap(oldestOutstandingSeqNum).keySet());
      for (      Long seq : sequenceNumbers) {
        Path p=outputfiles.remove(seq);
        LOG.info("removing old log file " + p.toString());
        fs.delete(p);
      }
    }
    this.numEntries=0;
  }
  finally {
    cacheFlushLock.unlock();
  }
}
