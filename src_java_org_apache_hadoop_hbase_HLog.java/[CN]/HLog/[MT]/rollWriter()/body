{
synchronized (rollLock) {
    Vector<Path> toDeleteList=new Vector<Path>();
synchronized (this) {
      if (closed) {
        throw new IOException("Cannot roll log; log is closed");
      }
      while (insideCacheFlush) {
        try {
          wait();
        }
 catch (        InterruptedException ie) {
        }
      }
      if (writer != null) {
        writer.close();
        Path p=computeFilename(filenum - 1);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Closing current log writer " + p.toString() + " to get a new one");
        }
        if (filenum > 0) {
          outputfiles.put(logSeqNum - 1,p);
        }
      }
      Path newPath=computeFilename(filenum++);
      this.writer=SequenceFile.createWriter(fs,conf,newPath,HLogKey.class,HLogEdit.class);
      if (LOG.isDebugEnabled()) {
        LOG.debug("new log writer created at " + newPath);
      }
      long oldestOutstandingSeqNum=Long.MAX_VALUE;
      for (      Long l : regionToLastFlush.values()) {
        long curSeqNum=l.longValue();
        if (curSeqNum < oldestOutstandingSeqNum) {
          oldestOutstandingSeqNum=curSeqNum;
        }
      }
      for (Iterator<Long> it=outputfiles.keySet().iterator(); it.hasNext(); ) {
        long maxSeqNum=it.next().longValue();
        if (maxSeqNum < oldestOutstandingSeqNum) {
          Path p=outputfiles.get(maxSeqNum);
          it.remove();
          toDeleteList.add(p);
        }
 else {
          break;
        }
      }
    }
    for (Iterator<Path> it=toDeleteList.iterator(); it.hasNext(); ) {
      Path p=it.next();
      if (LOG.isDebugEnabled()) {
        LOG.debug("removing old log file " + p.toString());
      }
      fs.delete(p);
    }
    this.numEntries.set(0);
  }
}
