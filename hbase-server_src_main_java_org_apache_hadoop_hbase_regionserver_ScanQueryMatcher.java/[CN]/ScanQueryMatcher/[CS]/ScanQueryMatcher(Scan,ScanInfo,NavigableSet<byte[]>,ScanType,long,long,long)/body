{
  this.tr=scan.getTimeRange();
  this.rowComparator=scanInfo.getComparator();
  this.deletes=new ScanDeleteTracker();
  this.stopRow=scan.getStopRow();
  this.startKey=KeyValueUtil.createFirstDeleteFamilyOnRow(scan.getStartRow(),scanInfo.getFamily());
  this.filter=scan.getFilter();
  this.earliestPutTs=earliestPutTs;
  this.maxReadPointToTrackVersions=readPointToUse;
  this.timeToPurgeDeletes=scanInfo.getTimeToPurgeDeletes();
  this.isUserScan=scanType == ScanType.USER_SCAN;
  this.keepDeletedCells=(scanInfo.getKeepDeletedCells() && !isUserScan) || scan.isRaw();
  this.retainDeletesInOutput=scanType == ScanType.COMPACT_RETAIN_DELETES || scan.isRaw();
  this.seePastDeleteMarkers=scanInfo.getKeepDeletedCells() && isUserScan;
  int maxVersions=scan.isRaw() ? scan.getMaxVersions() : Math.min(scan.getMaxVersions(),scanInfo.getMaxVersions());
  if (columns == null || columns.size() == 0) {
    hasNullColumn=true;
    this.columns=new ScanWildcardColumnTracker(scanInfo.getMinVersions(),maxVersions,oldestUnexpiredTS);
  }
 else {
    hasNullColumn=(columns.first().length == 0);
    byte[] attr=scan.getAttribute(Scan.HINT_LOOKAHEAD);
    this.columns=new ExplicitColumnTracker(columns,scanInfo.getMinVersions(),maxVersions,oldestUnexpiredTS,attr == null ? 0 : Bytes.toInt(attr));
  }
  this.isReversed=scan.isReversed();
}
