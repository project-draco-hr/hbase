{
  if (filter != null && filter.filterAllRemaining()) {
    return MatchCode.DONE_SCAN;
  }
  byte[] bytes=kv.getBuffer();
  int offset=kv.getOffset();
  int initialOffset=offset;
  int keyLength=Bytes.toInt(bytes,offset,Bytes.SIZEOF_INT);
  offset+=KeyValue.ROW_OFFSET;
  short rowLength=Bytes.toShort(bytes,offset,Bytes.SIZEOF_SHORT);
  offset+=Bytes.SIZEOF_SHORT;
  int ret=this.rowComparator.compareRows(row,0,row.length,bytes,offset,rowLength);
  if (ret <= -1) {
    return MatchCode.DONE;
  }
 else   if (ret >= 1) {
    return MatchCode.SEEK_NEXT_ROW;
  }
  if (this.stickyNextRow)   return MatchCode.SEEK_NEXT_ROW;
  if (this.columns.done()) {
    stickyNextRow=true;
    return MatchCode.SEEK_NEXT_ROW;
  }
  offset+=rowLength;
  byte familyLength=bytes[offset];
  offset+=familyLength + 1;
  int qualLength=keyLength + KeyValue.ROW_OFFSET - (offset - initialOffset) - KeyValue.TIMESTAMP_TYPE_SIZE;
  long timestamp=kv.getTimestamp();
  if (columns.isDone(timestamp)) {
    return columns.getNextRowOrNextColumn(bytes,offset,qualLength);
  }
  byte type=kv.getType();
  if (kv.isDelete()) {
    if (!keepDeletedCells) {
      boolean includeDeleteMarker=seePastDeleteMarkers ? tr.withinTimeRange(timestamp) : tr.withinOrAfterTimeRange(timestamp);
      if (includeDeleteMarker && kv.getMemstoreTS() <= maxReadPointToTrackVersions) {
        this.deletes.add(bytes,offset,qualLength,timestamp,type);
      }
    }
    if (retainDeletesInOutput || (!isUserScan && (EnvironmentEdgeManager.currentTimeMillis() - timestamp) <= timeToPurgeDeletes) || kv.getMemstoreTS() > maxReadPointToTrackVersions) {
      return MatchCode.INCLUDE;
    }
 else     if (keepDeletedCells) {
      if (timestamp < earliestPutTs) {
        return columns.getNextRowOrNextColumn(bytes,offset,qualLength);
      }
    }
 else {
      return MatchCode.SKIP;
    }
  }
 else   if (!this.deletes.isEmpty()) {
    DeleteResult deleteResult=deletes.isDeleted(bytes,offset,qualLength,timestamp);
switch (deleteResult) {
case FAMILY_DELETED:
case COLUMN_DELETED:
      return columns.getNextRowOrNextColumn(bytes,offset,qualLength);
case VERSION_DELETED:
    return MatchCode.SKIP;
case NOT_DELETED:
  break;
default :
throw new RuntimeException("UNEXPECTED");
}
}
int timestampComparison=tr.compare(timestamp);
if (timestampComparison >= 1) {
return MatchCode.SKIP;
}
 else if (timestampComparison <= -1) {
return columns.getNextRowOrNextColumn(bytes,offset,qualLength);
}
ReturnCode filterResponse=ReturnCode.SKIP;
if (filter != null) {
filterResponse=filter.filterKeyValue(kv);
if (filterResponse == ReturnCode.SKIP) {
return MatchCode.SKIP;
}
 else if (filterResponse == ReturnCode.NEXT_COL) {
return columns.getNextRowOrNextColumn(bytes,offset,qualLength);
}
 else if (filterResponse == ReturnCode.NEXT_ROW) {
stickyNextRow=true;
return MatchCode.SEEK_NEXT_ROW;
}
 else if (filterResponse == ReturnCode.SEEK_NEXT_USING_HINT) {
return MatchCode.SEEK_NEXT_USING_HINT;
}
}
MatchCode colChecker=columns.checkColumn(bytes,offset,qualLength,timestamp,type,kv.getMemstoreTS() > maxReadPointToTrackVersions);
if (colChecker == MatchCode.SEEK_NEXT_ROW) {
stickyNextRow=true;
}
 else if (filter != null && colChecker == MatchCode.INCLUDE && filterResponse == ReturnCode.INCLUDE_AND_NEXT_COL) {
return MatchCode.INCLUDE_AND_SEEK_NEXT_COL;
}
return colChecker;
}
