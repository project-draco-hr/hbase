{
  if (filter != null && filter.filterAllRemaining()) {
    return MatchCode.DONE_SCAN;
  }
  byte[] bytes=kv.getBuffer();
  int offset=kv.getOffset();
  int keyLength=Bytes.toInt(bytes,offset,Bytes.SIZEOF_INT);
  offset+=KeyValue.ROW_OFFSET;
  int initialOffset=offset;
  short rowLength=Bytes.toShort(bytes,offset,Bytes.SIZEOF_SHORT);
  offset+=Bytes.SIZEOF_SHORT;
  int ret=this.rowComparator.compareRows(row,this.rowOffset,this.rowLength,bytes,offset,rowLength);
  if (!this.isReversed) {
    if (ret <= -1) {
      return MatchCode.DONE;
    }
 else     if (ret >= 1) {
      return MatchCode.SEEK_NEXT_ROW;
    }
  }
 else {
    if (ret <= -1) {
      return MatchCode.SEEK_NEXT_ROW;
    }
 else     if (ret >= 1) {
      return MatchCode.DONE;
    }
  }
  if (this.stickyNextRow)   return MatchCode.SEEK_NEXT_ROW;
  if (this.columns.done()) {
    stickyNextRow=true;
    return MatchCode.SEEK_NEXT_ROW;
  }
  offset+=rowLength;
  byte familyLength=bytes[offset];
  offset+=familyLength + 1;
  int qualLength=keyLength - (offset - initialOffset) - KeyValue.TIMESTAMP_TYPE_SIZE;
  long timestamp=Bytes.toLong(bytes,initialOffset + keyLength - KeyValue.TIMESTAMP_TYPE_SIZE);
  if (columns.isDone(timestamp)) {
    return columns.getNextRowOrNextColumn(bytes,offset,qualLength);
  }
  byte type=bytes[initialOffset + keyLength - 1];
  if (kv.isDelete()) {
    if (!keepDeletedCells) {
      boolean includeDeleteMarker=seePastDeleteMarkers ? tr.withinTimeRange(timestamp) : tr.withinOrAfterTimeRange(timestamp);
      if (includeDeleteMarker && kv.getMvccVersion() <= maxReadPointToTrackVersions) {
        this.deletes.add(bytes,offset,qualLength,timestamp,type);
      }
    }
    if (retainDeletesInOutput || (!isUserScan && (EnvironmentEdgeManager.currentTimeMillis() - timestamp) <= timeToPurgeDeletes) || kv.getMvccVersion() > maxReadPointToTrackVersions) {
      if (!isUserScan) {
        return MatchCode.INCLUDE;
      }
    }
 else     if (keepDeletedCells) {
      if (timestamp < earliestPutTs) {
        return columns.getNextRowOrNextColumn(bytes,offset,qualLength);
      }
    }
 else {
      return MatchCode.SKIP;
    }
  }
 else   if (!this.deletes.isEmpty()) {
    DeleteResult deleteResult=deletes.isDeleted(bytes,offset,qualLength,timestamp);
switch (deleteResult) {
case FAMILY_DELETED:
case COLUMN_DELETED:
      return columns.getNextRowOrNextColumn(bytes,offset,qualLength);
case VERSION_DELETED:
case FAMILY_VERSION_DELETED:
    return MatchCode.SKIP;
case NOT_DELETED:
  break;
default :
throw new RuntimeException("UNEXPECTED");
}
}
int timestampComparison=tr.compare(timestamp);
if (timestampComparison >= 1) {
return MatchCode.SKIP;
}
 else if (timestampComparison <= -1) {
return columns.getNextRowOrNextColumn(bytes,offset,qualLength);
}
MatchCode colChecker=columns.checkColumn(bytes,offset,qualLength,type);
if (colChecker == MatchCode.INCLUDE) {
ReturnCode filterResponse=ReturnCode.SKIP;
if (filter != null) {
filterResponse=filter.filterKeyValue(kv);
switch (filterResponse) {
case SKIP:
return MatchCode.SKIP;
case NEXT_COL:
return columns.getNextRowOrNextColumn(bytes,offset,qualLength);
case NEXT_ROW:
stickyNextRow=true;
return MatchCode.SEEK_NEXT_ROW;
case SEEK_NEXT_USING_HINT:
return MatchCode.SEEK_NEXT_USING_HINT;
default :
break;
}
}
colChecker=columns.checkVersions(bytes,offset,qualLength,timestamp,type,kv.getMvccVersion() > maxReadPointToTrackVersions);
stickyNextRow=colChecker == MatchCode.INCLUDE_AND_SEEK_NEXT_ROW ? true : stickyNextRow;
return (filterResponse == ReturnCode.INCLUDE_AND_NEXT_COL && colChecker == MatchCode.INCLUDE) ? MatchCode.INCLUDE_AND_SEEK_NEXT_COL : colChecker;
}
stickyNextRow=(colChecker == MatchCode.SEEK_NEXT_ROW) ? true : stickyNextRow;
return colChecker;
}
