{
  if (this.parent.getCoprocessorHost() != null) {
    this.parent.getCoprocessorHost().preRollBackSplit();
  }
  boolean result=true;
  ListIterator<JournalEntry> iterator=this.journal.listIterator(this.journal.size());
  while (iterator.hasPrevious()) {
    JournalEntry je=iterator.previous();
switch (je) {
case SET_SPLITTING:
      if (server != null && server instanceof HRegionServer) {
        ((BaseCoordinatedStateManager)server.getCoordinatedStateManager()).getSplitTransactionCoordination().clean(this.parent.getRegionInfo());
      }
    break;
case CREATE_SPLIT_DIR:
  this.parent.writestate.writesEnabled=true;
this.parent.getRegionFileSystem().cleanupSplitsDir();
break;
case CLOSED_PARENT_REGION:
try {
this.parent.initialize();
}
 catch (IOException e) {
LOG.error("Failed rollbacking CLOSED_PARENT_REGION of region " + this.parent.getRegionNameAsString(),e);
throw new RuntimeException(e);
}
break;
case STARTED_REGION_A_CREATION:
this.parent.getRegionFileSystem().cleanupDaughterRegion(this.hri_a);
break;
case STARTED_REGION_B_CREATION:
this.parent.getRegionFileSystem().cleanupDaughterRegion(this.hri_b);
break;
case OFFLINED_PARENT:
if (services != null) services.addToOnlineRegions(this.parent);
break;
case PONR:
return false;
default :
throw new RuntimeException("Unhandled journal entry: " + je);
}
}
if (this.parent.getCoprocessorHost() != null) {
this.parent.getCoprocessorHost().postRollBackSplit();
}
return result;
}
