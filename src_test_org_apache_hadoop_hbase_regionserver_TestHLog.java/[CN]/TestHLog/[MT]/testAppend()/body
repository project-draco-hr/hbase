{
  final int COL_COUNT=10;
  final byte[] regionName=Bytes.toBytes("regionname");
  final byte[] tableName=Bytes.toBytes("tablename");
  final byte[] row=Bytes.toBytes("row");
  Reader reader=null;
  HLog log=new HLog(fs,dir,this.conf,null);
  try {
    long timestamp=System.currentTimeMillis();
    TreeMap<HStoreKey,byte[]> cols=new TreeMap<HStoreKey,byte[]>();
    for (int i=0; i < COL_COUNT; i++) {
      cols.put(new HStoreKey(row,Bytes.toBytes(Integer.toString(i)),timestamp),new byte[]{(byte)(i + '0')});
    }
    log.append(regionName,tableName,cols,false);
    long logSeqId=log.startCacheFlush();
    log.completeCacheFlush(regionName,tableName,logSeqId);
    log.close();
    Path filename=log.computeFilename(log.getFilenum());
    log=null;
    reader=new SequenceFile.Reader(fs,filename,conf);
    HLogKey key=new HLogKey();
    HLogEdit val=new HLogEdit();
    for (int i=0; i < COL_COUNT; i++) {
      reader.next(key,val);
      assertTrue(Bytes.equals(regionName,key.getRegionName()));
      assertTrue(Bytes.equals(tableName,key.getTablename()));
      assertTrue(Bytes.equals(row,key.getRow()));
      assertEquals((byte)(i + '0'),val.getVal()[0]);
      System.out.println(key + " " + val);
    }
    while (reader.next(key,val)) {
      assertTrue(Bytes.equals(regionName,key.getRegionName()));
      assertTrue(Bytes.equals(tableName,key.getTablename()));
      assertTrue(Bytes.equals(HLog.METAROW,key.getRow()));
      assertTrue(Bytes.equals(HLog.METACOLUMN,val.getColumn()));
      assertEquals(0,Bytes.compareTo(HLogEdit.COMPLETE_CACHE_FLUSH,val.getVal()));
      System.out.println(key + " " + val);
    }
  }
  finally {
    if (log != null) {
      log.closeAndDelete();
    }
    if (reader != null) {
      reader.close();
    }
  }
}
