{
  try {
    long rowKeyBase;
    StringBuilder buf=new StringBuilder();
    byte[][] columnFamilies=dataGenerator.getColumnFamilies();
    while ((rowKeyBase=getNextKeyToUpdate()) < endKey) {
      if (RandomUtils.nextInt(100) < updatePercent) {
        byte[] rowKey=dataGenerator.getDeterministicUniqueKey(rowKeyBase);
        Increment inc=new Increment(rowKey);
        Append app=new Append(rowKey);
        numKeys.addAndGet(1);
        int columnCount=0;
        for (        byte[] cf : columnFamilies) {
          long cfHash=Arrays.hashCode(cf);
          inc.addColumn(cf,INCREMENT,cfHash);
          buf.setLength(0);
          buf.append("#").append(Bytes.toString(INCREMENT));
          buf.append(":").append(MutationType.INCREMENT.getNumber());
          app.add(cf,MUTATE_INFO,Bytes.toBytes(buf.toString()));
          ++columnCount;
          if (!isBatchUpdate) {
            mutate(table,inc,rowKeyBase);
            numCols.addAndGet(1);
            inc=new Increment(rowKey);
            mutate(table,app,rowKeyBase);
            numCols.addAndGet(1);
            app=new Append(rowKey);
          }
          Result result=null;
          try {
            Get get=new Get(rowKey);
            get.addFamily(cf);
            result=table.get(get);
          }
 catch (          IOException ie) {
            LOG.warn("Failed to get the row for key = [" + rowKey + "], column family = ["+ Bytes.toString(cf)+ "]",ie);
          }
          Map<byte[],byte[]> columnValues=result != null ? result.getFamilyMap(cf) : null;
          if (columnValues == null) {
            failedKeySet.add(rowKeyBase);
            LOG.error("Failed to update the row with key = [" + rowKey + "], since we could not get the original row");
          }
          for (          byte[] column : columnValues.keySet()) {
            if (Bytes.equals(column,INCREMENT) || Bytes.equals(column,MUTATE_INFO)) {
              continue;
            }
            MutationType mt=MutationType.valueOf(RandomUtils.nextInt(MutationType.values().length));
            long columnHash=Arrays.hashCode(column);
            long hashCode=cfHash + columnHash;
            byte[] hashCodeBytes=Bytes.toBytes(hashCode);
            byte[] checkedValue=HConstants.EMPTY_BYTE_ARRAY;
            if (hashCode % 2 == 0) {
              Cell kv=result.getColumnLatest(cf,column);
              checkedValue=kv != null ? CellUtil.cloneValue(kv) : null;
              Preconditions.checkNotNull(checkedValue,"Column value to be checked should not be null");
            }
            buf.setLength(0);
            buf.append("#").append(Bytes.toString(column)).append(":");
            ++columnCount;
switch (mt) {
case PUT:
              Put put=new Put(rowKey);
            put.add(cf,column,hashCodeBytes);
          mutate(table,put,rowKeyBase,rowKey,cf,column,checkedValue);
        buf.append(MutationType.PUT.getNumber());
      break;
case DELETE:
    Delete delete=new Delete(rowKey);
  delete.deleteColumns(cf,column);
mutate(table,delete,rowKeyBase,rowKey,cf,column,checkedValue);
buf.append(MutationType.DELETE.getNumber());
break;
default :
buf.append(MutationType.APPEND.getNumber());
app.add(cf,column,hashCodeBytes);
}
app.add(cf,MUTATE_INFO,Bytes.toBytes(buf.toString()));
if (!isBatchUpdate) {
mutate(table,app,rowKeyBase);
numCols.addAndGet(1);
app=new Append(rowKey);
}
}
}
if (isBatchUpdate) {
if (verbose) {
LOG.debug("Preparing increment and append for key = [" + rowKey + "], "+ columnCount+ " columns");
}
mutate(table,inc,rowKeyBase);
mutate(table,app,rowKeyBase);
numCols.addAndGet(columnCount);
}
}
if (trackWroteKeys) {
wroteKeys.add(rowKeyBase);
}
}
}
  finally {
try {
table.close();
}
 catch (IOException e) {
LOG.error("Error closing table",e);
}
numThreadsWorking.decrementAndGet();
}
}
