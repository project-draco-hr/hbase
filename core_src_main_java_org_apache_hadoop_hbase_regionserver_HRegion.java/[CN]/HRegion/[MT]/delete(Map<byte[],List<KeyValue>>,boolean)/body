{
  long now=System.currentTimeMillis();
  byte[] byteNow=Bytes.toBytes(now);
  boolean flush=false;
  this.updatesLock.readLock().lock();
  try {
    for (    Map.Entry<byte[],List<KeyValue>> e : familyMap.entrySet()) {
      byte[] family=e.getKey();
      List<KeyValue> kvs=e.getValue();
      Map<byte[],Integer> kvCount=new TreeMap<byte[],Integer>(Bytes.BYTES_COMPARATOR);
      Store store=getStore(family);
      for (      KeyValue kv : kvs) {
        if (kv.isLatestTimestamp() && kv.isDeleteType()) {
          byte[] qual=kv.getQualifier();
          if (qual == null)           qual=HConstants.EMPTY_BYTE_ARRAY;
          Integer count=kvCount.get(qual);
          if (count == null) {
            kvCount.put(qual,new Integer(1));
          }
 else {
            kvCount.put(qual,new Integer(count + 1));
          }
          count=kvCount.get(qual);
          List<KeyValue> result=new ArrayList<KeyValue>(1);
          Get g=new Get(kv.getRow());
          g.setMaxVersions(count);
          NavigableSet<byte[]> qualifiers=new TreeSet<byte[]>(Bytes.BYTES_COMPARATOR);
          qualifiers.add(qual);
          get(store,g,qualifiers,result);
          if (result.size() < count) {
            kv.updateLatestStamp(byteNow);
            continue;
          }
          if (result.size() > count) {
            throw new RuntimeException("Unexpected size: " + result.size());
          }
          KeyValue getkv=result.get(count - 1);
          Bytes.putBytes(kv.getBuffer(),kv.getTimestampOffset(),getkv.getBuffer(),getkv.getTimestampOffset(),Bytes.SIZEOF_LONG);
        }
 else {
          kv.updateLatestStamp(byteNow);
        }
      }
    }
    if (writeToWAL) {
      WALEdit walEdit=new WALEdit();
      for (      Map.Entry<byte[],List<KeyValue>> e : familyMap.entrySet()) {
        List<KeyValue> kvs=e.getValue();
        for (        KeyValue kv : kvs) {
          walEdit.add(kv);
        }
      }
      if (!walEdit.isEmpty()) {
        this.log.append(regionInfo,regionInfo.getTableDesc().getName(),walEdit,now);
      }
    }
    long size=0;
    for (    Map.Entry<byte[],List<KeyValue>> e : familyMap.entrySet()) {
      byte[] family=e.getKey();
      List<KeyValue> kvs=e.getValue();
      Store store=getStore(family);
      for (      KeyValue kv : kvs) {
        size=this.memstoreSize.addAndGet(store.delete(kv));
      }
    }
    flush=isFlushSize(size);
  }
  finally {
    this.updatesLock.readLock().unlock();
  }
  if (flush) {
    requestFlush();
  }
}
