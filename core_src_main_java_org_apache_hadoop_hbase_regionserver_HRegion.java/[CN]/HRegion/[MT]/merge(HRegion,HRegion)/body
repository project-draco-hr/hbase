{
  if (!a.getRegionInfo().getTableDesc().getNameAsString().equals(b.getRegionInfo().getTableDesc().getNameAsString())) {
    throw new IOException("Regions do not belong to the same table");
  }
  FileSystem fs=a.getFilesystem();
  a.flushcache();
  b.flushcache();
  a.compactStores(true);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Files for region: " + a);
    listPaths(fs,a.getRegionDir());
  }
  b.compactStores(true);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Files for region: " + b);
    listPaths(fs,b.getRegionDir());
  }
  Configuration conf=a.getConf();
  HTableDescriptor tabledesc=a.getTableDesc();
  HLog log=a.getLog();
  Path basedir=a.getBaseDir();
  final byte[] startKey=a.comparator.matchingRows(a.getStartKey(),0,a.getStartKey().length,EMPTY_BYTE_ARRAY,0,EMPTY_BYTE_ARRAY.length) || b.comparator.matchingRows(b.getStartKey(),0,b.getStartKey().length,EMPTY_BYTE_ARRAY,0,EMPTY_BYTE_ARRAY.length) ? EMPTY_BYTE_ARRAY : a.comparator.compareRows(a.getStartKey(),0,a.getStartKey().length,b.getStartKey(),0,b.getStartKey().length) <= 0 ? a.getStartKey() : b.getStartKey();
  final byte[] endKey=a.comparator.matchingRows(a.getEndKey(),0,a.getEndKey().length,EMPTY_BYTE_ARRAY,0,EMPTY_BYTE_ARRAY.length) || a.comparator.matchingRows(b.getEndKey(),0,b.getEndKey().length,EMPTY_BYTE_ARRAY,0,EMPTY_BYTE_ARRAY.length) ? EMPTY_BYTE_ARRAY : a.comparator.compareRows(a.getEndKey(),0,a.getEndKey().length,b.getEndKey(),0,b.getEndKey().length) <= 0 ? b.getEndKey() : a.getEndKey();
  HRegionInfo newRegionInfo=new HRegionInfo(tabledesc,startKey,endKey);
  LOG.info("Creating new region " + newRegionInfo.toString());
  int encodedName=newRegionInfo.getEncodedName();
  Path newRegionDir=HRegion.getRegionDir(a.getBaseDir(),encodedName);
  if (fs.exists(newRegionDir)) {
    throw new IOException("Cannot merge; target file collision at " + newRegionDir);
  }
  fs.mkdirs(newRegionDir);
  LOG.info("starting merge of regions: " + a + " and "+ b+ " into new region "+ newRegionInfo.toString()+ " with start key <"+ Bytes.toString(startKey)+ "> and end key <"+ Bytes.toString(endKey)+ ">");
  Map<byte[],List<StoreFile>> byFamily=new TreeMap<byte[],List<StoreFile>>(Bytes.BYTES_COMPARATOR);
  byFamily=filesByFamily(byFamily,a.close());
  byFamily=filesByFamily(byFamily,b.close());
  for (  Map.Entry<byte[],List<StoreFile>> es : byFamily.entrySet()) {
    byte[] colFamily=es.getKey();
    makeColumnFamilyDirs(fs,basedir,newRegionInfo,colFamily);
    List<StoreFile> srcFiles=es.getValue();
    if (srcFiles.size() == 2) {
      long seqA=srcFiles.get(0).getMaxSequenceId();
      long seqB=srcFiles.get(1).getMaxSequenceId();
      if (seqA == seqB) {
        throw new IOException("Files have same sequenceid: " + seqA);
      }
    }
    for (    StoreFile hsf : srcFiles) {
      StoreFile.rename(fs,hsf.getPath(),StoreFile.getUniqueFile(fs,Store.getStoreHomedir(basedir,newRegionInfo.getEncodedName(),colFamily)));
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Files for new region");
    listPaths(fs,newRegionDir);
  }
  HRegion dstRegion=HRegion.newHRegion(basedir,log,fs,conf,newRegionInfo,null);
  dstRegion.initialize(null,null);
  dstRegion.compactStores();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Files for new region");
    listPaths(fs,dstRegion.getRegionDir());
  }
  deleteRegion(fs,a.getRegionDir());
  deleteRegion(fs,b.getRegionDir());
  LOG.info("merge completed. New region is " + dstRegion);
  return dstRegion;
}
