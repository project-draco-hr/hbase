{
  EventType et=rt.getEventType();
  final ServerName sn=rt.getServerName();
  final byte[] regionName=rt.getRegionName();
  final String encodedName=HRegionInfo.encodeRegionName(regionName);
  final String prettyPrintedRegionName=HRegionInfo.prettyPrint(encodedName);
  LOG.info("Processing " + prettyPrintedRegionName + " in state: "+ et);
  if (regionStates.isRegionInTransition(encodedName)) {
    LOG.info("Processed region " + prettyPrintedRegionName + " in state: "+ et+ ", does nothing since the region is already in transition "+ regionStates.getRegionTransitionState(encodedName));
    return true;
  }
  if (!serverManager.isServerOnline(sn)) {
    LOG.debug("RIT " + encodedName + " in state="+ rt.getEventType()+ " was on deadserver; forcing offline");
    if (regionStates.isRegionOnline(regionInfo)) {
      regionStates.regionOffline(regionInfo);
      sendRegionClosedNotification(regionInfo);
    }
    regionStates.updateRegionState(regionInfo,State.OFFLINE,sn);
    if (regionInfo.isMetaRegion()) {
      MetaRegionTracker.setMetaLocation(watcher,sn);
    }
 else {
      regionStates.setLastRegionServerOfRegion(sn,encodedName);
      if (!serverManager.isServerDead(sn)) {
        serverManager.expireServer(sn);
      }
    }
    return false;
  }
switch (et) {
case M_ZK_REGION_CLOSING:
    final RegionState rsClosing=regionStates.updateRegionState(rt,State.CLOSING);
  this.executorService.submit(new EventHandler(server,EventType.M_MASTER_RECOVERY){
    @Override public void process() throws IOException {
      ReentrantLock lock=locker.acquireLock(regionInfo.getEncodedName());
      try {
        final int expectedVersion=((ZkOpenRegionCoordination.ZkOpenRegionDetails)ord).getVersion();
        unassign(regionInfo,rsClosing,expectedVersion,null,useZKForAssignment,null);
        if (regionStates.isRegionOffline(regionInfo)) {
          assign(regionInfo,true);
        }
      }
  finally {
        lock.unlock();
      }
    }
  }
);
break;
case RS_ZK_REGION_CLOSED:
case RS_ZK_REGION_FAILED_OPEN:
regionStates.updateRegionState(regionInfo,State.CLOSED,sn);
invokeAssign(regionInfo);
break;
case M_ZK_REGION_OFFLINE:
regionStates.updateRegionState(rt,State.PENDING_OPEN);
final RegionState rsOffline=regionStates.getRegionState(regionInfo);
this.executorService.submit(new EventHandler(server,EventType.M_MASTER_RECOVERY){
@Override public void process() throws IOException {
ReentrantLock lock=locker.acquireLock(regionInfo.getEncodedName());
try {
RegionPlan plan=new RegionPlan(regionInfo,null,sn);
addPlan(encodedName,plan);
assign(rsOffline,false,false);
}
  finally {
lock.unlock();
}
}
}
);
break;
case RS_ZK_REGION_OPENING:
regionStates.updateRegionState(rt,State.OPENING);
break;
case RS_ZK_REGION_OPENED:
regionStates.updateRegionState(rt,State.OPEN);
new OpenedRegionHandler(server,this,regionInfo,coordination,ord).process();
break;
case RS_ZK_REQUEST_REGION_SPLIT:
case RS_ZK_REGION_SPLITTING:
case RS_ZK_REGION_SPLIT:
regionStates.regionOnline(regionInfo,sn);
regionStates.updateRegionState(rt,State.SPLITTING);
if (!handleRegionSplitting(rt,encodedName,prettyPrintedRegionName,sn)) {
deleteSplittingNode(encodedName,sn);
}
break;
case RS_ZK_REQUEST_REGION_MERGE:
case RS_ZK_REGION_MERGING:
case RS_ZK_REGION_MERGED:
if (!handleRegionMerging(rt,encodedName,prettyPrintedRegionName,sn)) {
deleteMergingNode(encodedName,sn);
}
break;
default :
throw new IllegalStateException("Received region in state:" + et + " is not valid.");
}
LOG.info("Processed region " + prettyPrintedRegionName + " in state "+ et+ ", on "+ (serverManager.isServerOnline(sn) ? "" : "dead ")+ "server: "+ sn);
return true;
}
