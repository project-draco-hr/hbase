{
  LOG.debug("Starting unassign of " + region.getRegionNameAsString() + " (offlining)");
  String encodedName=region.getEncodedName();
  int versionOfClosingNode=-1;
  ReentrantLock lock=locker.acquireLock(encodedName);
  RegionState state=regionStates.getRegionTransitionState(encodedName);
  try {
    if (state == null) {
      try {
        state=regionStates.getRegionState(region);
        if (state == null || state.getServerName() == null) {
          regionOffline(region);
          return;
        }
        versionOfClosingNode=ZKAssign.createNodeClosing(watcher,region,state.getServerName());
        if (versionOfClosingNode == -1) {
          LOG.debug("Attempting to unassign " + region.getRegionNameAsString() + " but ZK closing node "+ "can't be created.");
          return;
        }
      }
 catch (      KeeperException e) {
        if (e instanceof NodeExistsException) {
          NodeExistsException nee=(NodeExistsException)e;
          String path=nee.getPath();
          try {
            if (isSplitOrSplittingOrMergedOrMerging(path)) {
              LOG.debug(path + " is SPLIT or SPLITTING or MERGED or MERGING; " + "skipping unassign because region no longer exists -- its split or merge");
              return;
            }
          }
 catch (          KeeperException.NoNodeException ke) {
            LOG.warn("Failed getData on SPLITTING/SPLIT at " + path + "; presuming split and that the region to unassign, "+ encodedName+ ", no longer exists -- confirm",ke);
            return;
          }
catch (          KeeperException ke) {
            LOG.error("Unexpected zk state",ke);
          }
catch (          DeserializationException de) {
            LOG.error("Failed parse",de);
          }
        }
        server.abort("Unexpected ZK exception creating node CLOSING",e);
        return;
      }
      state=regionStates.updateRegionState(region,RegionState.State.PENDING_CLOSE);
    }
 else     if (state.isFailedOpen()) {
      regionOffline(region);
      return;
    }
 else     if (force && (state.isPendingClose() || state.isClosing() || state.isFailedClose())) {
      LOG.debug("Attempting to unassign " + region.getRegionNameAsString() + " which is already "+ state.getState()+ " but forcing to send a CLOSE RPC again ");
      if (state.isFailedClose()) {
        state=regionStates.updateRegionState(region,RegionState.State.PENDING_CLOSE);
      }
      state.updateTimestampToNow();
    }
 else {
      LOG.debug("Attempting to unassign " + region.getRegionNameAsString() + " but it is "+ "already in transition ("+ state.getState()+ ", force="+ force+ ")");
      return;
    }
    unassign(region,state,versionOfClosingNode,dest,true,null);
  }
  finally {
    lock.unlock();
  }
}
