{
  EventType et=rt.getEventType();
  ServerName sn=rt.getServerName();
  String encodedRegionName=regionInfo.getEncodedName();
  LOG.info("Processing region " + regionInfo.getRegionNameAsString() + " in state "+ et);
  Lock lock=locker.acquireLock(encodedRegionName);
  try {
    if (regionStates.isRegionInTransition(encodedRegionName) || failoverProcessedRegions.containsKey(encodedRegionName)) {
      return;
    }
switch (et) {
case M_ZK_REGION_CLOSING:
      if (isOnDeadServer(regionInfo,deadServers) && !isServerOnline(sn)) {
        forceOffline(regionInfo,rt);
      }
 else {
        regionStates.updateRegionState(rt,RegionState.State.CLOSING);
      }
    failoverProcessedRegions.put(encodedRegionName,regionInfo);
  break;
case RS_ZK_REGION_CLOSED:
case RS_ZK_REGION_FAILED_OPEN:
addToRITandCallClose(regionInfo,RegionState.State.CLOSED,rt);
failoverProcessedRegions.put(encodedRegionName,regionInfo);
break;
case M_ZK_REGION_OFFLINE:
if (isOnDeadServer(regionInfo,deadServers) && (sn == null || !isServerOnline(sn))) {
addToRITandCallClose(regionInfo,RegionState.State.OFFLINE,rt);
}
 else if (sn != null && !isServerOnline(sn)) {
addToRITandCallClose(regionInfo,RegionState.State.OFFLINE,rt);
}
 else {
regionStates.updateRegionState(rt,RegionState.State.PENDING_OPEN);
}
failoverProcessedRegions.put(encodedRegionName,regionInfo);
break;
case RS_ZK_REGION_OPENING:
if (regionInfo.isMetaTable()) {
regionStates.updateRegionState(rt,RegionState.State.OPENING);
processOpeningState(regionInfo);
break;
}
 else if (deadServers.keySet().contains(sn)) {
processOpeningState(regionInfo);
break;
}
regionStates.updateRegionState(rt,RegionState.State.OPENING);
failoverProcessedRegions.put(encodedRegionName,regionInfo);
break;
case RS_ZK_REGION_OPENED:
regionStates.updateRegionState(rt,RegionState.State.OPEN);
if (sn == null) {
LOG.warn("Region in transition " + regionInfo.getEncodedName() + " references a null server; letting RIT timeout so will be "+ "assigned elsewhere");
}
 else if (!serverManager.isServerOnline(sn) && (isOnDeadServer(regionInfo,deadServers) || regionInfo.isMetaRegion() || regionInfo.isRootRegion())) {
forceOffline(regionInfo,rt);
}
 else {
new OpenedRegionHandler(master,this,regionInfo,sn,expectedVersion).process();
}
failoverProcessedRegions.put(encodedRegionName,regionInfo);
break;
case RS_ZK_REGION_SPLITTING:
LOG.debug("Processed region in state : " + et);
break;
case RS_ZK_REGION_SPLIT:
LOG.debug("Processed region in state : " + et);
break;
default :
throw new IllegalStateException("Received region in state :" + et + " is not valid");
}
}
  finally {
lock.unlock();
}
}
