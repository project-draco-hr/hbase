{
  if (rt == null) {
    LOG.warn("Unexpected NULL input for RegionTransition rt");
    return;
  }
  final ServerName sn=rt.getServerName();
  if (sn.equals(HBCK_CODE_SERVERNAME)) {
    handleHBCK(rt);
    return;
  }
  final long createTime=rt.getCreateTime();
  final byte[] regionName=rt.getRegionName();
  String encodedName=HRegionInfo.encodeRegionName(regionName);
  String prettyPrintedRegionName=HRegionInfo.prettyPrint(encodedName);
  if (!serverManager.isServerOnline(sn) && !ignoreStatesRSOffline.contains(rt.getEventType())) {
    LOG.warn("Attempted to handle region transition for server but " + "it is not online: " + prettyPrintedRegionName + ", "+ rt);
    return;
  }
  RegionState regionState=regionStates.getRegionState(encodedName);
  long startTime=System.currentTimeMillis();
  if (LOG.isDebugEnabled()) {
    boolean lateEvent=createTime < (startTime - 15000);
    LOG.debug("Handling " + rt.getEventType() + ", server="+ sn+ ", region="+ (prettyPrintedRegionName == null ? "null" : prettyPrintedRegionName)+ (lateEvent ? ", which is more than 15 seconds late" : "")+ ", current_state="+ regionState);
  }
  if (rt.getEventType() == EventType.M_ZK_REGION_OFFLINE) {
    return;
  }
  Lock lock=locker.acquireLock(encodedName);
  try {
    RegionState latestState=regionStates.getRegionState(encodedName);
    if ((regionState == null && latestState != null) || (regionState != null && latestState == null) || (regionState != null && latestState != null && latestState.getState() != regionState.getState())) {
      LOG.warn("Region state changed from " + regionState + " to "+ latestState+ ", while acquiring lock");
    }
    long waitedTime=System.currentTimeMillis() - startTime;
    if (waitedTime > 5000) {
      LOG.warn("Took " + waitedTime + "ms to acquire the lock");
    }
    regionState=latestState;
switch (rt.getEventType()) {
case RS_ZK_REQUEST_REGION_SPLIT:
case RS_ZK_REGION_SPLITTING:
case RS_ZK_REGION_SPLIT:
      if (!handleRegionSplitting(rt,encodedName,prettyPrintedRegionName,sn)) {
        deleteSplittingNode(encodedName,sn);
      }
    break;
case RS_ZK_REQUEST_REGION_MERGE:
case RS_ZK_REGION_MERGING:
case RS_ZK_REGION_MERGED:
  if (!handleRegionMerging(rt,encodedName,prettyPrintedRegionName,sn)) {
    deleteMergingNode(encodedName,sn);
  }
break;
case M_ZK_REGION_CLOSING:
if (regionState == null || !regionState.isPendingCloseOrClosingOnServer(sn)) {
LOG.warn("Received CLOSING for " + prettyPrintedRegionName + " from "+ sn+ " but the region isn't PENDING_CLOSE/CLOSING here: "+ regionStates.getRegionState(encodedName));
return;
}
regionStates.updateRegionState(rt,State.CLOSING);
break;
case RS_ZK_REGION_CLOSED:
if (regionState == null || !regionState.isPendingCloseOrClosingOnServer(sn)) {
LOG.warn("Received CLOSED for " + prettyPrintedRegionName + " from "+ sn+ " but the region isn't PENDING_CLOSE/CLOSING here: "+ regionStates.getRegionState(encodedName));
return;
}
new ClosedRegionHandler(server,this,regionState.getRegion()).process();
updateClosedRegionHandlerTracker(regionState.getRegion());
break;
case RS_ZK_REGION_FAILED_OPEN:
if (regionState == null || !regionState.isPendingOpenOrOpeningOnServer(sn)) {
LOG.warn("Received FAILED_OPEN for " + prettyPrintedRegionName + " from "+ sn+ " but the region isn't PENDING_OPEN/OPENING here: "+ regionStates.getRegionState(encodedName));
return;
}
AtomicInteger failedOpenCount=failedOpenTracker.get(encodedName);
if (failedOpenCount == null) {
failedOpenCount=new AtomicInteger();
failedOpenTracker.put(encodedName,failedOpenCount);
}
if (failedOpenCount.incrementAndGet() >= maximumAttempts) {
regionStates.updateRegionState(rt,State.FAILED_OPEN);
failedOpenTracker.remove(encodedName);
}
 else {
regionState=regionStates.updateRegionState(rt,State.CLOSED);
if (regionState != null) {
try {
getRegionPlan(regionState.getRegion(),sn,true);
new ClosedRegionHandler(server,this,regionState.getRegion()).process();
}
 catch (HBaseIOException e) {
LOG.warn("Failed to get region plan",e);
}
}
}
break;
case RS_ZK_REGION_OPENING:
if (regionState == null || !regionState.isPendingOpenOrOpeningOnServer(sn)) {
LOG.warn("Received OPENING for " + prettyPrintedRegionName + " from "+ sn+ " but the region isn't PENDING_OPEN/OPENING here: "+ regionStates.getRegionState(encodedName));
return;
}
regionStates.updateRegionState(rt,State.OPENING);
break;
case RS_ZK_REGION_OPENED:
if (regionState == null || !regionState.isPendingOpenOrOpeningOnServer(sn)) {
LOG.warn("Received OPENED for " + prettyPrintedRegionName + " from "+ sn+ " but the region isn't PENDING_OPEN/OPENING here: "+ regionStates.getRegionState(encodedName));
if (regionState != null) {
unassign(regionState.getRegion(),null,-1,null,false,sn);
}
return;
}
regionState=regionStates.updateRegionState(rt,State.OPEN);
if (regionState != null) {
failedOpenTracker.remove(encodedName);
new OpenedRegionHandler(server,this,regionState.getRegion(),sn,expectedVersion).process();
updateOpenedRegionHandlerTracker(regionState.getRegion());
}
break;
default :
throw new IllegalStateException("Received event is not valid.");
}
}
  finally {
lock.unlock();
}
}
