{
  HRegionInfo regionInfo=regionState.getRegion();
  LOG.info("Regions in transition timed out:  " + regionState);
switch (regionState.getState()) {
case CLOSED:
    LOG.info("Region " + regionInfo.getEncodedName() + " has been CLOSED for too long, waiting on queued "+ "ClosedRegionHandler to run or server shutdown");
  regionState.updateTimestampToNow();
break;
case OFFLINE:
LOG.info("Region has been OFFLINE for too long, " + "reassigning " + regionInfo.getRegionNameAsString() + " to a random server");
invokeAssign(regionInfo);
break;
case PENDING_OPEN:
LOG.info("Region has been PENDING_OPEN for too " + "long, reassigning region=" + regionInfo.getRegionNameAsString());
invokeAssign(regionInfo);
break;
case OPENING:
processOpeningState(regionInfo);
break;
case OPEN:
LOG.error("Region has been OPEN for too long, " + "we don't know where region was opened so can't do anything");
synchronized (regionState) {
regionState.updateTimestampToNow();
}
break;
case PENDING_CLOSE:
LOG.info("Region has been PENDING_CLOSE for too " + "long, running forced unassign again on region=" + regionInfo.getRegionNameAsString());
invokeUnassign(regionInfo);
break;
case CLOSING:
LOG.info("Region has been CLOSING for too " + "long, this should eventually complete or the server will " + "expire, send RPC again");
invokeUnassign(regionInfo);
break;
case SPLIT:
case SPLITTING:
break;
default :
throw new IllegalStateException("Received event is not valid.");
}
}
