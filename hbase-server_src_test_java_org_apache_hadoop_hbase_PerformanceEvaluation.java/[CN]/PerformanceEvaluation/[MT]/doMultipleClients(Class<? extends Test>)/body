{
  final List<Thread> threads=new ArrayList<Thread>(this.N);
  final long[] timings=new long[this.N];
  final int perClientRows=R / N;
  for (int i=0; i < this.N; i++) {
    final int index=i;
    Thread t=new Thread("TestClient-" + i){
      @Override public void run(){
        super.run();
        PerformanceEvaluation pe=new PerformanceEvaluation(conf);
        pe.N=N;
        try {
          long elapsedTime=pe.runOneClient(cmd,index * perClientRows,perClientRows,R,flushCommits,writeToWAL,new Status(){
            public void setStatus(            final String msg) throws IOException {
              LOG.info("client-" + getName() + " "+ msg);
            }
          }
);
          timings[index]=elapsedTime;
          LOG.info("Finished " + getName() + " in "+ elapsedTime+ "ms writing "+ perClientRows+ " rows");
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
;
    threads.add(t);
  }
  for (  Thread t : threads) {
    t.start();
  }
  for (  Thread t : threads) {
    while (t.isAlive()) {
      try {
        t.join();
      }
 catch (      InterruptedException e) {
        LOG.debug("Interrupted, continuing" + e.toString());
      }
    }
  }
  final String test=cmd.getSimpleName();
  LOG.info("[" + test + "] Summary of timings (ms): "+ Arrays.toString(timings));
  Arrays.sort(timings);
  long total=0;
  for (int i=0; i < this.N; i++) {
    total+=timings[i];
  }
  LOG.info("[" + test + "]"+ "\tMin: "+ timings[0]+ "ms"+ "\tMax: "+ timings[this.N - 1]+ "ms"+ "\tAvg: "+ (total / this.N)+ "ms");
}
