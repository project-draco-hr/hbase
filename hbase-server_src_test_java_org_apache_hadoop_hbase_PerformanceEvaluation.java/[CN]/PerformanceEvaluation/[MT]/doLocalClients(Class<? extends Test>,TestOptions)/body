{
  Future<Long>[] threads=new Future[opts.numClientThreads];
  long[] timings=new long[opts.numClientThreads];
  ExecutorService pool=Executors.newFixedThreadPool(opts.numClientThreads,new ThreadFactoryBuilder().setNameFormat("TestClient-%s").build());
  for (int i=0; i < threads.length; i++) {
    final int index=i;
    threads[i]=pool.submit(new Callable<Long>(){
      @Override public Long call() throws Exception {
        TestOptions threadOpts=new TestOptions(opts);
        threadOpts.startRow=index * threadOpts.perClientRunRows;
        long elapsedTime=runOneClient(cmd,getConf(),threadOpts,new Status(){
          public void setStatus(          final String msg) throws IOException {
            LOG.info("client-" + Thread.currentThread().getName() + " "+ msg);
          }
        }
);
        LOG.info("Finished " + Thread.currentThread().getName() + " in "+ elapsedTime+ "ms over "+ threadOpts.perClientRunRows+ " rows");
        return elapsedTime;
      }
    }
);
  }
  pool.shutdown();
  for (int i=0; i < threads.length; i++) {
    try {
      timings[i]=threads[i].get();
    }
 catch (    ExecutionException e) {
      throw new IOException(e.getCause());
    }
  }
  final String test=cmd.getSimpleName();
  LOG.info("[" + test + "] Summary of timings (ms): "+ Arrays.toString(timings));
  Arrays.sort(timings);
  long total=0;
  for (int i=0; i < timings.length; i++) {
    total+=timings[i];
  }
  LOG.info("[" + test + "]"+ "\tMin: "+ timings[0]+ "ms"+ "\tMax: "+ timings[timings.length - 1]+ "ms"+ "\tAvg: "+ (total / timings.length)+ "ms");
}
