{
  if (this.columns.done()) {
    return MatchCode.DONE;
  }
  if (this.filter != null && this.filter.filterAllRemaining()) {
    return MatchCode.DONE;
  }
  byte[] bytes=kv.getBuffer();
  int offset=kv.getOffset();
  int keyLength=Bytes.toInt(bytes,offset);
  offset+=KeyValue.ROW_OFFSET;
  short rowLength=Bytes.toShort(bytes,offset);
  offset+=Bytes.SIZEOF_SHORT;
  int ret=this.rowComparator.compareRows(row,0,row.length,bytes,offset,rowLength);
  if (ret <= -1) {
    return MatchCode.NEXT;
  }
 else   if (ret >= 1) {
    return MatchCode.SKIP;
  }
  offset+=rowLength;
  byte familyLength=bytes[offset];
  offset+=Bytes.SIZEOF_BYTE + familyLength;
  int columnLength=keyLength + KeyValue.ROW_OFFSET - (offset - kv.getOffset()) - KeyValue.TIMESTAMP_TYPE_SIZE;
  int columnOffset=offset;
  offset+=columnLength;
  long timestamp=Bytes.toLong(bytes,offset);
  if (isExpired(timestamp)) {
    return MatchCode.NEXT;
  }
  offset+=Bytes.SIZEOF_LONG;
  byte type=bytes[offset];
  if (isDelete(type)) {
    if (tr.withinOrAfterTimeRange(timestamp)) {
      this.deletes.add(bytes,columnOffset,columnLength,timestamp,type);
    }
    return MatchCode.SKIP;
  }
  if (!tr.withinTimeRange(timestamp)) {
    return MatchCode.SKIP;
  }
  if (!deletes.isEmpty() && deletes.isDeleted(bytes,columnOffset,columnLength,timestamp)) {
    return MatchCode.SKIP;
  }
  MatchCode mc=columns.checkColumn(bytes,columnOffset,columnLength);
  if (mc == MatchCode.INCLUDE && this.filter != null) {
switch (this.filter.filterKeyValue(kv)) {
case INCLUDE:
      return MatchCode.INCLUDE;
case SKIP:
    return MatchCode.SKIP;
default :
  return MatchCode.DONE;
}
}
return mc;
}
