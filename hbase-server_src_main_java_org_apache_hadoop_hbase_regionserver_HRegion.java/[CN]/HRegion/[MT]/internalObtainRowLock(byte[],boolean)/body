{
  checkRow(row,"row lock");
  startRegionOperation();
  try {
    HashedBytes rowKey=new HashedBytes(row);
    CountDownLatch rowLatch=new CountDownLatch(1);
    while (true) {
      CountDownLatch existingLatch=lockedRows.putIfAbsent(rowKey,rowLatch);
      if (existingLatch == null) {
        break;
      }
 else {
        if (!waitForLock) {
          return null;
        }
        try {
          if (!existingLatch.await(this.rowLockWaitDuration,TimeUnit.MILLISECONDS)) {
            throw new IOException("Timed out on getting lock for row=" + Bytes.toStringBinary(row));
          }
        }
 catch (        InterruptedException ie) {
        }
      }
    }
    while (true) {
      Integer lockId=lockIdGenerator.incrementAndGet();
      HashedBytes existingRowKey=lockIds.putIfAbsent(lockId,rowKey);
      if (existingRowKey == null) {
        return lockId;
      }
 else {
        lockIdGenerator.set(rand.nextInt());
      }
    }
  }
  finally {
    closeRegionOperation();
  }
}
