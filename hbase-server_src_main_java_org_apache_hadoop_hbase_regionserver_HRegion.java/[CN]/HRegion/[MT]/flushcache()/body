{
  if (this.closing.get()) {
    LOG.debug("Skipping flush on " + this + " because closing");
    return false;
  }
  MonitoredTask status=TaskMonitor.get().createStatus("Flushing " + this);
  status.setStatus("Acquiring readlock on region");
  lock.readLock().lock();
  try {
    if (this.closed.get()) {
      LOG.debug("Skipping flush on " + this + " because closed");
      status.abort("Skipped: closed");
      return false;
    }
    if (coprocessorHost != null) {
      status.setStatus("Running coprocessor pre-flush hooks");
      coprocessorHost.preFlush();
    }
    if (numPutsWithoutWAL.get() > 0) {
      numPutsWithoutWAL.set(0);
      dataInMemoryWithoutWAL.set(0);
    }
synchronized (writestate) {
      if (!writestate.flushing && writestate.writesEnabled) {
        this.writestate.flushing=true;
      }
 else {
        if (LOG.isDebugEnabled()) {
          LOG.debug("NOT flushing memstore for region " + this + ", flushing="+ writestate.flushing+ ", writesEnabled="+ writestate.writesEnabled);
        }
        status.abort("Not flushing since " + (writestate.flushing ? "already flushing" : "writes not enabled"));
        return false;
      }
    }
    try {
      boolean result=internalFlushcache(status);
      if (coprocessorHost != null) {
        status.setStatus("Running post-flush coprocessor hooks");
        coprocessorHost.postFlush();
      }
      status.markComplete("Flush successful");
      return result;
    }
  finally {
synchronized (writestate) {
        writestate.flushing=false;
        this.writestate.flushRequested=false;
        writestate.notifyAll();
      }
    }
  }
  finally {
    lock.readLock().unlock();
    status.cleanup();
  }
}
