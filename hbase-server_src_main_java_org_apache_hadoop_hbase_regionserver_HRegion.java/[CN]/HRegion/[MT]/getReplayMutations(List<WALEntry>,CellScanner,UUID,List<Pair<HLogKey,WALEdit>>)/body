{
  List<Pair<MutationType,Mutation>> mutations=new ArrayList<Pair<MutationType,Mutation>>();
  List<Pair<MutationType,Mutation>> tmpEditMutations=new ArrayList<Pair<MutationType,Mutation>>();
  for (  WALEntry entry : entries) {
    HLogKey logKey=null;
    WALEdit val=null;
    Cell previousCell=null;
    Mutation m=null;
    tmpEditMutations.clear();
    int count=entry.getAssociatedCellCount();
    if (coprocessorHost != null) {
      val=new WALEdit();
    }
    for (int i=0; i < count; i++) {
      if (!cells.advance()) {
        throw new ArrayIndexOutOfBoundsException("Expected=" + count + ", index="+ i);
      }
      Cell cell=cells.current();
      if (val != null)       val.add(KeyValueUtil.ensureKeyValue(cell));
      boolean isNewRowOrType=previousCell == null || previousCell.getTypeByte() != cell.getTypeByte() || !CellUtil.matchingRow(previousCell,cell);
      if (isNewRowOrType) {
        if (CellUtil.isDelete(cell)) {
          m=new Delete(cell.getRowArray(),cell.getRowOffset(),cell.getRowLength());
          tmpEditMutations.add(new Pair<MutationType,Mutation>(MutationType.DELETE,m));
        }
 else {
          m=new Put(cell.getRowArray(),cell.getRowOffset(),cell.getRowLength());
          tmpEditMutations.add(new Pair<MutationType,Mutation>(MutationType.PUT,m));
        }
      }
      if (CellUtil.isDelete(cell)) {
        ((Delete)m).addDeleteMarker(KeyValueUtil.ensureKeyValue(cell));
      }
 else {
        ((Put)m).add(KeyValueUtil.ensureKeyValue(cell));
      }
      previousCell=cell;
    }
    if (coprocessorHost != null) {
      WALKey walKey=entry.getKey();
      logKey=new HLogKey(walKey.getEncodedRegionName().toByteArray(),TableName.valueOf(walKey.getTableName().toByteArray()),walKey.getLogSequenceNumber(),walKey.getWriteTime(),clusterId);
      if (coprocessorHost.preWALRestore(this.getRegionInfo(),logKey,val)) {
        continue;
      }
      logEntries.add(new Pair<HLogKey,WALEdit>(logKey,val));
    }
    mutations.addAll(tmpEditMutations);
  }
  return mutations;
}
