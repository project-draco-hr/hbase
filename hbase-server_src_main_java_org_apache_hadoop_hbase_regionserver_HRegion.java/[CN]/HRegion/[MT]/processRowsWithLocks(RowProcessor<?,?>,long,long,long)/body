{
  for (  byte[] row : processor.getRowsToLock()) {
    checkRow(row,"processRowsWithLocks");
  }
  if (!processor.readOnly()) {
    checkReadOnly();
  }
  checkResources();
  startRegionOperation();
  WALEdit walEdit=new WALEdit();
  try {
    processor.preProcess(this,walEdit);
  }
 catch (  IOException e) {
    closeRegionOperation();
    throw e;
  }
  if (processor.readOnly()) {
    try {
      long now=EnvironmentEdgeManager.currentTimeMillis();
      doProcessRowWithTimeout(processor,now,this,null,null,timeout);
      processor.postProcess(this,walEdit,true);
    }
 catch (    IOException e) {
      throw e;
    }
 finally {
      closeRegionOperation();
    }
    return;
  }
  MultiVersionConsistencyControl.WriteEntry writeEntry=null;
  boolean locked;
  boolean walSyncSuccessful=false;
  List<RowLock> acquiredRowLocks;
  long addedSize=0;
  List<Mutation> mutations=new ArrayList<Mutation>();
  List<KeyValue> memstoreCells=new ArrayList<KeyValue>();
  Collection<byte[]> rowsToLock=processor.getRowsToLock();
  long mvccNum=0;
  HLogKey walKey=null;
  try {
    acquiredRowLocks=new ArrayList<RowLock>(rowsToLock.size());
    for (    byte[] row : rowsToLock) {
      acquiredRowLocks.add(getRowLock(row));
    }
    lock(this.updatesLock.readLock(),acquiredRowLocks.size() == 0 ? 1 : acquiredRowLocks.size());
    locked=true;
    mvccNum=MultiVersionConsistencyControl.getPreAssignedWriteNumber(this.sequenceId);
    long now=EnvironmentEdgeManager.currentTimeMillis();
    try {
      doProcessRowWithTimeout(processor,now,this,mutations,walEdit,timeout);
      if (!mutations.isEmpty()) {
        writeEntry=mvcc.beginMemstoreInsertWithSeqNum(mvccNum);
        processor.preBatchMutate(this,walEdit);
        for (        Mutation m : mutations) {
          for (CellScanner cellScanner=m.cellScanner(); cellScanner.advance(); ) {
            KeyValue kv=KeyValueUtil.ensureKeyValue(cellScanner.current());
            kv.setSequenceId(mvccNum);
            Store store=getStore(kv);
            if (store == null) {
              checkFamily(CellUtil.cloneFamily(kv));
            }
            Pair<Long,Cell> ret=store.add(kv);
            addedSize+=ret.getFirst();
            memstoreCells.add(KeyValueUtil.ensureKeyValue(ret.getSecond()));
          }
        }
        long txid=0;
        if (!walEdit.isEmpty()) {
          walKey=new HLogKey(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),HLog.NO_SEQUENCE_ID,now,processor.getClusterIds(),nonceGroup,nonce);
          txid=this.log.appendNoSync(this.htableDescriptor,this.getRegionInfo(),walKey,walEdit,getSequenceId(),true,memstoreCells);
        }
        if (walKey == null) {
          walKey=this.appendNoSyncNoAppend(this.log,memstoreCells);
        }
        if (locked) {
          this.updatesLock.readLock().unlock();
          locked=false;
        }
        releaseRowLocks(acquiredRowLocks);
        if (txid != 0) {
          syncOrDefer(txid,getEffectiveDurability(processor.useDurability()));
        }
        walSyncSuccessful=true;
        processor.postBatchMutate(this);
      }
    }
  finally {
      if (!mutations.isEmpty() && !walSyncSuccessful) {
        LOG.warn("Wal sync failed. Roll back " + mutations.size() + " memstore keyvalues for row(s):"+ StringUtils.byteToHexString(processor.getRowsToLock().iterator().next())+ "...");
        for (        Mutation m : mutations) {
          for (CellScanner cellScanner=m.cellScanner(); cellScanner.advance(); ) {
            KeyValue kv=KeyValueUtil.ensureKeyValue(cellScanner.current());
            getStore(kv).rollback(kv);
          }
        }
      }
      if (writeEntry != null) {
        mvcc.completeMemstoreInsertWithSeqNum(writeEntry,walKey);
      }
      if (locked) {
        this.updatesLock.readLock().unlock();
      }
      releaseRowLocks(acquiredRowLocks);
    }
    processor.postProcess(this,walEdit,walSyncSuccessful);
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    closeRegionOperation();
    if (!mutations.isEmpty() && isFlushSize(this.addAndGetGlobalMemstoreSize(addedSize))) {
      requestFlush();
    }
  }
}
