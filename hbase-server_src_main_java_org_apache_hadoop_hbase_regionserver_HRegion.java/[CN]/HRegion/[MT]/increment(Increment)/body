{
  byte[] row=increment.getRow();
  checkRow(row,"increment");
  TimeRange tr=increment.getTimeRange();
  boolean flush=false;
  Durability durability=getEffectiveDurability(increment.getDurability());
  boolean writeToWAL=durability != Durability.SKIP_WAL;
  WALEdit walEdits=null;
  List<Cell> allKVs=new ArrayList<Cell>(increment.size());
  Map<Store,List<Cell>> tempMemstore=new HashMap<Store,List<Cell>>();
  long size=0;
  long txid=0;
  checkReadOnly();
  checkResources();
  startRegionOperation(Operation.INCREMENT);
  this.writeRequestsCount.increment();
  WriteEntry w=null;
  try {
    RowLock rowLock=getRowLock(row);
    try {
      lock(this.updatesLock.readLock());
      mvcc.completeMemstoreInsert(mvcc.beginMemstoreInsert());
      w=mvcc.beginMemstoreInsert();
      try {
        long now=EnvironmentEdgeManager.currentTimeMillis();
        for (        Map.Entry<byte[],List<Cell>> family : increment.getFamilyCellMap().entrySet()) {
          Store store=stores.get(family.getKey());
          List<Cell> kvs=new ArrayList<Cell>(family.getValue().size());
          Get get=new Get(row);
          for (          Cell cell : family.getValue()) {
            KeyValue kv=KeyValueUtil.ensureKeyValue(cell);
            get.addColumn(family.getKey(),kv.getQualifier());
          }
          get.setTimeRange(tr.getMin(),tr.getMax());
          List<Cell> results=get(get,false);
          int idx=0;
          for (          Cell kv : family.getValue()) {
            long amount=Bytes.toLong(CellUtil.cloneValue(kv));
            Cell c=null;
            if (idx < results.size() && CellUtil.matchingQualifier(results.get(idx),kv)) {
              c=results.get(idx);
              if (c.getValueLength() == Bytes.SIZEOF_LONG) {
                amount+=Bytes.toLong(c.getValueArray(),c.getValueOffset(),Bytes.SIZEOF_LONG);
              }
 else {
                throw new org.apache.hadoop.hbase.DoNotRetryIOException("Attempted to increment field that isn't 64 bits wide");
              }
              idx++;
            }
            byte[] q=CellUtil.cloneQualifier(kv);
            byte[] val=Bytes.toBytes(amount);
            int oldCellTagsLen=(c == null) ? 0 : c.getTagsLength();
            int incCellTagsLen=kv.getTagsLength();
            KeyValue newKV=new KeyValue(row.length,family.getKey().length,q.length,now,KeyValue.Type.Put,val.length,oldCellTagsLen + incCellTagsLen);
            System.arraycopy(row,0,newKV.getBuffer(),newKV.getRowOffset(),row.length);
            System.arraycopy(family.getKey(),0,newKV.getBuffer(),newKV.getFamilyOffset(),family.getKey().length);
            System.arraycopy(q,0,newKV.getBuffer(),newKV.getQualifierOffset(),q.length);
            System.arraycopy(val,0,newKV.getBuffer(),newKV.getValueOffset(),val.length);
            if (oldCellTagsLen > 0) {
              System.arraycopy(c.getTagsArray(),c.getTagsOffset(),newKV.getBuffer(),newKV.getTagsOffset(),oldCellTagsLen);
            }
            if (incCellTagsLen > 0) {
              System.arraycopy(kv.getTagsArray(),kv.getTagsOffset(),newKV.getBuffer(),newKV.getTagsOffset() + oldCellTagsLen,incCellTagsLen);
            }
            newKV.setMvccVersion(w.getWriteNumber());
            if (coprocessorHost != null) {
              newKV=KeyValueUtil.ensureKeyValue(coprocessorHost.postMutationBeforeWAL(RegionObserver.MutationType.INCREMENT,increment,c,(Cell)newKV));
            }
            kvs.add(newKV);
            if (writeToWAL) {
              if (walEdits == null) {
                walEdits=new WALEdit();
              }
              walEdits.add(newKV);
            }
          }
          tempMemstore.put(store,kvs);
        }
        if (writeToWAL) {
          txid=this.log.appendNoSync(this.getRegionInfo(),this.htableDescriptor.getTableName(),walEdits,new ArrayList<UUID>(),EnvironmentEdgeManager.currentTimeMillis(),this.htableDescriptor);
        }
 else {
          recordMutationWithoutWal(increment.getFamilyCellMap());
        }
        for (        Map.Entry<Store,List<Cell>> entry : tempMemstore.entrySet()) {
          Store store=entry.getKey();
          if (store.getFamily().getMaxVersions() == 1) {
            size+=store.upsert(entry.getValue(),getSmallestReadPoint());
          }
 else {
            for (            Cell cell : entry.getValue()) {
              KeyValue kv=KeyValueUtil.ensureKeyValue(cell);
              size+=store.add(kv);
            }
          }
          allKVs.addAll(entry.getValue());
        }
        size=this.addAndGetGlobalMemstoreSize(size);
        flush=isFlushSize(size);
      }
  finally {
        this.updatesLock.readLock().unlock();
      }
    }
  finally {
      rowLock.release();
    }
    if (writeToWAL) {
      syncOrDefer(txid,durability);
    }
  }
  finally {
    if (w != null) {
      mvcc.completeMemstoreInsert(w);
    }
    closeRegionOperation();
    if (this.metricsRegion != null) {
      this.metricsRegion.updateIncrement();
    }
  }
  if (flush) {
    requestFlush();
  }
  return Result.create(allKVs);
}
