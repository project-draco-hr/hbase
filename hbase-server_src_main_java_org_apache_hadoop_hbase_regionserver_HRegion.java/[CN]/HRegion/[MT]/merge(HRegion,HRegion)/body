{
  if (!a.getRegionInfo().getTableNameAsString().equals(b.getRegionInfo().getTableNameAsString())) {
    throw new IOException("Regions do not belong to the same table");
  }
  FileSystem fs=a.getRegionFileSystem().getFileSystem();
  a.flushcache();
  b.flushcache();
  a.compactStores(true);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Files for region: " + a);
    a.getRegionFileSystem().logFileSystemState(LOG);
  }
  b.compactStores(true);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Files for region: " + b);
    b.getRegionFileSystem().logFileSystemState(LOG);
  }
  RegionMergeTransaction rmt=new RegionMergeTransaction(a,b,true);
  if (!rmt.prepare(null)) {
    throw new IOException("Unable to merge regions " + a + " and "+ b);
  }
  HRegionInfo mergedRegionInfo=rmt.getMergedRegionInfo();
  LOG.info("starting merge of regions: " + a + " and "+ b+ " into new region "+ mergedRegionInfo.getRegionNameAsString()+ " with start key <"+ Bytes.toStringBinary(mergedRegionInfo.getStartKey())+ "> and end key <"+ Bytes.toStringBinary(mergedRegionInfo.getEndKey())+ ">");
  HRegion dstRegion;
  try {
    dstRegion=rmt.execute(null,null);
  }
 catch (  IOException ioe) {
    rmt.rollback(null,null);
    throw new IOException("Failed merging region " + a + " and "+ b+ ", and succssfully rolled back");
  }
  dstRegion.compactStores(true);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Files for new region");
    dstRegion.getRegionFileSystem().logFileSystemState(LOG);
  }
  if (dstRegion.getRegionFileSystem().hasReferences(dstRegion.getTableDesc())) {
    throw new IOException("Merged region " + dstRegion + " still has references after the compaction, is compaction canceled?");
  }
  HFileArchiver.archiveRegion(a.getBaseConf(),fs,a.getRegionInfo());
  HFileArchiver.archiveRegion(b.getBaseConf(),fs,b.getRegionInfo());
  LOG.info("merge completed. New region is " + dstRegion);
  return dstRegion;
}
