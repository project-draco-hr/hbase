{
  byte[] row=increment.getRow();
  checkRow(row,"increment");
  TimeRange tr=increment.getTimeRange();
  boolean flush=false;
  Durability durability=getEffectiveDurability(increment.getDurability());
  boolean writeToWAL=durability != Durability.SKIP_WAL;
  WALEdit walEdits=null;
  List<Cell> allKVs=new ArrayList<Cell>(increment.size());
  Map<Store,List<Cell>> tempMemstore=new HashMap<Store,List<Cell>>();
  long size=0;
  long txid=0;
  checkReadOnly();
  checkResources();
  startRegionOperation(Operation.INCREMENT);
  this.writeRequestsCount.increment();
  RowLock rowLock=null;
  WriteEntry w=null;
  WALKey walKey=null;
  long mvccNum=0;
  List<Cell> memstoreCells=new ArrayList<Cell>();
  boolean doRollBackMemstore=false;
  try {
    rowLock=getRowLock(row);
    try {
      lock(this.updatesLock.readLock());
      try {
        mvcc.waitForPreviousTransactionsComplete();
        if (this.coprocessorHost != null) {
          Result r=this.coprocessorHost.preIncrementAfterRowLock(increment);
          if (r != null) {
            return r;
          }
        }
        mvccNum=MultiVersionConsistencyControl.getPreAssignedWriteNumber(this.sequenceId);
        w=mvcc.beginMemstoreInsertWithSeqNum(mvccNum);
        long now=EnvironmentEdgeManager.currentTime();
        for (        Map.Entry<byte[],List<Cell>> family : increment.getFamilyCellMap().entrySet()) {
          Store store=stores.get(family.getKey());
          List<Cell> kvs=new ArrayList<Cell>(family.getValue().size());
          Collections.sort(family.getValue(),store.getComparator());
          Get get=new Get(row);
          for (          Cell cell : family.getValue()) {
            get.addColumn(family.getKey(),CellUtil.cloneQualifier(cell));
          }
          get.setTimeRange(tr.getMin(),tr.getMax());
          List<Cell> results=get(get,false);
          int idx=0;
          List<Cell> edits=family.getValue();
          for (int i=0; i < edits.size(); i++) {
            Cell cell=edits.get(i);
            long amount=Bytes.toLong(CellUtil.cloneValue(cell));
            boolean noWriteBack=(amount == 0);
            List<Tag> newTags=new ArrayList<Tag>();
            if (cell.getTagsLength() > 0) {
              Iterator<Tag> itr=CellUtil.tagsIterator(cell.getTagsArray(),cell.getTagsOffset(),cell.getTagsLength());
              while (itr.hasNext()) {
                newTags.add(itr.next());
              }
            }
            Cell c=null;
            long ts=now;
            if (idx < results.size() && CellUtil.matchingQualifier(results.get(idx),cell)) {
              c=results.get(idx);
              ts=Math.max(now,c.getTimestamp());
              if (c.getValueLength() == Bytes.SIZEOF_LONG) {
                amount+=Bytes.toLong(c.getValueArray(),c.getValueOffset(),Bytes.SIZEOF_LONG);
              }
 else {
                throw new org.apache.hadoop.hbase.DoNotRetryIOException("Attempted to increment field that isn't 64 bits wide");
              }
              if (c.getTagsLength() > 0) {
                Iterator<Tag> itr=CellUtil.tagsIterator(c.getTagsArray(),c.getTagsOffset(),c.getTagsLength());
                while (itr.hasNext()) {
                  newTags.add(itr.next());
                }
              }
              if (i < (edits.size() - 1) && !CellUtil.matchingQualifier(cell,edits.get(i + 1)))               idx++;
            }
            byte[] q=CellUtil.cloneQualifier(cell);
            byte[] val=Bytes.toBytes(amount);
            if (increment.getTTL() != Long.MAX_VALUE) {
              newTags.add(new Tag(TagType.TTL_TAG_TYPE,Bytes.toBytes(increment.getTTL())));
            }
            Cell newKV=new KeyValue(row,0,row.length,family.getKey(),0,family.getKey().length,q,0,q.length,ts,KeyValue.Type.Put,val,0,val.length,newTags);
            CellUtil.setSequenceId(newKV,mvccNum);
            if (coprocessorHost != null) {
              newKV=coprocessorHost.postMutationBeforeWAL(RegionObserver.MutationType.INCREMENT,increment,c,newKV);
            }
            allKVs.add(newKV);
            if (!noWriteBack) {
              kvs.add(newKV);
              if (writeToWAL) {
                if (walEdits == null) {
                  walEdits=new WALEdit();
                }
                walEdits.add(newKV);
              }
            }
          }
          if (!kvs.isEmpty()) {
            tempMemstore.put(store,kvs);
          }
        }
        if (!tempMemstore.isEmpty()) {
          for (          Map.Entry<Store,List<Cell>> entry : tempMemstore.entrySet()) {
            Store store=entry.getKey();
            if (store.getFamily().getMaxVersions() == 1) {
              size+=store.upsert(entry.getValue(),getSmallestReadPoint());
              memstoreCells.addAll(entry.getValue());
            }
 else {
              for (              Cell cell : entry.getValue()) {
                Pair<Long,Cell> ret=store.add(cell);
                size+=ret.getFirst();
                memstoreCells.add(ret.getSecond());
                doRollBackMemstore=true;
              }
            }
          }
          size=this.addAndGetGlobalMemstoreSize(size);
          flush=isFlushSize(size);
        }
        if (walEdits != null && !walEdits.isEmpty()) {
          if (writeToWAL) {
            walKey=new HLogKey(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),WALKey.NO_SEQUENCE_ID,nonceGroup,nonce);
            txid=this.wal.append(this.htableDescriptor,this.getRegionInfo(),walKey,walEdits,getSequenceId(),true,memstoreCells);
          }
 else {
            recordMutationWithoutWal(increment.getFamilyCellMap());
          }
        }
        if (walKey == null) {
          walKey=this.appendEmptyEdit(this.wal,memstoreCells);
        }
      }
  finally {
        this.updatesLock.readLock().unlock();
      }
    }
  finally {
      rowLock.release();
      rowLock=null;
    }
    if (txid != 0) {
      syncOrDefer(txid,durability);
    }
    doRollBackMemstore=false;
  }
  finally {
    if (rowLock != null) {
      rowLock.release();
    }
    if (doRollBackMemstore) {
      rollbackMemstore(memstoreCells);
    }
    if (w != null) {
      mvcc.completeMemstoreInsertWithSeqNum(w,walKey);
    }
    closeRegionOperation(Operation.INCREMENT);
    if (this.metricsRegion != null) {
      this.metricsRegion.updateIncrement();
    }
  }
  if (flush) {
    requestFlush();
  }
  return increment.isReturnResults() ? Result.create(allKVs) : null;
}
