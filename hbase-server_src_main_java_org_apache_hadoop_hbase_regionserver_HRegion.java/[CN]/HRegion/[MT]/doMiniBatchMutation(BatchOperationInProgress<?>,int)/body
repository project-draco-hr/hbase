{
  boolean isInReplay=batchOp.isInReplay();
  boolean putsCfSetConsistent=true;
  Set<byte[]> putsCfSet=null;
  boolean deletesCfSetConsistent=true;
  Set<byte[]> deletesCfSet=null;
  long currentNonceGroup=HConstants.NO_NONCE, currentNonce=HConstants.NO_NONCE;
  WALEdit walEdit=null;
  MultiVersionConcurrencyControl.WriteEntry writeEntry=null;
  long txid=0;
  boolean doRollBackMemstore=false;
  boolean locked=false;
  List<RowLock> acquiredRowLocks=Lists.newArrayListWithCapacity(batchOp.operations.length);
  Map<byte[],List<Cell>>[] familyMaps=new Map[batchOp.operations.length];
  int firstIndex=batchOp.nextIndexToProcess;
  int lastIndexExclusive=firstIndex;
  boolean success=false;
  int noOfPuts=0, noOfDeletes=0;
  WALKey walKey=null;
  long mvccNum=0;
  try {
    int numReadyToWrite=0;
    long now=EnvironmentEdgeManager.currentTime();
    while (lastIndexExclusive < batchOp.operations.length) {
      Mutation mutation=batchOp.getMutation(lastIndexExclusive);
      boolean isPutMutation=mutation instanceof Put;
      Map<byte[],List<Cell>> familyMap=mutation.getFamilyCellMap();
      familyMaps[lastIndexExclusive]=familyMap;
      if (batchOp.retCodeDetails[lastIndexExclusive].getOperationStatusCode() != OperationStatusCode.NOT_RUN) {
        lastIndexExclusive++;
        continue;
      }
      try {
        if (isPutMutation) {
          if (isInReplay) {
            removeNonExistentColumnFamilyForReplay(familyMap);
          }
 else {
            checkFamilies(familyMap.keySet());
          }
          checkTimestamps(mutation.getFamilyCellMap(),now);
        }
 else {
          prepareDelete((Delete)mutation);
        }
        checkRow(mutation.getRow(),"doMiniBatchMutation");
      }
 catch (      NoSuchColumnFamilyException nscf) {
        LOG.warn("No such column family in batch mutation",nscf);
        batchOp.retCodeDetails[lastIndexExclusive]=new OperationStatus(OperationStatusCode.BAD_FAMILY,nscf.getMessage());
        lastIndexExclusive++;
        continue;
      }
catch (      FailedSanityCheckException fsce) {
        LOG.warn("Batch Mutation did not pass sanity check",fsce);
        batchOp.retCodeDetails[lastIndexExclusive]=new OperationStatus(OperationStatusCode.SANITY_CHECK_FAILURE,fsce.getMessage());
        lastIndexExclusive++;
        continue;
      }
catch (      WrongRegionException we) {
        LOG.warn("Batch mutation had a row that does not belong to this region",we);
        batchOp.retCodeDetails[lastIndexExclusive]=new OperationStatus(OperationStatusCode.SANITY_CHECK_FAILURE,we.getMessage());
        lastIndexExclusive++;
        continue;
      }
      RowLock rowLock=null;
      try {
        rowLock=getRowLock(mutation.getRow(),true);
      }
 catch (      IOException ioe) {
        LOG.warn("Failed getting lock in batch put, row=" + Bytes.toStringBinary(mutation.getRow()),ioe);
      }
      if (rowLock == null) {
        break;
      }
 else {
        acquiredRowLocks.add(rowLock);
      }
      lastIndexExclusive++;
      numReadyToWrite++;
      if (isPutMutation) {
        if (putsCfSet == null) {
          putsCfSet=mutation.getFamilyCellMap().keySet();
        }
 else {
          putsCfSetConsistent=putsCfSetConsistent && mutation.getFamilyCellMap().keySet().equals(putsCfSet);
        }
      }
 else {
        if (deletesCfSet == null) {
          deletesCfSet=mutation.getFamilyCellMap().keySet();
        }
 else {
          deletesCfSetConsistent=deletesCfSetConsistent && mutation.getFamilyCellMap().keySet().equals(deletesCfSet);
        }
      }
    }
    now=EnvironmentEdgeManager.currentTime();
    byte[] byteNow=Bytes.toBytes(now);
    if (numReadyToWrite <= 0)     return 0L;
    for (int i=firstIndex; !isInReplay && i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.NOT_RUN)       continue;
      Mutation mutation=batchOp.getMutation(i);
      if (mutation instanceof Put) {
        updateCellTimestamps(familyMaps[i].values(),byteNow);
        noOfPuts++;
      }
 else {
        prepareDeleteTimestamps(mutation,familyMaps[i],byteNow);
        noOfDeletes++;
      }
      rewriteCellTags(familyMaps[i],mutation);
      for (      List<Cell> cells : familyMaps[i].values()) {
        cellCount+=cells.size();
      }
    }
    walEdit=new WALEdit(cellCount);
    lock(this.updatesLock.readLock(),numReadyToWrite);
    locked=true;
    if (!isInReplay && coprocessorHost != null) {
      MiniBatchOperationInProgress<Mutation> miniBatchOp=new MiniBatchOperationInProgress<Mutation>(batchOp.getMutationsForCoprocs(),batchOp.retCodeDetails,batchOp.walEditsFromCoprocessors,firstIndex,lastIndexExclusive);
      if (coprocessorHost.preBatchMutate(miniBatchOp))       return 0L;
    }
    Durability durability=Durability.USE_DEFAULT;
    for (int i=firstIndex; i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.NOT_RUN) {
        continue;
      }
      Mutation m=batchOp.getMutation(i);
      Durability tmpDur=getEffectiveDurability(m.getDurability());
      if (tmpDur.ordinal() > durability.ordinal()) {
        durability=tmpDur;
      }
      if (tmpDur == Durability.SKIP_WAL) {
        recordMutationWithoutWal(m.getFamilyCellMap());
        continue;
      }
      long nonceGroup=batchOp.getNonceGroup(i), nonce=batchOp.getNonce(i);
      if (nonceGroup != currentNonceGroup || nonce != currentNonce) {
        if (walEdit.size() > 0) {
          assert isInReplay;
          if (!isInReplay) {
            throw new IOException("Multiple nonces per batch and not in replay");
          }
          walKey=new ReplayHLogKey(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),now,m.getClusterIds(),currentNonceGroup,currentNonce,mvcc);
          txid=this.wal.append(this.htableDescriptor,this.getRegionInfo(),walKey,walEdit,true);
          walEdit=new WALEdit(isInReplay);
          walKey=null;
        }
        currentNonceGroup=nonceGroup;
        currentNonce=nonce;
      }
      WALEdit fromCP=batchOp.walEditsFromCoprocessors[i];
      if (fromCP != null) {
        for (        Cell cell : fromCP.getCells()) {
          walEdit.add(cell);
        }
      }
      addFamilyMapToWALEdit(familyMaps[i],walEdit);
    }
    Mutation mutation=batchOp.getMutation(firstIndex);
    if (isInReplay) {
      walKey=new ReplayHLogKey(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),WALKey.NO_SEQUENCE_ID,now,mutation.getClusterIds(),currentNonceGroup,currentNonce,mvcc);
      long replaySeqId=batchOp.getReplaySequenceId();
      walKey.setOrigLogSeqNum(replaySeqId);
    }
    if (walEdit.size() > 0) {
      if (!isInReplay) {
        walKey=new HLogKey(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),WALKey.NO_SEQUENCE_ID,now,mutation.getClusterIds(),currentNonceGroup,currentNonce,mvcc);
      }
      txid=this.wal.append(this.htableDescriptor,this.getRegionInfo(),walKey,walEdit,true);
    }
    if (walKey == null) {
      walKey=this.appendEmptyEdit(this.wal);
    }
    if (!isInReplay) {
      writeEntry=walKey.getWriteEntry();
      mvccNum=writeEntry.getWriteNumber();
    }
 else {
      mvccNum=batchOp.getReplaySequenceId();
    }
    long addedSize=0;
    for (int i=firstIndex; i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.NOT_RUN) {
        continue;
      }
      doRollBackMemstore=true;
      addedSize+=applyFamilyMapToMemstore(familyMaps[i],mvccNum,isInReplay);
    }
    if (locked) {
      this.updatesLock.readLock().unlock();
      locked=false;
    }
    releaseRowLocks(acquiredRowLocks);
    if (txid != 0) {
      syncOrDefer(txid,durability);
    }
    doRollBackMemstore=false;
    if (!isInReplay && coprocessorHost != null) {
      MiniBatchOperationInProgress<Mutation> miniBatchOp=new MiniBatchOperationInProgress<Mutation>(batchOp.getMutationsForCoprocs(),batchOp.retCodeDetails,batchOp.walEditsFromCoprocessors,firstIndex,lastIndexExclusive);
      coprocessorHost.postBatchMutate(miniBatchOp);
    }
    if (writeEntry != null) {
      mvcc.completeAndWait(writeEntry);
      writeEntry=null;
    }
 else     if (isInReplay) {
      mvcc.advanceTo(mvccNum);
    }
    for (int i=firstIndex; i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i] == OperationStatus.NOT_RUN) {
        batchOp.retCodeDetails[i]=OperationStatus.SUCCESS;
      }
    }
    if (!isInReplay && coprocessorHost != null) {
      for (int i=firstIndex; i < lastIndexExclusive; i++) {
        if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.SUCCESS) {
          continue;
        }
        Mutation m=batchOp.getMutation(i);
        if (m instanceof Put) {
          coprocessorHost.postPut((Put)m,walEdit,m.getDurability());
        }
 else {
          coprocessorHost.postDelete((Delete)m,walEdit,m.getDurability());
        }
      }
    }
    success=true;
    return addedSize;
  }
  finally {
    if (doRollBackMemstore) {
      for (int j=0; j < familyMaps.length; j++) {
        for (        List<Cell> cells : familyMaps[j].values()) {
          rollbackMemstore(cells);
        }
      }
      if (writeEntry != null)       mvcc.complete(writeEntry);
    }
 else     if (writeEntry != null) {
      mvcc.completeAndWait(writeEntry);
    }
    if (locked) {
      this.updatesLock.readLock().unlock();
    }
    releaseRowLocks(acquiredRowLocks);
    if (noOfPuts > 0) {
      if (this.metricsRegion != null) {
        this.metricsRegion.updatePut();
      }
    }
    if (noOfDeletes > 0) {
      if (this.metricsRegion != null) {
        this.metricsRegion.updateDelete();
      }
    }
    if (!success) {
      for (int i=firstIndex; i < lastIndexExclusive; i++) {
        if (batchOp.retCodeDetails[i].getOperationStatusCode() == OperationStatusCode.NOT_RUN) {
          batchOp.retCodeDetails[i]=OperationStatus.FAILURE;
        }
      }
    }
    if (coprocessorHost != null && !batchOp.isInReplay()) {
      MiniBatchOperationInProgress<Mutation> miniBatchOp=new MiniBatchOperationInProgress<Mutation>(batchOp.getMutationsForCoprocs(),batchOp.retCodeDetails,batchOp.walEditsFromCoprocessors,firstIndex,lastIndexExclusive);
      coprocessorHost.postBatchMutateIndispensably(miniBatchOp,success);
    }
    batchOp.nextIndexToProcess=lastIndexExclusive;
  }
}
