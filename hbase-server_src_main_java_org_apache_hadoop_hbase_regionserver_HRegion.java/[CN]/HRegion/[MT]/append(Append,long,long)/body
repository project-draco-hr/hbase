{
  byte[] row=append.getRow();
  checkRow(row,"append");
  boolean flush=false;
  Durability durability=getEffectiveDurability(append.getDurability());
  boolean writeToWAL=durability != Durability.SKIP_WAL;
  WALEdit walEdits=null;
  List<Cell> allKVs=new ArrayList<Cell>(append.size());
  Map<Store,List<Cell>> tempMemstore=new HashMap<Store,List<Cell>>();
  long size=0;
  long txid=0;
  checkReadOnly();
  checkResources();
  startRegionOperation(Operation.APPEND);
  this.writeRequestsCount.increment();
  long mvccNum=0;
  WriteEntry w=null;
  HLogKey walKey=null;
  RowLock rowLock=null;
  List<Cell> memstoreCells=new ArrayList<Cell>();
  boolean doRollBackMemstore=false;
  try {
    rowLock=getRowLock(row);
    try {
      lock(this.updatesLock.readLock());
      try {
        mvcc.waitForPreviousTransactionsComplete();
        if (this.coprocessorHost != null) {
          Result r=this.coprocessorHost.preAppendAfterRowLock(append);
          if (r != null) {
            return r;
          }
        }
        mvccNum=MultiVersionConsistencyControl.getPreAssignedWriteNumber(this.sequenceId);
        w=mvcc.beginMemstoreInsertWithSeqNum(mvccNum);
        long now=EnvironmentEdgeManager.currentTime();
        for (        Map.Entry<byte[],List<Cell>> family : append.getFamilyCellMap().entrySet()) {
          Store store=stores.get(family.getKey());
          List<Cell> kvs=new ArrayList<Cell>(family.getValue().size());
          Collections.sort(family.getValue(),store.getComparator());
          Get get=new Get(row);
          for (          Cell cell : family.getValue()) {
            get.addColumn(family.getKey(),CellUtil.cloneQualifier(cell));
          }
          List<Cell> results=get(get,false);
          int idx=0;
          for (          Cell cell : family.getValue()) {
            Cell newCell;
            Cell oldCell=null;
            if (idx < results.size() && CellUtil.matchingQualifier(results.get(idx),cell)) {
              oldCell=results.get(idx);
              newCell=new KeyValue(row.length,cell.getFamilyLength(),cell.getQualifierLength(),now,KeyValue.Type.Put,oldCell.getValueLength() + cell.getValueLength(),oldCell.getTagsLength() + cell.getTagsLength());
              System.arraycopy(oldCell.getValueArray(),oldCell.getValueOffset(),newCell.getValueArray(),newCell.getValueOffset(),oldCell.getValueLength());
              System.arraycopy(cell.getValueArray(),cell.getValueOffset(),newCell.getValueArray(),newCell.getValueOffset() + oldCell.getValueLength(),cell.getValueLength());
              System.arraycopy(oldCell.getTagsArray(),oldCell.getTagsOffset(),newCell.getTagsArray(),newCell.getTagsOffset(),oldCell.getTagsLength());
              System.arraycopy(cell.getTagsArray(),cell.getTagsOffset(),newCell.getTagsArray(),newCell.getTagsOffset() + oldCell.getTagsLength(),cell.getTagsLength());
              System.arraycopy(cell.getRowArray(),cell.getRowOffset(),newCell.getRowArray(),newCell.getRowOffset(),cell.getRowLength());
              System.arraycopy(cell.getFamilyArray(),cell.getFamilyOffset(),newCell.getFamilyArray(),newCell.getFamilyOffset(),cell.getFamilyLength());
              System.arraycopy(cell.getQualifierArray(),cell.getQualifierOffset(),newCell.getQualifierArray(),newCell.getQualifierOffset(),cell.getQualifierLength());
              idx++;
            }
 else {
              CellUtil.updateLatestStamp(cell,now);
              newCell=cell;
            }
            CellUtil.setSequenceId(newCell,mvccNum);
            if (coprocessorHost != null) {
              newCell=coprocessorHost.postMutationBeforeWAL(RegionObserver.MutationType.APPEND,append,oldCell,newCell);
            }
            kvs.add(newCell);
            if (writeToWAL) {
              if (walEdits == null) {
                walEdits=new WALEdit();
              }
              walEdits.add(newCell);
            }
          }
          tempMemstore.put(store,kvs);
        }
        for (        Map.Entry<Store,List<Cell>> entry : tempMemstore.entrySet()) {
          Store store=entry.getKey();
          if (store.getFamily().getMaxVersions() == 1) {
            size+=store.upsert(entry.getValue(),getSmallestReadPoint());
            memstoreCells.addAll(entry.getValue());
          }
 else {
            for (            Cell cell : entry.getValue()) {
              Pair<Long,Cell> ret=store.add(cell);
              size+=ret.getFirst();
              memstoreCells.add(ret.getSecond());
              doRollBackMemstore=true;
            }
          }
          allKVs.addAll(entry.getValue());
        }
        if (writeToWAL) {
          walKey=new HLogKey(getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),HLog.NO_SEQUENCE_ID,nonceGroup,nonce);
          txid=this.log.appendNoSync(this.htableDescriptor,getRegionInfo(),walKey,walEdits,this.sequenceId,true,memstoreCells);
        }
 else {
          recordMutationWithoutWal(append.getFamilyCellMap());
        }
        if (walKey == null) {
          walKey=this.appendNoSyncNoAppend(this.log,memstoreCells);
        }
        size=this.addAndGetGlobalMemstoreSize(size);
        flush=isFlushSize(size);
      }
  finally {
        this.updatesLock.readLock().unlock();
      }
    }
  finally {
      rowLock.release();
      rowLock=null;
    }
    if (txid != 0) {
      syncOrDefer(txid,durability);
    }
    doRollBackMemstore=false;
  }
  finally {
    if (rowLock != null) {
      rowLock.release();
    }
    if (doRollBackMemstore) {
      rollbackMemstore(memstoreCells);
    }
    if (w != null) {
      mvcc.completeMemstoreInsertWithSeqNum(w,walKey);
    }
    closeRegionOperation(Operation.APPEND);
  }
  if (this.metricsRegion != null) {
    this.metricsRegion.updateAppend();
  }
  if (flush) {
    requestFlush();
  }
  return append.isReturnResults() ? Result.create(allKVs) : null;
}
