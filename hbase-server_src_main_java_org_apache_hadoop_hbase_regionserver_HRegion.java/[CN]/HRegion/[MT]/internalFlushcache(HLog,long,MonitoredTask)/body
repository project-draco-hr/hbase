{
  if (this.rsServices != null && this.rsServices.isAborted()) {
    throw new IOException("Aborting flush because server is aborted...");
  }
  final long startTime=EnvironmentEdgeManager.currentTimeMillis();
  if (this.memstoreSize.get() <= 0) {
    this.updatesLock.writeLock().lock();
    try {
      if (this.memstoreSize.get() <= 0) {
        return wal != null ? new FlushResult(FlushResult.Result.CANNOT_FLUSH_MEMSTORE_EMPTY,getNextSequenceId(wal),"Nothing to flush") : new FlushResult(FlushResult.Result.CANNOT_FLUSH_MEMSTORE_EMPTY,"Nothing to flush");
      }
    }
  finally {
      this.updatesLock.writeLock().unlock();
    }
  }
  LOG.info("Started memstore flush for " + this + ", current region memstore size "+ StringUtils.byteDesc(this.memstoreSize.get())+ ((wal != null) ? "" : "; wal is null, using passed sequenceid=" + myseqid));
  MultiVersionConsistencyControl.WriteEntry w=null;
  status.setStatus("Obtaining lock to block concurrent updates");
  this.updatesLock.writeLock().lock();
  long totalFlushableSize=0;
  status.setStatus("Preparing to flush by snapshotting stores in " + getRegionInfo().getEncodedName());
  List<StoreFlushContext> storeFlushCtxs=new ArrayList<StoreFlushContext>(stores.size());
  TreeMap<byte[],List<Path>> committedFiles=new TreeMap<byte[],List<Path>>(Bytes.BYTES_COMPARATOR);
  long flushSeqId=-1L;
  long trxId=0;
  try {
    try {
      w=mvcc.beginMemstoreInsert();
      if (wal != null) {
        if (!wal.startCacheFlush(this.getRegionInfo().getEncodedNameAsBytes())) {
          String msg="Flush will not be started for [" + this.getRegionInfo().getEncodedName() + "] - because the WAL is closing.";
          status.setStatus(msg);
          return new FlushResult(FlushResult.Result.CANNOT_FLUSH,msg);
        }
        flushSeqId=getNextSequenceId(wal);
      }
 else {
        flushSeqId=myseqid;
      }
      for (      Store s : stores.values()) {
        totalFlushableSize+=s.getFlushableSize();
        storeFlushCtxs.add(s.createFlushContext(flushSeqId));
        committedFiles.put(s.getFamily().getName(),null);
      }
      if (wal != null) {
        FlushDescriptor desc=ProtobufUtil.toFlushDescriptor(FlushAction.START_FLUSH,getRegionInfo(),flushSeqId,committedFiles);
        trxId=HLogUtil.writeFlushMarker(wal,this.htableDescriptor,getRegionInfo(),desc,sequenceId,false);
      }
      for (      StoreFlushContext flush : storeFlushCtxs) {
        flush.prepare();
      }
    }
 catch (    IOException ex) {
      if (wal != null) {
        if (trxId > 0) {
          try {
            FlushDescriptor desc=ProtobufUtil.toFlushDescriptor(FlushAction.ABORT_FLUSH,getRegionInfo(),flushSeqId,committedFiles);
            HLogUtil.writeFlushMarker(wal,this.htableDescriptor,getRegionInfo(),desc,sequenceId,false);
          }
 catch (          Throwable t) {
            LOG.warn("Received unexpected exception trying to write ABORT_FLUSH marker to WAL:" + StringUtils.stringifyException(t));
          }
        }
        wal.abortCacheFlush(this.getRegionInfo().getEncodedNameAsBytes());
        throw ex;
      }
    }
 finally {
      this.updatesLock.writeLock().unlock();
    }
    String s="Finished memstore snapshotting " + this + ", syncing WAL and waiting on mvcc, flushsize="+ totalFlushableSize;
    status.setStatus(s);
    if (LOG.isTraceEnabled())     LOG.trace(s);
    if (wal != null) {
      try {
        wal.sync();
      }
 catch (      IOException ioe) {
        LOG.warn("Unexpected exception while log.sync(), ignoring. Exception: " + StringUtils.stringifyException(ioe));
      }
    }
    mvcc.waitForPreviousTransactionsComplete(w);
    w=null;
    s="Flushing stores of " + this;
    status.setStatus(s);
    if (LOG.isTraceEnabled())     LOG.trace(s);
  }
  finally {
    if (w != null) {
      mvcc.advanceMemstore(w);
    }
  }
  boolean compactionRequested=false;
  try {
    for (    StoreFlushContext flush : storeFlushCtxs) {
      flush.flushCache(status);
    }
    Iterator<Store> it=stores.values().iterator();
    for (    StoreFlushContext flush : storeFlushCtxs) {
      boolean needsCompaction=flush.commit(status);
      if (needsCompaction) {
        compactionRequested=true;
      }
      committedFiles.put(it.next().getFamily().getName(),flush.getCommittedFiles());
    }
    storeFlushCtxs.clear();
    this.addAndGetGlobalMemstoreSize(-totalFlushableSize);
    if (wal != null) {
      FlushDescriptor desc=ProtobufUtil.toFlushDescriptor(FlushAction.COMMIT_FLUSH,getRegionInfo(),flushSeqId,committedFiles);
      HLogUtil.writeFlushMarker(wal,this.htableDescriptor,getRegionInfo(),desc,sequenceId,true);
    }
  }
 catch (  Throwable t) {
    if (wal != null) {
      try {
        FlushDescriptor desc=ProtobufUtil.toFlushDescriptor(FlushAction.ABORT_FLUSH,getRegionInfo(),flushSeqId,committedFiles);
        HLogUtil.writeFlushMarker(wal,this.htableDescriptor,getRegionInfo(),desc,sequenceId,false);
      }
 catch (      Throwable ex) {
        LOG.warn("Received unexpected exception trying to write ABORT_FLUSH marker to WAL:" + StringUtils.stringifyException(ex));
      }
      wal.abortCacheFlush(this.getRegionInfo().getEncodedNameAsBytes());
    }
    DroppedSnapshotException dse=new DroppedSnapshotException("region: " + Bytes.toStringBinary(getRegionName()));
    dse.initCause(t);
    status.abort("Flush failed: " + StringUtils.stringifyException(t));
    throw dse;
  }
  if (wal != null) {
    wal.completeCacheFlush(this.getRegionInfo().getEncodedNameAsBytes());
  }
  this.lastFlushTime=EnvironmentEdgeManager.currentTimeMillis();
  this.lastFlushSeqId=flushSeqId;
synchronized (this) {
    notifyAll();
  }
  long time=EnvironmentEdgeManager.currentTimeMillis() - startTime;
  long memstoresize=this.memstoreSize.get();
  String msg="Finished memstore flush of ~" + StringUtils.byteDesc(totalFlushableSize) + "/"+ totalFlushableSize+ ", currentsize="+ StringUtils.byteDesc(memstoresize)+ "/"+ memstoresize+ " for region "+ this+ " in "+ time+ "ms, sequenceid="+ flushSeqId+ ", compaction requested="+ compactionRequested+ ((wal == null) ? "; wal=null" : "");
  LOG.info(msg);
  status.setStatus(msg);
  return new FlushResult(compactionRequested ? FlushResult.Result.FLUSHED_COMPACTION_NEEDED : FlushResult.Result.FLUSHED_NO_COMPACTION_NEEDED,flushSeqId);
}
