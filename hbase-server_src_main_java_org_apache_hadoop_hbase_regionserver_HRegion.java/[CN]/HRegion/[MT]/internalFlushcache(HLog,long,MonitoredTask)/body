{
  if (this.rsServices != null && this.rsServices.isAborted()) {
    throw new IOException("Aborting flush because server is abortted...");
  }
  final long startTime=EnvironmentEdgeManager.currentTimeMillis();
  if (this.memstoreSize.get() <= 0) {
    return new FlushResult(FlushResult.Result.CANNOT_FLUSH_MEMSTORE_EMPTY,"Nothing to flush");
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Started memstore flush for " + this + ", current region memstore size "+ StringUtils.humanReadableInt(this.memstoreSize.get())+ ((wal != null) ? "" : "; wal is null, using passed sequenceid=" + myseqid));
  }
  MultiVersionConsistencyControl.WriteEntry w=null;
  status.setStatus("Obtaining lock to block concurrent updates");
  this.updatesLock.writeLock().lock();
  long totalFlushableSize=0;
  status.setStatus("Preparing to flush by snapshotting stores");
  List<StoreFlushContext> storeFlushCtxs=new ArrayList<StoreFlushContext>(stores.size());
  long flushSeqId=-1L;
  try {
    w=mvcc.beginMemstoreInsert();
    mvcc.advanceMemstore(w);
    if (wal != null) {
      if (!wal.startCacheFlush(this.getRegionInfo().getEncodedNameAsBytes())) {
        String msg="Flush will not be started for [" + this.getRegionInfo().getEncodedName() + "] - because the WAL is closing.";
        status.setStatus(msg);
        return new FlushResult(FlushResult.Result.CANNOT_FLUSH,msg);
      }
      flushSeqId=this.sequenceId.incrementAndGet();
    }
 else {
      flushSeqId=myseqid;
    }
    for (    Store s : stores.values()) {
      totalFlushableSize+=s.getFlushableSize();
      storeFlushCtxs.add(s.createFlushContext(flushSeqId));
    }
    for (    StoreFlushContext flush : storeFlushCtxs) {
      flush.prepare();
    }
  }
  finally {
    this.updatesLock.writeLock().unlock();
  }
  String s="Finished memstore snapshotting " + this + ", syncing WAL and waiting on mvcc, flushsize="+ totalFlushableSize;
  status.setStatus(s);
  if (LOG.isTraceEnabled())   LOG.trace(s);
  if (wal != null && !shouldSyncLog()) {
    wal.sync();
  }
  mvcc.waitForRead(w);
  s="Flushing stores of " + this;
  status.setStatus(s);
  if (LOG.isTraceEnabled())   LOG.trace(s);
  boolean compactionRequested=false;
  try {
    for (    StoreFlushContext flush : storeFlushCtxs) {
      flush.flushCache(status);
    }
    for (    StoreFlushContext flush : storeFlushCtxs) {
      boolean needsCompaction=flush.commit(status);
      if (needsCompaction) {
        compactionRequested=true;
      }
    }
    storeFlushCtxs.clear();
    this.addAndGetGlobalMemstoreSize(-totalFlushableSize);
  }
 catch (  Throwable t) {
    if (wal != null) {
      wal.abortCacheFlush(this.getRegionInfo().getEncodedNameAsBytes());
    }
    DroppedSnapshotException dse=new DroppedSnapshotException("region: " + Bytes.toStringBinary(getRegionName()));
    dse.initCause(t);
    status.abort("Flush failed: " + StringUtils.stringifyException(t));
    throw dse;
  }
  if (wal != null) {
    wal.completeCacheFlush(this.getRegionInfo().getEncodedNameAsBytes());
  }
  this.lastFlushTime=EnvironmentEdgeManager.currentTimeMillis();
  completeSequenceId=flushSeqId;
synchronized (this) {
    notifyAll();
  }
  long time=EnvironmentEdgeManager.currentTimeMillis() - startTime;
  long memstoresize=this.memstoreSize.get();
  String msg="Finished memstore flush of ~" + StringUtils.humanReadableInt(totalFlushableSize) + "/"+ totalFlushableSize+ ", currentsize="+ StringUtils.humanReadableInt(memstoresize)+ "/"+ memstoresize+ " for region "+ this+ " in "+ time+ "ms, sequenceid="+ flushSeqId+ ", compaction requested="+ compactionRequested+ ((wal == null) ? "; wal=null" : "");
  LOG.info(msg);
  status.setStatus(msg);
  this.recentFlushes.add(new Pair<Long,Long>(time / 1000,totalFlushableSize));
  return new FlushResult(compactionRequested ? FlushResult.Result.FLUSHED_COMPACTION_NEEDED : FlushResult.Result.FLUSHED_NO_COMPACTION_NEEDED,flushSeqId);
}
