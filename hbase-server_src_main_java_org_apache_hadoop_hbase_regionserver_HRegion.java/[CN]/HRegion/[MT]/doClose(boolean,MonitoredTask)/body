{
  if (isClosed()) {
    LOG.warn("Region " + this + " already closed");
    return null;
  }
  if (coprocessorHost != null) {
    status.setStatus("Running coprocessor pre-close hooks");
    this.coprocessorHost.preClose(abort);
  }
  status.setStatus("Disabling compacts and flushes for region");
  boolean wasFlushing=false;
synchronized (writestate) {
    writestate.writesEnabled=false;
    wasFlushing=writestate.flushing;
    LOG.debug("Closing " + this + ": disabling compactions & flushes");
    waitForFlushesAndCompactions();
  }
  if (!abort && !wasFlushing && worthPreFlushing()) {
    status.setStatus("Pre-flushing region before close");
    LOG.info("Running close preflush of " + this.getRegionNameAsString());
    internalFlushcache(status);
  }
  this.closing.set(true);
  status.setStatus("Disabling writes for close");
  lock.writeLock().lock();
  try {
    if (this.isClosed()) {
      status.abort("Already got closed by another process");
      return null;
    }
    LOG.debug("Updates disabled for region " + this);
    if (!abort) {
      internalFlushcache(status);
    }
    List<StoreFile> result=new ArrayList<StoreFile>();
    if (!stores.isEmpty()) {
      ThreadPoolExecutor storeCloserThreadPool=getStoreOpenAndCloseThreadPool("StoreCloserThread-" + this.regionInfo.getRegionNameAsString());
      CompletionService<Collection<StoreFile>> completionService=new ExecutorCompletionService<Collection<StoreFile>>(storeCloserThreadPool);
      for (      final Store store : stores.values()) {
        completionService.submit(new Callable<Collection<StoreFile>>(){
          public Collection<StoreFile> call() throws IOException {
            return store.close();
          }
        }
);
      }
      try {
        for (int i=0; i < stores.size(); i++) {
          Future<Collection<StoreFile>> future=completionService.take();
          Collection<StoreFile> storeFileList=future.get();
          result.addAll(storeFileList);
        }
      }
 catch (      InterruptedException e) {
        throw new IOException(e);
      }
catch (      ExecutionException e) {
        throw new IOException(e.getCause());
      }
 finally {
        storeCloserThreadPool.shutdownNow();
      }
    }
    this.closed.set(true);
    if (coprocessorHost != null) {
      status.setStatus("Running coprocessor post-close hooks");
      this.coprocessorHost.postClose(abort);
    }
    if (this.metricsRegion != null) {
      this.metricsRegion.close();
    }
    if (this.metricsRegionWrapper != null) {
      Closeables.closeQuietly(this.metricsRegionWrapper);
    }
    status.markComplete("Closed");
    LOG.info("Closed " + this);
    return result;
  }
  finally {
    lock.writeLock().unlock();
  }
}
