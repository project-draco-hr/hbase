{
  List<IndexSpecification> indexesToUpdate=new LinkedList<IndexSpecification>();
  for (  IndexSpecification index : getIndexes()) {
    if (possiblyAppliesToIndex(index,put)) {
      indexesToUpdate.add(index);
    }
  }
  if (indexesToUpdate.size() == 0) {
    return;
  }
  NavigableSet<byte[]> neededColumns=getColumnsForIndexes(indexesToUpdate);
  NavigableMap<byte[],byte[]> newColumnValues=getColumnsFromPut(put);
  Get oldGet=new Get(put.getRow());
  for (  byte[] neededCol : neededColumns) {
    byte[][] famQf=KeyValue.parseColumn(neededCol);
    if (famQf.length == 1) {
      oldGet.addFamily(famQf[0]);
    }
 else {
      oldGet.addColumn(famQf[0],famQf[1]);
    }
  }
  Result oldResult=super.get(oldGet,lockId);
  if (oldResult != null && oldResult.raw() != null) {
    for (    KeyValue oldKV : oldResult.raw()) {
      byte[] column=KeyValue.makeColumn(oldKV.getFamily(),oldKV.getQualifier());
      if (!newColumnValues.containsKey(column)) {
        newColumnValues.put(column,oldKV.getValue());
      }
    }
  }
  Iterator<IndexSpecification> indexIterator=indexesToUpdate.iterator();
  while (indexIterator.hasNext()) {
    IndexSpecification indexSpec=indexIterator.next();
    if (!IndexMaintenanceUtils.doesApplyToIndex(indexSpec,newColumnValues)) {
      indexIterator.remove();
    }
  }
  SortedMap<byte[],byte[]> oldColumnValues=convertToValueMap(oldResult);
  for (  IndexSpecification indexSpec : indexesToUpdate) {
    removeOldIndexEntry(indexSpec,put.getRow(),oldColumnValues);
    updateIndex(indexSpec,put.getRow(),newColumnValues);
  }
}
