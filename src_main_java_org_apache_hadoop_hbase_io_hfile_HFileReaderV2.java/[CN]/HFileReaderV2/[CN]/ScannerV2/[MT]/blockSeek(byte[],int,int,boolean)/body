{
  int klen, vlen;
  long memstoreTS=0;
  int memstoreTSLen=0;
  int lastKeyValueSize=-1;
  do {
    blockBuffer.mark();
    klen=blockBuffer.getInt();
    vlen=blockBuffer.getInt();
    blockBuffer.reset();
    if (this.reader.shouldIncludeMemstoreTS()) {
      try {
        int memstoreTSOffset=blockBuffer.arrayOffset() + blockBuffer.position() + KEY_VALUE_LEN_SIZE+ klen+ vlen;
        memstoreTS=Bytes.readVLong(blockBuffer.array(),memstoreTSOffset);
        memstoreTSLen=WritableUtils.getVIntSize(memstoreTS);
      }
 catch (      Exception e) {
        throw new RuntimeException("Error reading memstore timestamp",e);
      }
    }
    int keyOffset=blockBuffer.arrayOffset() + blockBuffer.position() + KEY_VALUE_LEN_SIZE;
    int comp=reader.getComparator().compare(key,offset,length,blockBuffer.array(),keyOffset,klen);
    if (comp == 0) {
      if (seekBefore) {
        if (lastKeyValueSize < 0) {
          throw new IllegalStateException("blockSeek with seekBefore " + "at the first key of the block: key=" + Bytes.toStringBinary(key) + ", blockOffset="+ block.getOffset()+ ", onDiskSize="+ block.getOnDiskSizeWithHeader());
        }
        blockBuffer.position(blockBuffer.position() - lastKeyValueSize);
        readKeyValueLen();
        return 1;
      }
      currKeyLen=klen;
      currValueLen=vlen;
      if (this.reader.shouldIncludeMemstoreTS()) {
        currMemstoreTS=memstoreTS;
        currMemstoreTSLen=memstoreTSLen;
      }
      return 0;
    }
    if (comp < 0) {
      if (lastKeyValueSize > 0)       blockBuffer.position(blockBuffer.position() - lastKeyValueSize);
      readKeyValueLen();
      return 1;
    }
    lastKeyValueSize=klen + vlen + memstoreTSLen+ KEY_VALUE_LEN_SIZE;
    blockBuffer.position(blockBuffer.position() + lastKeyValueSize);
  }
 while (blockBuffer.remaining() > 0);
  blockBuffer.position(blockBuffer.position() - lastKeyValueSize);
  readKeyValueLen();
  return 1;
}
