{
  startupStatus.setStatus("Trying to register in ZK as active master");
  boolean cleanSetOfActiveMaster=true;
  try {
    if (ZKUtil.createEphemeralNodeAndWatch(this.watcher,this.watcher.masterAddressZNode,Bytes.toBytes(this.sn.toString()))) {
      startupStatus.setStatus("Successfully registered as active master.");
      this.clusterHasActiveMaster.set(true);
      LOG.info("Master=" + this.sn);
      return cleanSetOfActiveMaster;
    }
    cleanSetOfActiveMaster=false;
    this.clusterHasActiveMaster.set(true);
    byte[] bytes=ZKUtil.getDataAndWatch(this.watcher,this.watcher.masterAddressZNode);
    ServerName currentMaster=new ServerName(Bytes.toString(bytes));
    if (ServerName.isSameHostnameAndPort(currentMaster,this.sn)) {
      String msg=("Current master has this master's address, " + currentMaster + "; master was restarted?  Waiting on znode to expire...");
      LOG.info(msg);
      startupStatus.setStatus(msg);
      ZKUtil.deleteNode(this.watcher,this.watcher.masterAddressZNode);
    }
 else {
      String msg="Another master is the active master, " + currentMaster + "; waiting to become the next active master";
      LOG.info(msg);
      startupStatus.setStatus(msg);
    }
  }
 catch (  KeeperException ke) {
    master.abort("Received an unexpected KeeperException, aborting",ke);
    return false;
  }
synchronized (this.clusterHasActiveMaster) {
    while (this.clusterHasActiveMaster.get() && !this.master.isStopped()) {
      try {
        this.clusterHasActiveMaster.wait();
      }
 catch (      InterruptedException e) {
        LOG.debug("Interrupted waiting for master to die",e);
      }
    }
    if (this.master.isStopped()) {
      return cleanSetOfActiveMaster;
    }
    blockUntilBecomingActiveMaster(startupStatus);
  }
  return cleanSetOfActiveMaster;
}
