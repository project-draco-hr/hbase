{
  if (filter != null && filter.filterAllRemaining()) {
    return MatchCode.DONE_SCAN;
  }
  byte[] bytes=kv.getBuffer();
  int offset=kv.getOffset();
  int initialOffset=offset;
  int keyLength=Bytes.toInt(bytes,offset,Bytes.SIZEOF_INT);
  offset+=KeyValue.ROW_OFFSET;
  short rowLength=Bytes.toShort(bytes,offset,Bytes.SIZEOF_SHORT);
  offset+=Bytes.SIZEOF_SHORT;
  int ret=this.rowComparator.compareRows(row,0,row.length,bytes,offset,rowLength);
  if (ret <= -1) {
    return MatchCode.DONE;
  }
 else   if (ret >= 1) {
    return MatchCode.SEEK_NEXT_ROW;
  }
  if (this.stickyNextRow)   return MatchCode.SEEK_NEXT_ROW;
  if (this.columns.done()) {
    stickyNextRow=true;
    return MatchCode.SEEK_NEXT_ROW;
  }
  offset+=rowLength;
  byte familyLength=bytes[offset];
  offset+=familyLength + 1;
  int qualLength=keyLength + KeyValue.ROW_OFFSET - (offset - initialOffset) - KeyValue.TIMESTAMP_TYPE_SIZE;
  long timestamp=kv.getTimestamp();
  if (isExpired(timestamp)) {
    return getNextRowOrNextColumn(bytes,offset,qualLength);
  }
  byte type=kv.getType();
  if (isDelete(type)) {
    if (tr.withinOrAfterTimeRange(timestamp)) {
      this.deletes.add(bytes,offset,qualLength,timestamp,type);
    }
    return MatchCode.SKIP;
  }
  if (!this.deletes.isEmpty() && deletes.isDeleted(bytes,offset,qualLength,timestamp)) {
    return MatchCode.SKIP;
  }
  int timestampComparison=tr.compare(timestamp);
  if (timestampComparison >= 1) {
    return MatchCode.SKIP;
  }
 else   if (timestampComparison <= -1) {
    return getNextRowOrNextColumn(bytes,offset,qualLength);
  }
  if (filter != null) {
    ReturnCode filterResponse=filter.filterKeyValue(kv);
    if (filterResponse == ReturnCode.SKIP) {
      return MatchCode.SKIP;
    }
 else     if (filterResponse == ReturnCode.NEXT_COL) {
      return getNextRowOrNextColumn(bytes,offset,qualLength);
    }
 else     if (filterResponse == ReturnCode.NEXT_ROW) {
      stickyNextRow=true;
      return MatchCode.SEEK_NEXT_ROW;
    }
 else     if (filterResponse == ReturnCode.SEEK_NEXT_USING_HINT) {
      return MatchCode.SEEK_NEXT_USING_HINT;
    }
  }
  MatchCode colChecker=columns.checkColumn(bytes,offset,qualLength);
  if (colChecker == MatchCode.SKIP) {
    return MatchCode.SEEK_NEXT_COL;
  }
 else   if (colChecker == MatchCode.NEXT || colChecker == MatchCode.DONE) {
    stickyNextRow=true;
    return MatchCode.SEEK_NEXT_ROW;
  }
  return MatchCode.INCLUDE;
}
