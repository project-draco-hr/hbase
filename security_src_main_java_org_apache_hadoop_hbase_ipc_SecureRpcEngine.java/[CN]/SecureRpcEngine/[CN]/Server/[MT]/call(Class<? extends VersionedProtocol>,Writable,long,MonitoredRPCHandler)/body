{
  try {
    Invocation call=(Invocation)param;
    if (call.getMethodName() == null) {
      throw new IOException("Could not find requested method, the usual " + "cause is a version mismatch between client and server.");
    }
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    Object impl=null;
    if (protocol.isAssignableFrom(this.implementation)) {
      impl=this.instance;
    }
 else {
      throw new HBaseRPC.UnknownProtocolException(protocol);
    }
    long startTime=System.currentTimeMillis();
    Object[] params=call.getParameters();
    Object value=method.invoke(impl,params);
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (TRACELOG.isDebugEnabled()) {
      TRACELOG.debug("Call #" + CurCall.get().id + "; Served: "+ protocol.getSimpleName()+ "#"+ call.getMethodName()+ " queueTime="+ qTime+ " processingTime="+ processingTime+ " contents="+ Objects.describeQuantity(params));
    }
    rpcMetrics.rpcQueueTime.inc(qTime);
    rpcMetrics.rpcProcessingTime.inc(processingTime);
    rpcMetrics.inc(call.getMethodName(),processingTime);
    if (verbose)     log("Return: " + value);
    return new HbaseObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
    if (target instanceof ServiceException) {
      throw ProtobufUtil.getRemoteException((ServiceException)target);
    }
    IOException ioe=new IOException(target.toString());
    ioe.setStackTrace(target.getStackTrace());
    throw ioe;
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}
