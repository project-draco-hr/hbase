{
  if (this.deletes == null || this.deletes.size() == 0) {
    finalize(this.newDeletes);
    return;
  }
  if (this.newDeletes.size() == 0) {
    return;
  }
  List<Delete> mergeDeletes=new ArrayList<Delete>(this.newDeletes.size());
  int oldIndex=0;
  int newIndex=0;
  Delete newDelete=newDeletes.get(oldIndex);
  Delete oldDelete=deletes.get(oldIndex);
  while (true) {
switch (compareDeletes(oldDelete,newDelete)) {
case NEXT_NEW:
{
        if (++newIndex == newDeletes.size()) {
          mergeDown(mergeDeletes,deletes,oldIndex);
          finalize(mergeDeletes);
          return;
        }
        newDelete=this.newDeletes.get(newIndex);
        break;
      }
case INCLUDE_NEW_NEXT_NEW:
{
      mergeDeletes.add(newDelete);
      if (++newIndex == newDeletes.size()) {
        mergeDown(mergeDeletes,deletes,oldIndex);
        finalize(mergeDeletes);
        return;
      }
      newDelete=this.newDeletes.get(newIndex);
      break;
    }
case INCLUDE_NEW_NEXT_BOTH:
{
    mergeDeletes.add(newDelete);
    ++oldIndex;
    ++newIndex;
    if (oldIndex == deletes.size()) {
      if (newIndex == newDeletes.size()) {
        finalize(mergeDeletes);
        return;
      }
      mergeDown(mergeDeletes,newDeletes,newIndex);
      finalize(mergeDeletes);
      return;
    }
 else     if (newIndex == newDeletes.size()) {
      mergeDown(mergeDeletes,deletes,oldIndex);
      finalize(mergeDeletes);
      return;
    }
    oldDelete=this.deletes.get(oldIndex);
    newDelete=this.newDeletes.get(newIndex);
    break;
  }
case INCLUDE_OLD_NEXT_BOTH:
{
  mergeDeletes.add(oldDelete);
  ++oldIndex;
  ++newIndex;
  if (oldIndex == deletes.size()) {
    if (newIndex == newDeletes.size()) {
      finalize(mergeDeletes);
      return;
    }
    mergeDown(mergeDeletes,newDeletes,newIndex);
    finalize(mergeDeletes);
    return;
  }
 else   if (newIndex == newDeletes.size()) {
    mergeDown(mergeDeletes,deletes,oldIndex);
    finalize(mergeDeletes);
    return;
  }
  oldDelete=this.deletes.get(oldIndex);
  newDelete=this.newDeletes.get(newIndex);
  break;
}
case INCLUDE_OLD_NEXT_OLD:
{
mergeDeletes.add(oldDelete);
if (++oldIndex == deletes.size()) {
  mergeDown(mergeDeletes,newDeletes,newIndex);
  finalize(mergeDeletes);
  return;
}
oldDelete=this.deletes.get(oldIndex);
break;
}
case NEXT_OLD:
{
if (++oldIndex == deletes.size()) {
mergeDown(mergeDeletes,newDeletes,newIndex);
finalize(mergeDeletes);
return;
}
oldDelete=this.deletes.get(oldIndex);
}
}
}
}
