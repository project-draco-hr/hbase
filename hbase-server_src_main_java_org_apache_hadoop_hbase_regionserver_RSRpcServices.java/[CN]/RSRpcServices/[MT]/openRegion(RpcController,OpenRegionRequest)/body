{
  requestCount.increment();
  if (request.hasServerStartCode()) {
    long serverStartCode=request.getServerStartCode();
    if (regionServer.serverName.getStartcode() != serverStartCode) {
      throw new ServiceException(new DoNotRetryIOException("This RPC was intended for a " + "different server with startCode: " + serverStartCode + ", this server is: "+ regionServer.serverName));
    }
  }
  OpenRegionResponse.Builder builder=OpenRegionResponse.newBuilder();
  final int regionCount=request.getOpenInfoCount();
  final Map<TableName,HTableDescriptor> htds=new HashMap<TableName,HTableDescriptor>(regionCount);
  final boolean isBulkAssign=regionCount > 1;
  try {
    checkOpen();
  }
 catch (  IOException ie) {
    TableName tableName=null;
    if (regionCount == 1) {
      RegionInfo ri=request.getOpenInfo(0).getRegion();
      if (ri != null) {
        tableName=ProtobufUtil.toTableName(ri.getTableName());
      }
    }
    if (!TableName.META_TABLE_NAME.equals(tableName)) {
      throw new ServiceException(ie);
    }
    int timeout=regionServer.conf.getInt(HConstants.HBASE_RPC_TIMEOUT_KEY,HConstants.DEFAULT_HBASE_RPC_TIMEOUT) >> 2;
    long endTime=System.currentTimeMillis() + timeout;
synchronized (regionServer.online) {
      try {
        while (System.currentTimeMillis() <= endTime && !regionServer.isStopped() && !regionServer.isOnline()) {
          regionServer.online.wait(100);
        }
        checkOpen();
      }
 catch (      InterruptedException t) {
        Thread.currentThread().interrupt();
        throw new ServiceException(t);
      }
catch (      IOException e) {
        throw new ServiceException(e);
      }
    }
  }
  for (  RegionOpenInfo regionOpenInfo : request.getOpenInfoList()) {
    final HRegionInfo region=HRegionInfo.convert(regionOpenInfo.getRegion());
    OpenRegionCoordination coordination=regionServer.getCoordinatedStateManager().getOpenRegionCoordination();
    OpenRegionCoordination.OpenRegionDetails ord=coordination.parseFromProtoRequest(regionOpenInfo);
    HTableDescriptor htd;
    try {
      final HRegion onlineRegion=regionServer.getFromOnlineRegions(region.getEncodedName());
      if (onlineRegion != null) {
        if (onlineRegion.getCoprocessorHost() != null) {
          onlineRegion.getCoprocessorHost().preOpen();
        }
        Pair<HRegionInfo,ServerName> p=MetaTableAccessor.getRegion(regionServer.getShortCircuitConnection(),region.getRegionName());
        if (regionServer.serverName.equals(p.getSecond())) {
          Boolean closing=regionServer.regionsInTransitionInRS.get(region.getEncodedNameAsBytes());
          if (!Boolean.FALSE.equals(closing) && regionServer.getFromOnlineRegions(region.getEncodedName()) != null) {
            LOG.warn("Attempted open of " + region.getEncodedName() + " but already online on this server");
            builder.addOpeningState(RegionOpeningState.ALREADY_OPENED);
            continue;
          }
        }
 else {
          LOG.warn("The region " + region.getEncodedName() + " is online on this server"+ " but hbase:meta does not have this server - continue opening.");
          regionServer.removeFromOnlineRegions(onlineRegion,null);
        }
      }
      LOG.info("Open " + region.getRegionNameAsString());
      htd=htds.get(region.getTable());
      if (htd == null) {
        htd=regionServer.tableDescriptors.get(region.getTable());
        htds.put(region.getTable(),htd);
      }
      final Boolean previous=regionServer.regionsInTransitionInRS.putIfAbsent(region.getEncodedNameAsBytes(),Boolean.TRUE);
      if (Boolean.FALSE.equals(previous)) {
        coordination.tryTransitionFromOfflineToFailedOpen(regionServer,region,ord);
        throw new RegionAlreadyInTransitionException("Received OPEN for the region:" + region.getRegionNameAsString() + " , which we are already trying to CLOSE ");
      }
      if (Boolean.TRUE.equals(previous)) {
        LOG.info("Receiving OPEN for the region:" + region.getRegionNameAsString() + " , which we are already trying to OPEN"+ " - ignoring this new request for this region.");
      }
      regionServer.removeFromMovedRegions(region.getEncodedName());
      if (previous == null) {
        if (SplitLogManager.isRegionMarkedRecoveringInZK(regionServer.getZooKeeper(),region.getEncodedName())) {
          if (!regionOpenInfo.hasOpenForDistributedLogReplay() || regionOpenInfo.getOpenForDistributedLogReplay()) {
            regionServer.recoveringRegions.put(region.getEncodedName(),null);
          }
 else {
            List<String> tmpRegions=new ArrayList<String>();
            tmpRegions.add(region.getEncodedName());
            SplitLogManager.deleteRecoveringRegionZNodes(regionServer.getZooKeeper(),tmpRegions);
          }
        }
        if (region.isMetaRegion()) {
          regionServer.service.submit(new OpenMetaHandler(regionServer,regionServer,region,htd,coordination,ord));
        }
 else {
          regionServer.updateRegionFavoredNodesMapping(region.getEncodedName(),regionOpenInfo.getFavoredNodesList());
          regionServer.service.submit(new OpenRegionHandler(regionServer,regionServer,region,htd,coordination,ord));
        }
      }
      builder.addOpeningState(RegionOpeningState.OPENED);
    }
 catch (    KeeperException zooKeeperEx) {
      LOG.error("Can't retrieve recovering state from zookeeper",zooKeeperEx);
      throw new ServiceException(zooKeeperEx);
    }
catch (    IOException ie) {
      LOG.warn("Failed opening region " + region.getRegionNameAsString(),ie);
      if (isBulkAssign) {
        builder.addOpeningState(RegionOpeningState.FAILED_OPENING);
      }
 else {
        throw new ServiceException(ie);
      }
    }
  }
  return builder.build();
}
