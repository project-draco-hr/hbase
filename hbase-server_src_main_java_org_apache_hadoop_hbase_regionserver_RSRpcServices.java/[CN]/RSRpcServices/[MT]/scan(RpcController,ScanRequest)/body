{
  OperationQuota quota=null;
  Leases.Lease lease=null;
  String scannerName=null;
  try {
    if (!request.hasScannerId() && !request.hasScan()) {
      throw new DoNotRetryIOException("Missing required input: scannerId or scan");
    }
    long scannerId=-1;
    if (request.hasScannerId()) {
      scannerId=request.getScannerId();
      scannerName=String.valueOf(scannerId);
    }
    try {
      checkOpen();
    }
 catch (    IOException e) {
      if (scannerName != null) {
        LOG.debug("Server shutting down and client tried to access missing scanner " + scannerName);
        if (regionServer.leases != null) {
          try {
            regionServer.leases.cancelLease(scannerName);
          }
 catch (          LeaseException le) {
          }
        }
      }
      throw e;
    }
    requestCount.increment();
    int ttl=0;
    Region region=null;
    RegionScanner scanner=null;
    RegionScannerHolder rsh=null;
    boolean moreResults=true;
    boolean closeScanner=false;
    boolean isSmallScan=false;
    ScanResponse.Builder builder=ScanResponse.newBuilder();
    if (request.hasCloseScanner()) {
      closeScanner=request.getCloseScanner();
    }
    int rows=closeScanner ? 0 : 1;
    if (request.hasNumberOfRows()) {
      rows=request.getNumberOfRows();
    }
    if (request.hasScannerId()) {
      rsh=scanners.get(scannerName);
      if (rsh == null) {
        LOG.info("Client tried to access missing scanner " + scannerName);
        throw new UnknownScannerException("Name: " + scannerName + ", already closed?");
      }
      scanner=rsh.s;
      HRegionInfo hri=scanner.getRegionInfo();
      region=regionServer.getRegion(hri.getRegionName());
      if (region != rsh.r) {
        throw new NotServingRegionException("Region was re-opened after the scanner" + scannerName + " was created: "+ hri.getRegionNameAsString());
      }
    }
 else {
      region=getRegion(request.getRegion());
      ClientProtos.Scan protoScan=request.getScan();
      boolean isLoadingCfsOnDemandSet=protoScan.hasLoadColumnFamiliesOnDemand();
      Scan scan=ProtobufUtil.toScan(protoScan);
      if (!isLoadingCfsOnDemandSet) {
        scan.setLoadColumnFamiliesOnDemand(region.isLoadingCfsOnDemandDefault());
      }
      isSmallScan=scan.isSmall();
      if (!scan.hasFamilies()) {
        for (        byte[] family : region.getTableDesc().getFamiliesKeys()) {
          scan.addFamily(family);
        }
      }
      if (region.getCoprocessorHost() != null) {
        scanner=region.getCoprocessorHost().preScannerOpen(scan);
      }
      if (scanner == null) {
        scanner=region.getScanner(scan);
      }
      if (region.getCoprocessorHost() != null) {
        scanner=region.getCoprocessorHost().postScannerOpen(scan,scanner);
      }
      scannerId=this.scannerIdGen.incrementAndGet();
      scannerName=String.valueOf(scannerId);
      rsh=addScanner(scannerName,scanner,region);
      ttl=this.scannerLeaseTimeoutPeriod;
    }
    RpcCallContext context=RpcServer.getCurrentCall();
    quota=getQuotaManager().checkQuota(region,OperationQuota.OperationType.SCAN);
    long maxQuotaResultSize=Math.min(maxScannerResultSize,quota.getReadAvailable());
    if (rows > 0) {
      if (request.hasNextCallSeq()) {
        if (rsh == null) {
          rsh=scanners.get(scannerName);
        }
        if (rsh != null) {
          if (request.getNextCallSeq() != rsh.getNextCallSeq()) {
            throw new OutOfOrderScannerNextException("Expected nextCallSeq: " + rsh.getNextCallSeq() + " But the nextCallSeq got from client: "+ request.getNextCallSeq()+ "; request="+ TextFormat.shortDebugString(request));
          }
          rsh.incNextCallSeq();
        }
      }
      try {
        lease=regionServer.leases.removeLease(scannerName);
        List<Result> results=new ArrayList<Result>();
        long totalCellSize=0;
        long currentScanResultSize=0;
        boolean done=false;
        if (region != null && region.getCoprocessorHost() != null) {
          Boolean bypass=region.getCoprocessorHost().preScannerNext(scanner,results,rows);
          if (!results.isEmpty()) {
            for (            Result r : results) {
              for (              Cell cell : r.rawCells()) {
                totalCellSize+=CellUtil.estimatedSerializedSizeOf(cell);
                currentScanResultSize+=CellUtil.estimatedHeapSizeOfWithoutTags(cell);
              }
            }
          }
          if (bypass != null && bypass.booleanValue()) {
            done=true;
          }
        }
        if (!done) {
          long maxResultSize=Math.min(scanner.getMaxResultSize(),maxQuotaResultSize);
          if (maxResultSize <= 0) {
            maxResultSize=maxQuotaResultSize;
          }
          List<Cell> values=new ArrayList<Cell>(32);
          region.startRegionOperation(Operation.SCAN);
          try {
            int i=0;
synchronized (scanner) {
              boolean stale=(region.getRegionInfo().getReplicaId() != 0);
              boolean clientHandlesPartials=request.hasClientHandlesPartials() && request.getClientHandlesPartials();
              boolean clientHandlesHeartbeats=request.hasClientHandlesHeartbeats() && request.getClientHandlesHeartbeats();
              boolean serverGuaranteesOrderOfPartials=currentScanResultSize == 0;
              boolean allowPartialResults=clientHandlesPartials && serverGuaranteesOrderOfPartials && !isSmallScan;
              boolean moreRows=false;
              boolean allowHeartbeatMessages=clientHandlesHeartbeats && allowPartialResults;
              long timeLimit=-1;
              if (allowHeartbeatMessages && (scannerLeaseTimeoutPeriod > 0 || rpcTimeout > 0)) {
                long timeLimitDelta;
                if (scannerLeaseTimeoutPeriod > 0 && rpcTimeout > 0) {
                  timeLimitDelta=Math.min(scannerLeaseTimeoutPeriod,rpcTimeout);
                }
 else {
                  timeLimitDelta=scannerLeaseTimeoutPeriod > 0 ? scannerLeaseTimeoutPeriod : rpcTimeout;
                }
                timeLimitDelta=Math.max(timeLimitDelta / 2,minimumScanTimeLimitDelta);
                timeLimit=System.currentTimeMillis() + timeLimitDelta;
              }
              final LimitScope sizeScope=allowPartialResults ? LimitScope.BETWEEN_CELLS : LimitScope.BETWEEN_ROWS;
              final LimitScope timeScope=allowHeartbeatMessages ? LimitScope.BETWEEN_CELLS : LimitScope.BETWEEN_ROWS;
              boolean trackMetrics=request.hasTrackScanMetrics() && request.getTrackScanMetrics();
              ScannerContext.Builder contextBuilder=ScannerContext.newBuilder(true);
              contextBuilder.setSizeLimit(sizeScope,maxResultSize);
              contextBuilder.setBatchLimit(scanner.getBatch());
              contextBuilder.setTimeLimit(timeScope,timeLimit);
              contextBuilder.setTrackMetrics(trackMetrics);
              ScannerContext scannerContext=contextBuilder.build();
              boolean limitReached=false;
              while (i < rows) {
                scannerContext.setBatchProgress(0);
                moreRows=scanner.nextRaw(values,scannerContext);
                if (!values.isEmpty()) {
                  for (                  Cell cell : values) {
                    totalCellSize+=CellUtil.estimatedSerializedSizeOf(cell);
                  }
                  final boolean partial=scannerContext.partialResultFormed();
                  results.add(Result.create(values,null,stale,partial));
                  i++;
                }
                boolean sizeLimitReached=scannerContext.checkSizeLimit(LimitScope.BETWEEN_ROWS);
                boolean timeLimitReached=scannerContext.checkTimeLimit(LimitScope.BETWEEN_ROWS);
                boolean rowLimitReached=i >= rows;
                limitReached=sizeLimitReached || timeLimitReached || rowLimitReached;
                if (limitReached || !moreRows) {
                  if (LOG.isTraceEnabled()) {
                    LOG.trace("Done scanning. limitReached: " + limitReached + " moreRows: "+ moreRows+ " scannerContext: "+ scannerContext);
                  }
                  if (moreRows) {
                    builder.setHeartbeatMessage(timeLimitReached);
                  }
                  break;
                }
                values.clear();
              }
              if (limitReached || moreRows) {
                builder.setMoreResultsInRegion(true);
              }
 else {
                builder.setMoreResultsInRegion(false);
              }
              if (trackMetrics) {
                Map<String,Long> metrics=scannerContext.getMetrics().getMetricsMap();
                ScanMetrics.Builder metricBuilder=ScanMetrics.newBuilder();
                NameInt64Pair.Builder pairBuilder=NameInt64Pair.newBuilder();
                for (                Entry<String,Long> entry : metrics.entrySet()) {
                  pairBuilder.setName(entry.getKey());
                  pairBuilder.setValue(entry.getValue());
                  metricBuilder.addMetrics(pairBuilder.build());
                }
                builder.setScanMetrics(metricBuilder.build());
              }
            }
            region.updateReadRequestsCount(i);
            region.getMetrics().updateScanNext(totalCellSize);
            if (regionServer.metricsRegionServer != null) {
              regionServer.metricsRegionServer.updateScannerNext(totalCellSize);
            }
          }
  finally {
            region.closeRegionOperation();
          }
          if (region != null && region.getCoprocessorHost() != null) {
            region.getCoprocessorHost().postScannerNext(scanner,results,rows,true);
          }
        }
        quota.addScanResult(results);
        if (scanner.isFilterDone() && results.isEmpty()) {
          moreResults=false;
          results=null;
        }
 else {
          addResults(builder,results,controller,RegionReplicaUtil.isDefaultReplica(region.getRegionInfo()),isClientCellBlockSupport(context));
        }
      }
 catch (      IOException e) {
        if (rsh != null && request.hasNextCallSeq()) {
          rsh.rollbackNextCallSeq();
        }
        throw e;
      }
 finally {
        if (context != null) {
          context.setCallBack(rsh.shippedCallback);
        }
        if (scanners.containsKey(scannerName)) {
          ttl=this.scannerLeaseTimeoutPeriod;
          if (context == null) {
            if (lease != null)             regionServer.leases.addLease(lease);
          }
        }
      }
    }
    if (!moreResults || closeScanner) {
      ttl=0;
      moreResults=false;
      if (region != null && region.getCoprocessorHost() != null) {
        if (region.getCoprocessorHost().preScannerClose(scanner)) {
          return builder.build();
        }
      }
      rsh=scanners.remove(scannerName);
      if (rsh != null) {
        if (context != null) {
          context.setCallBack(rsh.closeCallBack);
        }
 else {
          rsh.s.close();
        }
        try {
          regionServer.leases.cancelLease(scannerName);
        }
 catch (        LeaseException le) {
        }
        if (region != null && region.getCoprocessorHost() != null) {
          region.getCoprocessorHost().postScannerClose(scanner);
        }
      }
    }
    if (ttl > 0) {
      builder.setTtl(ttl);
    }
    builder.setScannerId(scannerId);
    builder.setMoreResults(moreResults);
    return builder.build();
  }
 catch (  IOException ie) {
    if (scannerName != null && ie instanceof NotServingRegionException) {
      RegionScannerHolder rsh=scanners.remove(scannerName);
      if (rsh != null) {
        try {
          RegionScanner scanner=rsh.s;
          LOG.warn(scannerName + " encountered " + ie.getMessage()+ ", closing ...");
          scanner.close();
          regionServer.leases.cancelLease(scannerName);
        }
 catch (        IOException e) {
          LOG.warn("Getting exception closing " + scannerName,e);
        }
      }
    }
    throw new ServiceException(ie);
  }
 finally {
    if (quota != null) {
      quota.close();
    }
  }
}
