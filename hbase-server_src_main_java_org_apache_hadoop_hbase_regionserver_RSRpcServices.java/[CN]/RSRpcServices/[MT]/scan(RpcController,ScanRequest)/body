{
  OperationQuota quota=null;
  Leases.Lease lease=null;
  String scannerName=null;
  try {
    if (!request.hasScannerId() && !request.hasScan()) {
      throw new DoNotRetryIOException("Missing required input: scannerId or scan");
    }
    long scannerId=-1;
    if (request.hasScannerId()) {
      scannerId=request.getScannerId();
      scannerName=String.valueOf(scannerId);
    }
    try {
      checkOpen();
    }
 catch (    IOException e) {
      if (scannerName != null) {
        try {
          regionServer.leases.cancelLease(scannerName);
        }
 catch (        LeaseException le) {
          LOG.info("Server shutting down and client tried to access missing scanner " + scannerName);
        }
      }
      throw e;
    }
    requestCount.increment();
    int ttl=0;
    HRegion region=null;
    RegionScanner scanner=null;
    RegionScannerHolder rsh=null;
    boolean moreResults=true;
    boolean closeScanner=false;
    ScanResponse.Builder builder=ScanResponse.newBuilder();
    if (request.hasCloseScanner()) {
      closeScanner=request.getCloseScanner();
    }
    int rows=closeScanner ? 0 : 1;
    if (request.hasNumberOfRows()) {
      rows=request.getNumberOfRows();
    }
    if (request.hasScannerId()) {
      rsh=scanners.get(scannerName);
      if (rsh == null) {
        LOG.info("Client tried to access missing scanner " + scannerName);
        throw new UnknownScannerException("Name: " + scannerName + ", already closed?");
      }
      scanner=rsh.s;
      HRegionInfo hri=scanner.getRegionInfo();
      region=regionServer.getRegion(hri.getRegionName());
      if (region != rsh.r) {
        throw new NotServingRegionException("Region was re-opened after the scanner" + scannerName + " was created: "+ hri.getRegionNameAsString());
      }
    }
 else {
      region=getRegion(request.getRegion());
      ClientProtos.Scan protoScan=request.getScan();
      boolean isLoadingCfsOnDemandSet=protoScan.hasLoadColumnFamiliesOnDemand();
      Scan scan=ProtobufUtil.toScan(protoScan);
      if (!isLoadingCfsOnDemandSet) {
        scan.setLoadColumnFamiliesOnDemand(region.isLoadingCfsOnDemandDefault());
      }
      scan.getAttribute(Scan.SCAN_ATTRIBUTES_METRICS_ENABLE);
      region.prepareScanner(scan);
      if (region.getCoprocessorHost() != null) {
        scanner=region.getCoprocessorHost().preScannerOpen(scan);
      }
      if (scanner == null) {
        scanner=region.getScanner(scan);
      }
      if (region.getCoprocessorHost() != null) {
        scanner=region.getCoprocessorHost().postScannerOpen(scan,scanner);
      }
      scannerId=addScanner(scanner,region);
      scannerName=String.valueOf(scannerId);
      ttl=this.scannerLeaseTimeoutPeriod;
    }
    quota=getQuotaManager().checkQuota(region,OperationQuota.OperationType.SCAN);
    long maxQuotaResultSize=Math.min(maxScannerResultSize,quota.getReadAvailable());
    if (rows > 0) {
      if (request.hasNextCallSeq()) {
        if (rsh == null) {
          rsh=scanners.get(scannerName);
        }
        if (rsh != null) {
          if (request.getNextCallSeq() != rsh.nextCallSeq) {
            throw new OutOfOrderScannerNextException("Expected nextCallSeq: " + rsh.nextCallSeq + " But the nextCallSeq got from client: "+ request.getNextCallSeq()+ "; request="+ TextFormat.shortDebugString(request));
          }
          rsh.nextCallSeq++;
        }
      }
      try {
        lease=regionServer.leases.removeLease(scannerName);
        List<Result> results=new ArrayList<Result>(rows);
        long currentScanResultSize=0;
        long totalKvSize=0;
        boolean done=false;
        if (region != null && region.getCoprocessorHost() != null) {
          Boolean bypass=region.getCoprocessorHost().preScannerNext(scanner,results,rows);
          if (!results.isEmpty()) {
            for (            Result r : results) {
              for (              Cell cell : r.rawCells()) {
                KeyValue kv=KeyValueUtil.ensureKeyValue(cell);
                currentScanResultSize+=kv.heapSize();
                totalKvSize+=kv.getLength();
              }
            }
          }
          if (bypass != null && bypass.booleanValue()) {
            done=true;
          }
        }
        if (!done) {
          long maxResultSize=Math.min(scanner.getMaxResultSize(),maxQuotaResultSize);
          if (maxResultSize <= 0) {
            maxResultSize=maxQuotaResultSize;
          }
          List<Cell> values=new ArrayList<Cell>();
          region.startRegionOperation(Operation.SCAN);
          try {
            int i=0;
synchronized (scanner) {
              boolean stale=(region.getRegionInfo().getReplicaId() != 0);
              while (i < rows) {
                if ((maxScannerResultSize < Long.MAX_VALUE) && (currentScanResultSize >= maxResultSize)) {
                  break;
                }
                boolean moreRows=scanner.nextRaw(values);
                if (!values.isEmpty()) {
                  for (                  Cell cell : values) {
                    KeyValue kv=KeyValueUtil.ensureKeyValue(cell);
                    currentScanResultSize+=kv.heapSize();
                    totalKvSize+=kv.getLength();
                  }
                  results.add(Result.create(values,null,stale));
                  i++;
                }
                if (!moreRows) {
                  break;
                }
                values.clear();
              }
            }
            region.readRequestsCount.add(i);
            region.getMetrics().updateScanNext(totalKvSize);
          }
  finally {
            region.closeRegionOperation();
          }
          if (region != null && region.getCoprocessorHost() != null) {
            region.getCoprocessorHost().postScannerNext(scanner,results,rows,true);
          }
        }
        quota.addScanResult(results);
        if (scanner.isFilterDone() && results.isEmpty()) {
          moreResults=false;
          results=null;
        }
 else {
          addResults(builder,results,controller,RegionReplicaUtil.isDefaultReplica(region.getRegionInfo()));
        }
      }
  finally {
        if (scanners.containsKey(scannerName)) {
          if (lease != null)           regionServer.leases.addLease(lease);
          ttl=this.scannerLeaseTimeoutPeriod;
        }
      }
    }
    if (!moreResults || closeScanner) {
      ttl=0;
      moreResults=false;
      if (region != null && region.getCoprocessorHost() != null) {
        if (region.getCoprocessorHost().preScannerClose(scanner)) {
          return builder.build();
        }
      }
      rsh=scanners.remove(scannerName);
      if (rsh != null) {
        scanner=rsh.s;
        scanner.close();
        regionServer.leases.cancelLease(scannerName);
        if (region != null && region.getCoprocessorHost() != null) {
          region.getCoprocessorHost().postScannerClose(scanner);
        }
      }
    }
    if (ttl > 0) {
      builder.setTtl(ttl);
    }
    builder.setScannerId(scannerId);
    builder.setMoreResults(moreResults);
    return builder.build();
  }
 catch (  IOException ie) {
    if (scannerName != null && ie instanceof NotServingRegionException) {
      RegionScannerHolder rsh=scanners.remove(scannerName);
      if (rsh != null) {
        try {
          RegionScanner scanner=rsh.s;
          scanner.close();
          regionServer.leases.cancelLease(scannerName);
        }
 catch (        IOException e) {
        }
      }
    }
    throw new ServiceException(ie);
  }
 finally {
    if (quota != null) {
      quota.close();
    }
  }
}
