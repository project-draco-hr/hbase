{
  OperationQuota quota=null;
  Leases.Lease lease=null;
  String scannerName=null;
  try {
    if (!request.hasScannerId() && !request.hasScan()) {
      throw new DoNotRetryIOException("Missing required input: scannerId or scan");
    }
    long scannerId=-1;
    if (request.hasScannerId()) {
      scannerId=request.getScannerId();
      scannerName=String.valueOf(scannerId);
    }
    try {
      checkOpen();
    }
 catch (    IOException e) {
      if (scannerName != null) {
        LOG.debug("Server shutting down and client tried to access missing scanner " + scannerName);
        if (regionServer.leases != null) {
          try {
            regionServer.leases.cancelLease(scannerName);
          }
 catch (          LeaseException le) {
          }
        }
      }
      throw e;
    }
    requestCount.increment();
    int ttl=0;
    Region region=null;
    RegionScanner scanner=null;
    RegionScannerHolder rsh=null;
    boolean moreResults=true;
    boolean closeScanner=false;
    boolean isSmallScan=false;
    ScanResponse.Builder builder=ScanResponse.newBuilder();
    if (request.hasCloseScanner()) {
      closeScanner=request.getCloseScanner();
    }
    int rows=closeScanner ? 0 : 1;
    if (request.hasNumberOfRows()) {
      rows=request.getNumberOfRows();
    }
    if (request.hasScannerId()) {
      rsh=scanners.get(scannerName);
      if (rsh == null) {
        LOG.info("Client tried to access missing scanner " + scannerName);
        throw new UnknownScannerException("Name: " + scannerName + ", already closed?");
      }
      scanner=rsh.s;
      HRegionInfo hri=scanner.getRegionInfo();
      region=regionServer.getRegion(hri.getRegionName());
      if (region != rsh.r) {
        throw new NotServingRegionException("Region was re-opened after the scanner" + scannerName + " was created: "+ hri.getRegionNameAsString());
      }
    }
 else {
      region=getRegion(request.getRegion());
      ClientProtos.Scan protoScan=request.getScan();
      boolean isLoadingCfsOnDemandSet=protoScan.hasLoadColumnFamiliesOnDemand();
      Scan scan=ProtobufUtil.toScan(protoScan);
      if (!isLoadingCfsOnDemandSet) {
        scan.setLoadColumnFamiliesOnDemand(region.isLoadingCfsOnDemandDefault());
      }
      isSmallScan=scan.isSmall();
      if (!scan.hasFamilies()) {
        for (        byte[] family : region.getTableDesc().getFamiliesKeys()) {
          scan.addFamily(family);
        }
      }
      if (region.getCoprocessorHost() != null) {
        scanner=region.getCoprocessorHost().preScannerOpen(scan);
      }
      if (scanner == null) {
        scanner=region.getScanner(scan);
      }
      if (region.getCoprocessorHost() != null) {
        scanner=region.getCoprocessorHost().postScannerOpen(scan,scanner);
      }
      scannerId=addScanner(scanner,region);
      scannerName=String.valueOf(scannerId);
      ttl=this.scannerLeaseTimeoutPeriod;
    }
    quota=getQuotaManager().checkQuota(region,OperationQuota.OperationType.SCAN);
    long maxQuotaResultSize=Math.min(maxScannerResultSize,quota.getReadAvailable());
    if (rows > 0) {
      if (request.hasNextCallSeq()) {
        if (rsh == null) {
          rsh=scanners.get(scannerName);
        }
        if (rsh != null) {
          if (request.getNextCallSeq() != rsh.nextCallSeq) {
            throw new OutOfOrderScannerNextException("Expected nextCallSeq: " + rsh.nextCallSeq + " But the nextCallSeq got from client: "+ request.getNextCallSeq()+ "; request="+ TextFormat.shortDebugString(request));
          }
          rsh.nextCallSeq++;
        }
      }
      try {
        lease=regionServer.leases.removeLease(scannerName);
        List<Result> results=new ArrayList<Result>();
        long totalCellSize=0;
        long currentScanResultSize=0;
        boolean done=false;
        if (region != null && region.getCoprocessorHost() != null) {
          Boolean bypass=region.getCoprocessorHost().preScannerNext(scanner,results,rows);
          if (!results.isEmpty()) {
            for (            Result r : results) {
              for (              Cell cell : r.rawCells()) {
                totalCellSize+=CellUtil.estimatedSerializedSizeOf(cell);
                currentScanResultSize+=CellUtil.estimatedHeapSizeOfWithoutTags(cell);
              }
            }
          }
          if (bypass != null && bypass.booleanValue()) {
            done=true;
          }
        }
        if (!done) {
          long maxResultSize=Math.min(scanner.getMaxResultSize(),maxQuotaResultSize);
          if (maxResultSize <= 0) {
            maxResultSize=maxQuotaResultSize;
          }
          List<Cell> values=new ArrayList<Cell>();
          region.startRegionOperation(Operation.SCAN);
          try {
            int i=0;
synchronized (scanner) {
              boolean stale=(region.getRegionInfo().getReplicaId() != 0);
              boolean clientHandlesPartials=request.hasClientHandlesPartials() && request.getClientHandlesPartials();
              boolean serverGuaranteesOrderOfPartials=currentScanResultSize == 0;
              boolean allowPartialResults=clientHandlesPartials && serverGuaranteesOrderOfPartials && !isSmallScan;
              boolean moreRows=false;
              final LimitScope sizeScope=allowPartialResults ? LimitScope.BETWEEN_CELLS : LimitScope.BETWEEN_ROWS;
              ScannerContext.Builder contextBuilder=ScannerContext.newBuilder(true);
              contextBuilder.setSizeLimit(sizeScope,maxResultSize);
              contextBuilder.setBatchLimit(scanner.getBatch());
              ScannerContext scannerContext=contextBuilder.build();
              while (i < rows) {
                if (scannerContext.checkSizeLimit(LimitScope.BETWEEN_ROWS)) {
                  builder.setMoreResultsInRegion(true);
                  break;
                }
                scannerContext.setBatchProgress(0);
                moreRows=scanner.nextRaw(values,scannerContext);
                if (!values.isEmpty()) {
                  for (                  Cell cell : values) {
                    totalCellSize+=CellUtil.estimatedSerializedSizeOf(cell);
                  }
                  final boolean partial=scannerContext.partialResultFormed();
                  results.add(Result.create(values,null,stale,partial));
                  i++;
                }
                if (!moreRows) {
                  break;
                }
                values.clear();
              }
              if (scannerContext.checkSizeLimit(LimitScope.BETWEEN_ROWS) || i >= rows || moreRows) {
                builder.setMoreResultsInRegion(true);
              }
 else {
                builder.setMoreResultsInRegion(false);
              }
            }
            region.updateReadRequestsCount(i);
            region.getMetrics().updateScanNext(totalCellSize);
            if (regionServer.metricsRegionServer != null) {
              regionServer.metricsRegionServer.updateScannerNext(totalCellSize);
            }
          }
  finally {
            region.closeRegionOperation();
          }
          if (region != null && region.getCoprocessorHost() != null) {
            region.getCoprocessorHost().postScannerNext(scanner,results,rows,true);
          }
        }
        quota.addScanResult(results);
        if (scanner.isFilterDone() && results.isEmpty()) {
          moreResults=false;
          results=null;
        }
 else {
          addResults(builder,results,controller,RegionReplicaUtil.isDefaultReplica(region.getRegionInfo()));
        }
      }
  finally {
        if (scanners.containsKey(scannerName)) {
          if (lease != null)           regionServer.leases.addLease(lease);
          ttl=this.scannerLeaseTimeoutPeriod;
        }
      }
    }
    if (!moreResults || closeScanner) {
      ttl=0;
      moreResults=false;
      if (region != null && region.getCoprocessorHost() != null) {
        if (region.getCoprocessorHost().preScannerClose(scanner)) {
          return builder.build();
        }
      }
      rsh=scanners.remove(scannerName);
      if (rsh != null) {
        scanner=rsh.s;
        scanner.close();
        regionServer.leases.cancelLease(scannerName);
        if (region != null && region.getCoprocessorHost() != null) {
          region.getCoprocessorHost().postScannerClose(scanner);
        }
      }
    }
    if (ttl > 0) {
      builder.setTtl(ttl);
    }
    builder.setScannerId(scannerId);
    builder.setMoreResults(moreResults);
    return builder.build();
  }
 catch (  IOException ie) {
    if (scannerName != null && ie instanceof NotServingRegionException) {
      RegionScannerHolder rsh=scanners.remove(scannerName);
      if (rsh != null) {
        try {
          RegionScanner scanner=rsh.s;
          LOG.warn(scannerName + " encountered " + ie.getMessage()+ ", closing ...");
          scanner.close();
          regionServer.leases.cancelLease(scannerName);
        }
 catch (        IOException e) {
          LOG.warn("Getting exception closing " + scannerName,e);
        }
      }
    }
    throw new ServiceException(ie);
  }
 finally {
    if (quota != null) {
      quota.close();
    }
  }
}
