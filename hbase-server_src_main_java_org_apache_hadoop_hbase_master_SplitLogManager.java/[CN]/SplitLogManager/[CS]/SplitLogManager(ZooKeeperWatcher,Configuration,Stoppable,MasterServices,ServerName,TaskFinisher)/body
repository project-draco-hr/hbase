{
  super(zkw);
  this.taskFinisher=tf;
  this.conf=conf;
  this.stopper=stopper;
  this.master=master;
  this.zkretries=conf.getLong("hbase.splitlog.zk.retries",DEFAULT_ZK_RETRIES);
  this.resubmit_threshold=conf.getLong("hbase.splitlog.max.resubmit",DEFAULT_MAX_RESUBMIT);
  this.timeout=conf.getInt("hbase.splitlog.manager.timeout",DEFAULT_TIMEOUT);
  this.unassignedTimeout=conf.getInt("hbase.splitlog.manager.unassigned.timeout",DEFAULT_UNASSIGNED_TIMEOUT);
  setRecoveryMode(true);
  LOG.info("Timeout=" + timeout + ", unassigned timeout="+ unassignedTimeout+ ", distributedLogReplay="+ (this.recoveryMode == RecoveryMode.LOG_REPLAY));
  this.serverName=serverName;
  this.timeoutMonitor=new TimeoutMonitor(conf.getInt("hbase.splitlog.manager.timeoutmonitor.period",1000),stopper);
  this.failedDeletions=Collections.synchronizedSet(new HashSet<String>());
  Threads.setDaemonThreadRunning(timeoutMonitor.getThread(),serverName + ".splitLogManagerTimeoutMonitor");
  if (this.watcher != null) {
    this.watcher.registerListener(this);
    lookForOrphans();
  }
}
