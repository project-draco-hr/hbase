{
  super(zkw);
  this.taskFinisher=tf;
  this.conf=conf;
  this.stopper=stopper;
  this.master=master;
  this.zkretries=conf.getLong("hbase.splitlog.zk.retries",DEFAULT_ZK_RETRIES);
  this.resubmit_threshold=conf.getLong("hbase.splitlog.max.resubmit",DEFAULT_MAX_RESUBMIT);
  this.timeout=conf.getInt("hbase.splitlog.manager.timeout",DEFAULT_TIMEOUT);
  this.unassignedTimeout=conf.getInt("hbase.splitlog.manager.unassigned.timeout",DEFAULT_UNASSIGNED_TIMEOUT);
  LOG.info("timeout=" + timeout + ", unassigned timeout="+ unassignedTimeout);
  this.serverName=serverName;
  this.timeoutMonitor=new TimeoutMonitor(conf.getInt("hbase.splitlog.manager.timeoutmonitor.period",1000),stopper);
  this.failedDeletions=Collections.synchronizedSet(new HashSet<String>());
  this.distributedLogReplay=this.conf.getBoolean(HConstants.DISTRIBUTED_LOG_REPLAY_KEY,HConstants.DEFAULT_DISTRIBUTED_LOG_REPLAY_CONFIG);
  LOG.info("distributedLogReplay = " + this.distributedLogReplay);
  if (!masterRecovery) {
    Threads.setDaemonThreadRunning(timeoutMonitor.getThread(),serverName + ".splitLogManagerTimeoutMonitor");
  }
  if (this.watcher != null) {
    this.watcher.registerListener(this);
    lookForOrphans();
  }
}
