{
  byte[] startRow=HConstants.EMPTY_START_ROW;
  byte[] stopRow=HConstants.EMPTY_END_ROW;
  if (proto.hasStartRow()) {
    startRow=proto.getStartRow().toByteArray();
  }
  if (proto.hasStopRow()) {
    stopRow=proto.getStopRow().toByteArray();
  }
  Scan scan=new Scan(startRow,stopRow);
  if (proto.hasCacheBlocks()) {
    scan.setCacheBlocks(proto.getCacheBlocks());
  }
  if (proto.hasMaxVersions()) {
    scan.setMaxVersions(proto.getMaxVersions());
  }
  if (proto.hasStoreLimit()) {
    scan.setMaxResultsPerColumnFamily(proto.getStoreLimit());
  }
  if (proto.hasStoreOffset()) {
    scan.setRowOffsetPerColumnFamily(proto.getStoreOffset());
  }
  if (proto.hasTimeRange()) {
    HBaseProtos.TimeRange timeRange=proto.getTimeRange();
    long minStamp=0;
    long maxStamp=Long.MAX_VALUE;
    if (timeRange.hasFrom()) {
      minStamp=timeRange.getFrom();
    }
    if (timeRange.hasTo()) {
      maxStamp=timeRange.getTo();
    }
    scan.setTimeRange(minStamp,maxStamp);
  }
  if (proto.hasFilter()) {
    HBaseProtos.Filter filter=proto.getFilter();
    scan.setFilter(ProtobufUtil.toFilter(filter));
  }
  if (proto.hasBatchSize()) {
    scan.setBatch(proto.getBatchSize());
  }
  if (proto.hasMaxResultSize()) {
    scan.setMaxResultSize(proto.getMaxResultSize());
  }
  for (  NameBytesPair attribute : proto.getAttributeList()) {
    scan.setAttribute(attribute.getName(),attribute.getValue().toByteArray());
  }
  if (proto.getColumnCount() > 0) {
    TreeMap<byte[],NavigableSet<byte[]>> familyMap=new TreeMap<byte[],NavigableSet<byte[]>>(Bytes.BYTES_COMPARATOR);
    for (    Column column : proto.getColumnList()) {
      byte[] family=column.getFamily().toByteArray();
      TreeSet<byte[]> set=new TreeSet<byte[]>(Bytes.BYTES_COMPARATOR);
      for (      ByteString qualifier : column.getQualifierList()) {
        set.add(qualifier.toByteArray());
      }
      familyMap.put(family,set);
    }
    scan.setFamilyMap(familyMap);
  }
  return scan;
}
