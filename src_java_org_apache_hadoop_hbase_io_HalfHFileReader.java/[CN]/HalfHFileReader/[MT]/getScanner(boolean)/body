{
  final HFileScanner s=super.getScanner(cacheBlocks);
  return new HFileScanner(){
    final HFileScanner delegate=s;
    public boolean atEnd=false;
    public ByteBuffer getKey(){
      if (atEnd)       return null;
      return delegate.getKey();
    }
    public String getKeyString(){
      if (atEnd)       return null;
      return delegate.getKeyString();
    }
    public ByteBuffer getValue(){
      if (atEnd)       return null;
      return delegate.getValue();
    }
    public String getValueString(){
      if (atEnd)       return null;
      return delegate.getValueString();
    }
    public KeyValue getKeyValue(){
      if (atEnd)       return null;
      return delegate.getKeyValue();
    }
    public boolean next() throws IOException {
      if (atEnd)       return false;
      boolean b=delegate.next();
      if (!b) {
        return b;
      }
      if (!top) {
        ByteBuffer bb=getKey();
        if (getComparator().compare(bb.array(),bb.arrayOffset(),bb.limit(),splitkey,0,splitkey.length) >= 0) {
          atEnd=true;
          return false;
        }
      }
      return true;
    }
    public boolean seekBefore(    byte[] key) throws IOException {
      return seekBefore(key,0,key.length);
    }
    public boolean seekBefore(    byte[] key,    int offset,    int length) throws IOException {
      if (top) {
        if (getComparator().compare(key,offset,length,splitkey,0,splitkey.length) < 0) {
          return false;
        }
      }
 else {
        if (getComparator().compare(key,offset,length,splitkey,0,splitkey.length) >= 0) {
          return seekBefore(splitkey,0,splitkey.length);
        }
      }
      return this.delegate.seekBefore(key,offset,length);
    }
    public boolean seekTo() throws IOException {
      if (top) {
        int r=this.delegate.seekTo(splitkey);
        if (r < 0) {
          return this.delegate.seekTo();
        }
        if (r > 0) {
          return this.delegate.next();
        }
        return true;
      }
      boolean b=delegate.seekTo();
      if (!b) {
        return b;
      }
      ByteBuffer k=this.delegate.getKey();
      return this.delegate.getReader().getComparator().compare(k.array(),k.arrayOffset(),k.limit(),splitkey,0,splitkey.length) < 0;
    }
    public int seekTo(    byte[] key) throws IOException {
      return seekTo(key,0,key.length);
    }
    public int seekTo(    byte[] key,    int offset,    int length) throws IOException {
      if (top) {
        if (getComparator().compare(key,offset,length,splitkey,0,splitkey.length) < 0) {
          return -1;
        }
      }
 else {
        if (getComparator().compare(key,offset,length,splitkey,0,splitkey.length) >= 0) {
          boolean res=delegate.seekBefore(splitkey,0,splitkey.length);
          if (!res) {
            throw new IOException("Seeking for a key in bottom of file, but key exists in top of file, failed on seekBefore(midkey)");
          }
          return 1;
        }
      }
      return delegate.seekTo(key,offset,length);
    }
    public Reader getReader(){
      return this.delegate.getReader();
    }
    public boolean isSeeked(){
      return this.delegate.isSeeked();
    }
  }
;
}
