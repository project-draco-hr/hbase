{
  byte[] midkey=f.createReader().midkey();
  KeyValue midKV=KeyValue.createKeyValueFromKey(midkey);
  byte[] midRow=midKV.getRow();
  Path topDir=HStore.getStoreHomedir(this.testDir,"1",Bytes.toBytes(f.getPath().getParent().getName()));
  if (this.fs.exists(topDir)) {
    this.fs.delete(topDir,true);
  }
  Path topPath=StoreFile.split(this.fs,topDir,f,midRow,true);
  Path bottomDir=HStore.getStoreHomedir(this.testDir,"2",Bytes.toBytes(f.getPath().getParent().getName()));
  if (this.fs.exists(bottomDir)) {
    this.fs.delete(bottomDir,true);
  }
  Path bottomPath=StoreFile.split(this.fs,bottomDir,f,midRow,false);
  StoreFile.Reader top=new StoreFile(this.fs,topPath,conf,cacheConf,BloomType.NONE,NoOpDataBlockEncoder.INSTANCE).createReader();
  StoreFile.Reader bottom=new StoreFile(this.fs,bottomPath,conf,cacheConf,BloomType.NONE,NoOpDataBlockEncoder.INSTANCE).createReader();
  ByteBuffer previous=null;
  LOG.info("Midkey: " + midKV.toString());
  ByteBuffer bbMidkeyBytes=ByteBuffer.wrap(midkey);
  try {
    boolean first=true;
    ByteBuffer key=null;
    HFileScanner topScanner=top.getScanner(false,false);
    while ((!topScanner.isSeeked() && topScanner.seekTo()) || (topScanner.isSeeked() && topScanner.next())) {
      key=topScanner.getKey();
      if (topScanner.getReader().getComparator().compare(key.array(),key.arrayOffset(),key.limit(),midkey,0,midkey.length) < 0) {
        fail("key=" + Bytes.toStringBinary(key) + " < midkey="+ Bytes.toStringBinary(midkey));
      }
      if (first) {
        first=false;
        LOG.info("First in top: " + Bytes.toString(Bytes.toBytes(key)));
      }
    }
    LOG.info("Last in top: " + Bytes.toString(Bytes.toBytes(key)));
    first=true;
    HFileScanner bottomScanner=bottom.getScanner(false,false);
    while ((!bottomScanner.isSeeked() && bottomScanner.seekTo()) || bottomScanner.next()) {
      previous=bottomScanner.getKey();
      key=bottomScanner.getKey();
      if (first) {
        first=false;
        LOG.info("First in bottom: " + Bytes.toString(Bytes.toBytes(previous)));
      }
      assertTrue(key.compareTo(bbMidkeyBytes) < 0);
    }
    if (previous != null) {
      LOG.info("Last in bottom: " + Bytes.toString(Bytes.toBytes(previous)));
    }
    this.fs.delete(topPath,false);
    this.fs.delete(bottomPath,false);
    byte[] badmidkey=Bytes.toBytes("  .");
    topPath=StoreFile.split(this.fs,topDir,f,badmidkey,true);
    bottomPath=StoreFile.split(this.fs,bottomDir,f,badmidkey,false);
    top=new StoreFile(this.fs,topPath,conf,cacheConf,BloomType.NONE,NoOpDataBlockEncoder.INSTANCE).createReader();
    bottom=new StoreFile(this.fs,bottomPath,conf,cacheConf,BloomType.NONE,NoOpDataBlockEncoder.INSTANCE).createReader();
    bottomScanner=bottom.getScanner(false,false);
    int count=0;
    while ((!bottomScanner.isSeeked() && bottomScanner.seekTo()) || bottomScanner.next()) {
      count++;
    }
    assertTrue(count == 0);
    first=true;
    topScanner=top.getScanner(false,false);
    while ((!topScanner.isSeeked() && topScanner.seekTo()) || topScanner.next()) {
      key=topScanner.getKey();
      assertTrue(topScanner.getReader().getComparator().compare(key.array(),key.arrayOffset(),key.limit(),badmidkey,0,badmidkey.length) >= 0);
      if (first) {
        first=false;
        KeyValue keyKV=KeyValue.createKeyValueFromKey(key);
        LOG.info("First top when key < bottom: " + keyKV);
        String tmp=Bytes.toString(keyKV.getRow());
        for (int i=0; i < tmp.length(); i++) {
          assertTrue(tmp.charAt(i) == 'a');
        }
      }
    }
    KeyValue keyKV=KeyValue.createKeyValueFromKey(key);
    LOG.info("Last top when key < bottom: " + keyKV);
    String tmp=Bytes.toString(keyKV.getRow());
    for (int i=0; i < tmp.length(); i++) {
      assertTrue(tmp.charAt(i) == 'z');
    }
    this.fs.delete(topPath,false);
    this.fs.delete(bottomPath,false);
    badmidkey=Bytes.toBytes("|||");
    topPath=StoreFile.split(this.fs,topDir,f,badmidkey,true);
    bottomPath=StoreFile.split(this.fs,bottomDir,f,badmidkey,false);
    top=new StoreFile(this.fs,topPath,conf,cacheConf,BloomType.NONE,NoOpDataBlockEncoder.INSTANCE).createReader();
    bottom=new StoreFile(this.fs,bottomPath,conf,cacheConf,BloomType.NONE,NoOpDataBlockEncoder.INSTANCE).createReader();
    first=true;
    bottomScanner=bottom.getScanner(false,false);
    while ((!bottomScanner.isSeeked() && bottomScanner.seekTo()) || bottomScanner.next()) {
      key=bottomScanner.getKey();
      if (first) {
        first=false;
        keyKV=KeyValue.createKeyValueFromKey(key);
        LOG.info("First bottom when key > top: " + keyKV);
        tmp=Bytes.toString(keyKV.getRow());
        for (int i=0; i < tmp.length(); i++) {
          assertTrue(tmp.charAt(i) == 'a');
        }
      }
    }
    keyKV=KeyValue.createKeyValueFromKey(key);
    LOG.info("Last bottom when key > top: " + keyKV);
    for (int i=0; i < tmp.length(); i++) {
      assertTrue(Bytes.toString(keyKV.getRow()).charAt(i) == 'z');
    }
    count=0;
    topScanner=top.getScanner(false,false);
    while ((!topScanner.isSeeked() && topScanner.seekTo()) || (topScanner.isSeeked() && topScanner.next())) {
      count++;
    }
    assertTrue(count == 0);
  }
  finally {
    if (top != null) {
      top.close(true);
    }
    if (bottom != null) {
      bottom.close(true);
    }
    fs.delete(f.getPath(),true);
  }
}
