{
  Encryption.Context cryptoContext=Encryption.Context.NONE;
  String cipherName=family.getEncryptionType();
  if (cipherName != null) {
    Cipher cipher;
    Key key;
    byte[] keyBytes=family.getEncryptionKey();
    if (keyBytes != null) {
      String masterKeyName=conf.get(HConstants.CRYPTO_MASTERKEY_NAME_CONF_KEY,User.getCurrent().getShortName());
      try {
        key=EncryptionUtil.unwrapKey(conf,masterKeyName,keyBytes);
      }
 catch (      KeyException e) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Unable to unwrap key with current master key '" + masterKeyName + "'");
        }
        String alternateKeyName=conf.get(HConstants.CRYPTO_MASTERKEY_ALTERNATE_NAME_CONF_KEY);
        if (alternateKeyName != null) {
          try {
            key=EncryptionUtil.unwrapKey(conf,alternateKeyName,keyBytes);
          }
 catch (          KeyException ex) {
            throw new IOException(ex);
          }
        }
 else {
          throw new IOException(e);
        }
      }
      cipher=Encryption.getCipher(conf,key.getAlgorithm());
      if (cipher == null) {
        throw new RuntimeException("Cipher '" + key.getAlgorithm() + "' is not available");
      }
      if (!cipher.getName().equalsIgnoreCase(cipherName)) {
        throw new RuntimeException("Encryption for family '" + family.getNameAsString() + "' configured with type '"+ cipherName+ "' but key specifies algorithm '"+ cipher.getName()+ "'");
      }
    }
 else {
      cipher=Encryption.getCipher(conf,cipherName);
      if (cipher == null) {
        throw new RuntimeException("Cipher '" + cipherName + "' is not available");
      }
      key=cipher.getRandomKey();
    }
    cryptoContext=Encryption.newContext(conf);
    cryptoContext.setCipher(cipher);
    cryptoContext.setKey(key);
  }
  return cryptoContext;
}
