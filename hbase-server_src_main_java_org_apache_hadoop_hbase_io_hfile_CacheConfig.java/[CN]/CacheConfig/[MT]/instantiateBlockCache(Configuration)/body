{
  if (GLOBAL_BLOCK_CACHE_INSTANCE != null)   return GLOBAL_BLOCK_CACHE_INSTANCE;
  if (blockCacheDisabled)   return null;
  float cachePercentage=conf.getFloat(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY,HConstants.HFILE_BLOCK_CACHE_SIZE_DEFAULT);
  if (cachePercentage == 0L) {
    blockCacheDisabled=true;
    return null;
  }
  if (cachePercentage > 1.0) {
    throw new IllegalArgumentException(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY + " must be between 0.0 and 1.0, and not > 1.0");
  }
  MemoryUsage mu=ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();
  long lruCacheSize=(long)(mu.getMax() * cachePercentage);
  int blockSize=conf.getInt("hbase.offheapcache.minblocksize",HConstants.DEFAULT_BLOCKSIZE);
  long slabCacheOffHeapCacheSize=(long)(conf.getFloat(SLAB_CACHE_OFFHEAP_PERCENTAGE_KEY,(float)0) * DirectMemoryUtils.getDirectMemorySize());
  if (slabCacheOffHeapCacheSize <= 0) {
    String bucketCacheIOEngineName=conf.get(BUCKET_CACHE_IOENGINE_KEY,null);
    float bucketCachePercentage=conf.getFloat(BUCKET_CACHE_SIZE_KEY,0F);
    long bucketCacheSize=(long)(bucketCachePercentage < 1 ? mu.getMax() * bucketCachePercentage : bucketCachePercentage * 1024 * 1024);
    boolean combinedWithLru=conf.getBoolean(BUCKET_CACHE_COMBINED_KEY,DEFAULT_BUCKET_CACHE_COMBINED);
    BucketCache bucketCache=null;
    if (bucketCacheIOEngineName != null && bucketCacheSize > 0) {
      int writerThreads=conf.getInt(BUCKET_CACHE_WRITER_THREADS_KEY,DEFAULT_BUCKET_CACHE_WRITER_THREADS);
      int writerQueueLen=conf.getInt(BUCKET_CACHE_WRITER_QUEUE_KEY,DEFAULT_BUCKET_CACHE_WRITER_QUEUE);
      String persistentPath=conf.get(BUCKET_CACHE_PERSISTENT_PATH_KEY);
      float combinedPercentage=conf.getFloat(BUCKET_CACHE_COMBINED_PERCENTAGE_KEY,DEFAULT_BUCKET_CACHE_COMBINED_PERCENTAGE);
      if (combinedWithLru) {
        lruCacheSize=(long)((1 - combinedPercentage) * bucketCacheSize);
        bucketCacheSize=(long)(combinedPercentage * bucketCacheSize);
      }
      try {
        int ioErrorsTolerationDuration=conf.getInt("hbase.bucketcache.ioengine.errors.tolerated.duration",BucketCache.DEFAULT_ERROR_TOLERATION_DURATION);
        bucketCache=new BucketCache(bucketCacheIOEngineName,bucketCacheSize,blockSize,writerThreads,writerQueueLen,persistentPath,ioErrorsTolerationDuration);
      }
 catch (      IOException ioex) {
        LOG.error("Can't instantiate bucket cache",ioex);
        throw new RuntimeException(ioex);
      }
    }
    LOG.info("Allocating LruBlockCache size=" + StringUtils.byteDesc(lruCacheSize) + ", blockSize="+ StringUtils.byteDesc(blockSize));
    LruBlockCache lruCache=new LruBlockCache(lruCacheSize,blockSize);
    lruCache.setVictimCache(bucketCache);
    if (bucketCache != null && combinedWithLru) {
      GLOBAL_BLOCK_CACHE_INSTANCE=new CombinedBlockCache(lruCache,bucketCache);
    }
 else {
      GLOBAL_BLOCK_CACHE_INSTANCE=lruCache;
    }
  }
 else {
    GLOBAL_BLOCK_CACHE_INSTANCE=new DoubleBlockCache(lruCacheSize,slabCacheOffHeapCacheSize,blockSize,blockSize,conf);
  }
  return GLOBAL_BLOCK_CACHE_INSTANCE;
}
