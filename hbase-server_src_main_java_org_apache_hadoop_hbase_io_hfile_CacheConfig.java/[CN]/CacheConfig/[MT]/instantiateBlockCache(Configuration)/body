{
  if (globalBlockCache != null)   return globalBlockCache;
  if (blockCacheDisabled)   return null;
  float cachePercentage=conf.getFloat(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY,HConstants.HFILE_BLOCK_CACHE_SIZE_DEFAULT);
  if (cachePercentage == 0L) {
    blockCacheDisabled=true;
    return null;
  }
  if (cachePercentage > 1.0) {
    throw new IllegalArgumentException(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY + " must be between 0.0 and 1.0, and not > 1.0");
  }
  MemoryUsage mu=ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();
  long lruCacheSize=(long)(mu.getMax() * cachePercentage);
  int blockSize=conf.getInt("hbase.offheapcache.minblocksize",HConstants.DEFAULT_BLOCKSIZE);
  long offHeapCacheSize=(long)(conf.getFloat("hbase.offheapcache.percentage",(float)0) * DirectMemoryUtils.getDirectMemorySize());
  if (offHeapCacheSize <= 0) {
    String bucketCacheIOEngineName=conf.get(BUCKET_CACHE_IOENGINE_KEY,null);
    float bucketCachePercentage=conf.getFloat(BUCKET_CACHE_SIZE_KEY,0F);
    long bucketCacheSize=(long)(bucketCachePercentage < 1 ? mu.getMax() * bucketCachePercentage : bucketCachePercentage * 1024 * 1024);
    boolean combinedWithLru=conf.getBoolean(BUCKET_CACHE_COMBINED_KEY,DEFAULT_BUCKET_CACHE_COMBINED);
    BucketCache bucketCache=null;
    if (bucketCacheIOEngineName != null && bucketCacheSize > 0) {
      int writerThreads=conf.getInt(BUCKET_CACHE_WRITER_THREADS_KEY,DEFAULT_BUCKET_CACHE_WRITER_THREADS);
      int writerQueueLen=conf.getInt(BUCKET_CACHE_WRITER_QUEUE_KEY,DEFAULT_BUCKET_CACHE_WRITER_QUEUE);
      String persistentPath=conf.get(BUCKET_CACHE_PERSISTENT_PATH_KEY);
      float combinedPercentage=conf.getFloat(BUCKET_CACHE_COMBINED_PERCENTAGE_KEY,DEFAULT_BUCKET_CACHE_COMBINED_PERCENTAGE);
      if (combinedWithLru) {
        lruCacheSize=(long)((1 - combinedPercentage) * bucketCacheSize);
        bucketCacheSize=(long)(combinedPercentage * bucketCacheSize);
      }
      try {
        int ioErrorsTolerationDuration=conf.getInt("hbase.bucketcache.ioengine.errors.tolerated.duration",BucketCache.DEFAULT_ERROR_TOLERATION_DURATION);
        bucketCache=new BucketCache(bucketCacheIOEngineName,bucketCacheSize,blockSize,writerThreads,writerQueueLen,persistentPath,ioErrorsTolerationDuration);
      }
 catch (      IOException ioex) {
        LOG.error("Can't instantiate bucket cache",ioex);
        throw new RuntimeException(ioex);
      }
    }
    LOG.info("Allocating LruBlockCache with maximum size " + StringUtils.humanReadableInt(lruCacheSize));
    LruBlockCache lruCache=new LruBlockCache(lruCacheSize,blockSize);
    lruCache.setVictimCache(bucketCache);
    if (bucketCache != null && combinedWithLru) {
      globalBlockCache=new CombinedBlockCache(lruCache,bucketCache);
    }
 else {
      globalBlockCache=lruCache;
    }
  }
 else {
    globalBlockCache=new DoubleBlockCache(lruCacheSize,offHeapCacheSize,blockSize,blockSize,conf);
  }
  return globalBlockCache;
}
