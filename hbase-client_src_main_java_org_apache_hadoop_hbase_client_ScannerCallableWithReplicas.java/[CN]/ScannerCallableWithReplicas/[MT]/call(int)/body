{
  if (currentScannerCallable != null && currentScannerCallable.closed) {
    if (LOG.isTraceEnabled()) {
      LOG.trace("Closing scanner id=" + currentScannerCallable.scannerId);
    }
    Result[] r=currentScannerCallable.call(timeout);
    currentScannerCallable=null;
    return r;
  }
  RegionLocations rl=RpcRetryingCallerWithReadReplicas.getRegionLocations(true,RegionReplicaUtil.DEFAULT_REPLICA_ID,cConnection,tableName,currentScannerCallable.getRow());
  ResultBoundedCompletionService<Pair<Result[],ScannerCallable>> cs=new ResultBoundedCompletionService<Pair<Result[],ScannerCallable>>(RpcRetryingCallerFactory.instantiate(ScannerCallableWithReplicas.this.conf),pool,rl.size() * 5);
  AtomicBoolean done=new AtomicBoolean(false);
  replicaSwitched.set(false);
  addCallsForCurrentReplica(cs,rl);
  try {
    Future<Pair<Result[],ScannerCallable>> f=cs.poll(timeBeforeReplicas,TimeUnit.MICROSECONDS);
    if (f != null) {
      Pair<Result[],ScannerCallable> r=f.get(timeout,TimeUnit.MILLISECONDS);
      if (r != null && r.getSecond() != null) {
        updateCurrentlyServingReplica(r.getSecond(),r.getFirst(),done,pool);
      }
      return r == null ? null : r.getFirst();
    }
  }
 catch (  ExecutionException e) {
    RpcRetryingCallerWithReadReplicas.throwEnrichedException(e,retries);
  }
catch (  CancellationException e) {
    throw new InterruptedIOException(e.getMessage());
  }
catch (  InterruptedException e) {
    throw new InterruptedIOException(e.getMessage());
  }
catch (  TimeoutException e) {
    throw new InterruptedIOException(e.getMessage());
  }
  addCallsForOtherReplicas(cs,rl,0,rl.size() - 1);
  try {
    Future<Pair<Result[],ScannerCallable>> f=cs.poll(timeout,TimeUnit.MILLISECONDS);
    if (f != null) {
      Pair<Result[],ScannerCallable> r=f.get(timeout,TimeUnit.MILLISECONDS);
      if (r != null && r.getSecond() != null) {
        updateCurrentlyServingReplica(r.getSecond(),r.getFirst(),done,pool);
      }
      return r == null ? null : r.getFirst();
    }
  }
 catch (  ExecutionException e) {
    RpcRetryingCallerWithReadReplicas.throwEnrichedException(e,retries);
  }
catch (  CancellationException e) {
    throw new InterruptedIOException(e.getMessage());
  }
catch (  InterruptedException e) {
    throw new InterruptedIOException(e.getMessage());
  }
catch (  TimeoutException e) {
    throw new InterruptedIOException(e.getMessage());
  }
 finally {
    cs.cancelAll();
  }
  return null;
}
