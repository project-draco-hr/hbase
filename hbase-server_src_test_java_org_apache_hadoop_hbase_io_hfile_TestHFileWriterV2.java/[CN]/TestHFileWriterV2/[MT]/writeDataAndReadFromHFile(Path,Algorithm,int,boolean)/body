{
  HFileContext context=new HFileContextBuilder().withBlockSize(4096).withCompression(compressAlgo).build();
  HFile.Writer writer=new HFileWriterFactory(conf,new CacheConfig(conf)).withPath(fs,hfilePath).withFileContext(context).create();
  Random rand=new Random(9713312);
  List<KeyValue> keyValues=new ArrayList<KeyValue>(entryCount);
  for (int i=0; i < entryCount; ++i) {
    byte[] keyBytes=randomOrderedKey(rand,i);
    byte[] valueBytes=randomValue(rand);
    KeyValue keyValue=new KeyValue(keyBytes,null,null,valueBytes);
    writer.append(keyValue);
    keyValues.add(keyValue);
  }
  writer.appendMetaBlock("CAPITAL_OF_USA",new Text("Washington, D.C."));
  writer.appendMetaBlock("CAPITAL_OF_RUSSIA",new Text("Moscow"));
  writer.appendMetaBlock("CAPITAL_OF_FRANCE",new Text("Paris"));
  writer.close();
  FSDataInputStream fsdis=fs.open(hfilePath);
  long fileSize=fs.getFileStatus(hfilePath).getLen();
  FixedFileTrailer trailer=FixedFileTrailer.readFromStream(fsdis,fileSize);
  assertEquals(entryCount,trailer.getEntryCount());
  HFileContext meta=new HFileContextBuilder().withHBaseCheckSum(true).withIncludesMvcc(false).withIncludesTags(false).withCompression(compressAlgo).build();
  HFileBlock.FSReader blockReader=new HFileBlock.FSReaderImpl(fsdis,fileSize,meta);
  CellComparator comparator=trailer.createComparator();
  HFileBlockIndex.BlockIndexReader dataBlockIndexReader=new HFileBlockIndex.BlockIndexReader(comparator,trailer.getNumDataIndexLevels());
  HFileBlockIndex.BlockIndexReader metaBlockIndexReader=new HFileBlockIndex.BlockIndexReader(null,1);
  HFileBlock.BlockIterator blockIter=blockReader.blockRange(trailer.getLoadOnOpenDataOffset(),fileSize - trailer.getTrailerSize());
  dataBlockIndexReader.readMultiLevelIndexRoot(blockIter.nextBlockWithBlockType(BlockType.ROOT_INDEX),trailer.getDataIndexCount());
  if (findMidKey) {
    byte[] midkey=dataBlockIndexReader.midkey();
    assertNotNull("Midkey should not be null",midkey);
  }
  metaBlockIndexReader.readRootIndex(blockIter.nextBlockWithBlockType(BlockType.ROOT_INDEX).getByteStream(),trailer.getMetaIndexCount());
  FileInfo fileInfo=new FileInfo();
  fileInfo.read(blockIter.nextBlockWithBlockType(BlockType.FILE_INFO).getByteStream());
  byte[] keyValueFormatVersion=fileInfo.get(HFileWriterImpl.KEY_VALUE_VERSION);
  boolean includeMemstoreTS=keyValueFormatVersion != null && Bytes.toInt(keyValueFormatVersion) > 0;
  int entriesRead=0;
  int blocksRead=0;
  long memstoreTS=0;
  fsdis.seek(0);
  long curBlockPos=0;
  while (curBlockPos <= trailer.getLastDataBlockOffset()) {
    HFileBlock block=blockReader.readBlockData(curBlockPos,-1,-1,false);
    assertEquals(BlockType.DATA,block.getBlockType());
    if (meta.isCompressedOrEncrypted()) {
      assertFalse(block.isUnpacked());
      block=block.unpack(meta,blockReader);
    }
    ByteBuffer buf=block.getBufferWithoutHeader();
    while (buf.hasRemaining()) {
      int keyLen=buf.getInt();
      int valueLen=buf.getInt();
      byte[] key=new byte[keyLen];
      buf.get(key);
      byte[] value=new byte[valueLen];
      buf.get(value);
      if (includeMemstoreTS) {
        ByteArrayInputStream byte_input=new ByteArrayInputStream(buf.array(),buf.arrayOffset() + buf.position(),buf.remaining());
        DataInputStream data_input=new DataInputStream(byte_input);
        memstoreTS=WritableUtils.readVLong(data_input);
        buf.position(buf.position() + WritableUtils.getVIntSize(memstoreTS));
      }
      assertTrue(Bytes.compareTo(key,keyValues.get(entriesRead).getKey()) == 0);
      assertTrue(Bytes.compareTo(value,keyValues.get(entriesRead).getValue()) == 0);
      ++entriesRead;
    }
    ++blocksRead;
    curBlockPos+=block.getOnDiskSizeWithHeader();
  }
  LOG.info("Finished reading: entries=" + entriesRead + ", blocksRead="+ blocksRead);
  assertEquals(entryCount,entriesRead);
  int metaCounter=0;
  while (fsdis.getPos() < trailer.getLoadOnOpenDataOffset()) {
    LOG.info("Current offset: " + fsdis.getPos() + ", scanning until "+ trailer.getLoadOnOpenDataOffset());
    HFileBlock block=blockReader.readBlockData(curBlockPos,-1,-1,false).unpack(meta,blockReader);
    assertEquals(BlockType.META,block.getBlockType());
    Text t=new Text();
    ByteBuffer buf=block.getBufferWithoutHeader();
    if (Writables.getWritable(buf.array(),buf.arrayOffset(),buf.limit(),t) == null) {
      throw new IOException("Failed to deserialize block " + this + " into a "+ t.getClass().getSimpleName());
    }
    Text expectedText=(metaCounter == 0 ? new Text("Paris") : metaCounter == 1 ? new Text("Moscow") : new Text("Washington, D.C."));
    assertEquals(expectedText,t);
    LOG.info("Read meta block data: " + t);
    ++metaCounter;
    curBlockPos+=block.getOnDiskSizeWithHeader();
  }
  fsdis.close();
}
