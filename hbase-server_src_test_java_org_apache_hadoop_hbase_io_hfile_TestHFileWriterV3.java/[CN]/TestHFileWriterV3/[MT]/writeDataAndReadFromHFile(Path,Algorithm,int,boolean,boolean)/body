{
  HFileContext context=new HFileContextBuilder().withBlockSize(4096).withIncludesTags(useTags).withCompressionAlgo(compressAlgo).build();
  HFileWriterV3 writer=(HFileWriterV3)new HFileWriterV3.WriterFactoryV3(conf,new CacheConfig(conf)).withPath(fs,hfilePath).withFileContext(context).withComparator(KeyValue.COMPARATOR).create();
  Random rand=new Random(9713312);
  List<KeyValue> keyValues=new ArrayList<KeyValue>(entryCount);
  for (int i=0; i < entryCount; ++i) {
    byte[] keyBytes=TestHFileWriterV2.randomOrderedKey(rand,i);
    byte[] valueBytes=TestHFileWriterV2.randomValue(rand);
    KeyValue keyValue=null;
    if (useTags) {
      ArrayList<Tag> tags=new ArrayList<Tag>();
      for (int j=0; j < 1 + rand.nextInt(4); j++) {
        byte[] tagBytes=new byte[16];
        rand.nextBytes(tagBytes);
        tags.add(new Tag((byte)1,tagBytes));
      }
      keyValue=new KeyValue(keyBytes,null,null,HConstants.LATEST_TIMESTAMP,valueBytes,tags);
    }
 else {
      keyValue=new KeyValue(keyBytes,null,null,HConstants.LATEST_TIMESTAMP,valueBytes);
    }
    writer.append(keyValue);
    keyValues.add(keyValue);
  }
  writer.appendMetaBlock("CAPITAL_OF_USA",new Text("Washington, D.C."));
  writer.appendMetaBlock("CAPITAL_OF_RUSSIA",new Text("Moscow"));
  writer.appendMetaBlock("CAPITAL_OF_FRANCE",new Text("Paris"));
  writer.close();
  FSDataInputStream fsdis=fs.open(hfilePath);
  long fileSize=fs.getFileStatus(hfilePath).getLen();
  FixedFileTrailer trailer=FixedFileTrailer.readFromStream(fsdis,fileSize);
  assertEquals(3,trailer.getMajorVersion());
  assertEquals(entryCount,trailer.getEntryCount());
  HFileContext meta=new HFileContextBuilder().withCompressionAlgo(compressAlgo).withIncludesMvcc(false).withIncludesTags(useTags).withHBaseCheckSum(true).build();
  HFileBlock.FSReader blockReader=new HFileBlock.FSReaderV2(fsdis,fileSize,meta);
  KVComparator comparator=trailer.createComparator();
  HFileBlockIndex.BlockIndexReader dataBlockIndexReader=new HFileBlockIndex.BlockIndexReader(comparator,trailer.getNumDataIndexLevels());
  HFileBlockIndex.BlockIndexReader metaBlockIndexReader=new HFileBlockIndex.BlockIndexReader(KeyValue.RAW_COMPARATOR,1);
  HFileBlock.BlockIterator blockIter=blockReader.blockRange(trailer.getLoadOnOpenDataOffset(),fileSize - trailer.getTrailerSize());
  dataBlockIndexReader.readMultiLevelIndexRoot(blockIter.nextBlockWithBlockType(BlockType.ROOT_INDEX),trailer.getDataIndexCount());
  if (findMidKey) {
    byte[] midkey=dataBlockIndexReader.midkey();
    assertNotNull("Midkey should not be null",midkey);
  }
  metaBlockIndexReader.readRootIndex(blockIter.nextBlockWithBlockType(BlockType.ROOT_INDEX).getByteStream(),trailer.getMetaIndexCount());
  FileInfo fileInfo=new FileInfo();
  fileInfo.read(blockIter.nextBlockWithBlockType(BlockType.FILE_INFO).getByteStream());
  byte[] keyValueFormatVersion=fileInfo.get(HFileWriterV3.KEY_VALUE_VERSION);
  boolean includeMemstoreTS=keyValueFormatVersion != null && Bytes.toInt(keyValueFormatVersion) > 0;
  int entriesRead=0;
  int blocksRead=0;
  long memstoreTS=0;
  fsdis.seek(0);
  long curBlockPos=0;
  while (curBlockPos <= trailer.getLastDataBlockOffset()) {
    HFileBlock block=blockReader.readBlockData(curBlockPos,-1,-1,false);
    assertEquals(BlockType.DATA,block.getBlockType());
    ByteBuffer buf=block.getBufferWithoutHeader();
    int keyLen=-1;
    while (buf.hasRemaining()) {
      keyLen=buf.getInt();
      int valueLen=buf.getInt();
      byte[] key=new byte[keyLen];
      buf.get(key);
      byte[] value=new byte[valueLen];
      buf.get(value);
      byte[] tagValue=null;
      if (useTags) {
        int tagLen=buf.getShort();
        tagValue=new byte[tagLen];
        buf.get(tagValue);
      }
      if (includeMemstoreTS) {
        ByteArrayInputStream byte_input=new ByteArrayInputStream(buf.array(),buf.arrayOffset() + buf.position(),buf.remaining());
        DataInputStream data_input=new DataInputStream(byte_input);
        memstoreTS=WritableUtils.readVLong(data_input);
        buf.position(buf.position() + WritableUtils.getVIntSize(memstoreTS));
      }
      assertTrue(Bytes.compareTo(key,keyValues.get(entriesRead).getKey()) == 0);
      assertTrue(Bytes.compareTo(value,keyValues.get(entriesRead).getValue()) == 0);
      if (useTags) {
        assertNotNull(tagValue);
        KeyValue tkv=keyValues.get(entriesRead);
        assertEquals(tagValue.length,tkv.getTagsLength());
        assertTrue(Bytes.compareTo(tagValue,0,tagValue.length,tkv.getBuffer(),tkv.getTagsOffset(),tkv.getTagsLength()) == 0);
      }
      ++entriesRead;
    }
    ++blocksRead;
    curBlockPos+=block.getOnDiskSizeWithHeader();
  }
  LOG.info("Finished reading: entries=" + entriesRead + ", blocksRead="+ blocksRead);
  assertEquals(entryCount,entriesRead);
  int metaCounter=0;
  while (fsdis.getPos() < trailer.getLoadOnOpenDataOffset()) {
    LOG.info("Current offset: " + fsdis.getPos() + ", scanning until "+ trailer.getLoadOnOpenDataOffset());
    HFileBlock block=blockReader.readBlockData(curBlockPos,-1,-1,false);
    assertEquals(BlockType.META,block.getBlockType());
    Text t=new Text();
    ByteBuffer buf=block.getBufferWithoutHeader();
    if (Writables.getWritable(buf.array(),buf.arrayOffset(),buf.limit(),t) == null) {
      throw new IOException("Failed to deserialize block " + this + " into a "+ t.getClass().getSimpleName());
    }
    Text expectedText=(metaCounter == 0 ? new Text("Paris") : metaCounter == 1 ? new Text("Moscow") : new Text("Washington, D.C."));
    assertEquals(expectedText,t);
    LOG.info("Read meta block data: " + t);
    ++metaCounter;
    curBlockPos+=block.getOnDiskSizeWithHeader();
  }
  fsdis.close();
}
