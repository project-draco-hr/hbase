{
  SortedMap<HStoreKey,byte[]> headMap=map.headMap(search_key);
  if (headMap.isEmpty()) {
    return;
  }
  HStoreKey found_key=null;
  if (candidateKeys.isEmpty()) {
    Set<HStoreKey> keys=headMap.keySet();
    HStoreKey[] cells=keys.toArray(new HStoreKey[keys.size()]);
    byte[] lastRowFound=null;
    for (int i=cells.length - 1; i >= 0; i--) {
      HStoreKey thisKey=cells[i];
      boolean deleted=HLogEdit.isDeleted(headMap.get(thisKey));
      if (lastRowFound != null && !Bytes.equals(lastRowFound,thisKey.getRow()) && !deleted) {
        break;
      }
      if (!deleted) {
        if (ttl == HConstants.FOREVER || now < thisKey.getTimestamp() + ttl) {
          lastRowFound=thisKey.getRow();
          candidateKeys.put(stripTimestamp(thisKey),new Long(thisKey.getTimestamp()));
        }
 else {
          victims.add(found_key);
          if (LOG.isDebugEnabled()) {
            LOG.debug("getRowKeyBefore: " + found_key + ": expired, skipped");
          }
        }
      }
    }
  }
 else {
    SortedMap<HStoreKey,byte[]> thisRowTailMap=headMap.tailMap(new HStoreKey(headMap.lastKey().getRow()));
    Iterator<HStoreKey> key_iterator=thisRowTailMap.keySet().iterator();
    do {
      found_key=key_iterator.next();
      if (HLogEdit.isDeleted(thisRowTailMap.get(found_key))) {
        handleDeleted(found_key,candidateKeys);
      }
 else {
        if (ttl == HConstants.FOREVER || now < found_key.getTimestamp() + ttl) {
          candidateKeys.put(stripTimestamp(found_key),Long.valueOf(found_key.getTimestamp()));
        }
 else {
          victims.add(found_key);
          if (LOG.isDebugEnabled()) {
            LOG.debug("internalGetRowKeyAtOrBefore: " + found_key + ": expired, skipped");
          }
        }
      }
    }
 while (key_iterator.hasNext());
  }
}
