{
  SortedMap<HStoreKey,byte[]> headMap=map.headMap(search_key);
  if (headMap.isEmpty()) {
    return;
  }
  if (candidateKeys.isEmpty()) {
    Set<HStoreKey> keys=headMap.keySet();
    HStoreKey[] cells=keys.toArray(new HStoreKey[keys.size()]);
    byte[] lastRowFound=null;
    for (int i=cells.length - 1; i >= 0; i--) {
      HStoreKey found_key=cells[i];
      boolean deleted=HLogEdit.isDeleted(headMap.get(found_key));
      if (lastRowFound != null && !HStoreKey.equalsTwoRowKeys(regionInfo,lastRowFound,found_key.getRow()) && !deleted) {
        break;
      }
      if (!deleted) {
        if (HStore.notExpiredAndNotInDeletes(this.ttl,found_key,now,deletes)) {
          lastRowFound=found_key.getRow();
          candidateKeys.put(stripTimestamp(found_key),new Long(found_key.getTimestamp()));
        }
 else {
          expires.add(found_key);
          if (LOG.isDebugEnabled()) {
            LOG.debug("getRowKeyBefore: " + found_key + ": expired, skipped");
          }
        }
      }
 else {
        deletes.add(found_key);
      }
    }
  }
 else {
    SortedMap<HStoreKey,byte[]> thisRowTailMap=headMap.tailMap(new HStoreKey(headMap.lastKey().getRow(),this.regionInfo));
    Iterator<HStoreKey> key_iterator=thisRowTailMap.keySet().iterator();
    do {
      HStoreKey found_key=key_iterator.next();
      if (HLogEdit.isDeleted(thisRowTailMap.get(found_key))) {
        HStore.handleDeleted(found_key,candidateKeys,deletes);
      }
 else {
        if (ttl == HConstants.FOREVER || now < found_key.getTimestamp() + ttl || !deletes.contains(found_key)) {
          candidateKeys.put(stripTimestamp(found_key),Long.valueOf(found_key.getTimestamp()));
        }
 else {
          expires.add(found_key);
          if (LOG.isDebugEnabled()) {
            LOG.debug("internalGetRowKeyAtOrBefore: " + found_key + ": expired, skipped");
          }
        }
      }
    }
 while (key_iterator.hasNext());
  }
}
