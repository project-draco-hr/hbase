{
  if (!needsBalance(new ClusterLoadState(clusterState))) {
    return null;
  }
  long startTime=EnvironmentEdgeManager.currentTimeMillis();
  double currentCost, newCost, initCost;
  Cluster cluster=new Cluster(clusterState,loads,regionFinder);
  currentCost=newCost=initCost=computeCost(cluster);
  int computedMaxSteps=Math.min(this.maxSteps,(cluster.numRegions * this.stepsPerRegion));
  int step;
  for (step=0; step < computedMaxSteps; step++) {
    for (int leftServer=0; leftServer < cluster.numServers; leftServer++) {
      int rightServer=pickOtherServer(leftServer,cluster);
      if (rightServer < 0) {
        continue;
      }
      int lRegion=pickRandomRegion(cluster,leftServer,0);
      int rRegion=pickRandomRegion(cluster,rightServer,0.5);
      if (lRegion < 0 && rRegion < 0) {
        continue;
      }
      cluster.moveOrSwapRegion(leftServer,rightServer,lRegion,rRegion);
      newCost=computeCost(cluster);
      if (newCost < currentCost) {
        currentCost=newCost;
      }
 else {
        cluster.moveOrSwapRegion(leftServer,rightServer,rRegion,lRegion);
      }
    }
    if (EnvironmentEdgeManager.currentTimeMillis() - startTime > maxRunningTime) {
      break;
    }
  }
  long endTime=EnvironmentEdgeManager.currentTimeMillis();
  if (initCost > currentCost) {
    List<RegionPlan> plans=createRegionPlans(cluster);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Finished computing new load balance plan.  Computation took " + (endTime - startTime) + "ms to try "+ step+ " different iterations.  Found a solution that moves "+ plans.size()+ " regions; Going from a computed cost of "+ initCost+ " to a new cost of "+ currentCost);
    }
    return plans;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Could not find a better load balance plan.  Tried " + step + " different configurations in "+ (endTime - startTime)+ "ms, and did not find anything with a computed cost less than "+ initCost);
  }
  return null;
}
