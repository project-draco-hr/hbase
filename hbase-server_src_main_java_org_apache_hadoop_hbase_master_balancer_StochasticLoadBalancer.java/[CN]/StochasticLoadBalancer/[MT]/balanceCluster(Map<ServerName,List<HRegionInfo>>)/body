{
  List<RegionPlan> plans=balanceMasterRegions(clusterState);
  if (plans != null) {
    return plans;
  }
  filterExcludedServers(clusterState);
  Cluster cluster=new Cluster(masterServerName,clusterState,loads,regionFinder,getBackupMasters(),tablesOnMaster,rackManager);
  if (!needsBalance(cluster)) {
    return null;
  }
  long startTime=EnvironmentEdgeManager.currentTimeMillis();
  initCosts(cluster);
  double currentCost=computeCost(cluster,Double.MAX_VALUE);
  double initCost=currentCost;
  double newCost=currentCost;
  long computedMaxSteps=Math.min(this.maxSteps,((long)cluster.numRegions * (long)this.stepsPerRegion * (long)cluster.numServers));
  long step;
  for (step=0; step < computedMaxSteps; step++) {
    int generatorIdx=RANDOM.nextInt(candidateGenerators.length);
    CandidateGenerator p=candidateGenerators[generatorIdx];
    Cluster.Action action=p.generate(cluster);
    if (action.type == Type.NULL) {
      continue;
    }
    cluster.doAction(action);
    updateCostsWithAction(cluster,action);
    newCost=computeCost(cluster,currentCost);
    if (newCost < currentCost) {
      currentCost=newCost;
    }
 else {
      Action undoAction=action.undoAction();
      cluster.doAction(undoAction);
      updateCostsWithAction(cluster,undoAction);
    }
    if (EnvironmentEdgeManager.currentTimeMillis() - startTime > maxRunningTime) {
      break;
    }
  }
  long endTime=EnvironmentEdgeManager.currentTimeMillis();
  metricsBalancer.balanceCluster(endTime - startTime);
  if (initCost > currentCost) {
    plans=createRegionPlans(cluster);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Finished computing new load balance plan.  Computation took " + (endTime - startTime) + "ms to try "+ step+ " different iterations.  Found a solution that moves "+ plans.size()+ " regions; Going from a computed cost of "+ initCost+ " to a new cost of "+ currentCost);
    }
    return plans;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Could not find a better load balance plan.  Tried " + step + " different configurations in "+ (endTime - startTime)+ "ms, and did not find anything with a computed cost less than "+ initCost);
  }
  return null;
}
