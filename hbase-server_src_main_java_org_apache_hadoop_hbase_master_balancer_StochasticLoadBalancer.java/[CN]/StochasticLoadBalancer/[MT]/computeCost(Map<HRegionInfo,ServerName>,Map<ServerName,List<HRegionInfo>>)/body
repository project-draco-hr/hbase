{
  double moveCost=moveCostMultiplier * computeMoveCost(initialRegionMapping,clusterState);
  double regionCountSkewCost=loadMultiplier * computeSkewLoadCost(clusterState);
  double tableSkewCost=tableMultiplier * computeTableSkewLoadCost(clusterState);
  double localityCost=localityMultiplier * computeDataLocalityCost(initialRegionMapping,clusterState);
  double memstoreSizeCost=memStoreSizeMultiplier * computeRegionLoadCost(clusterState,RegionLoadCostType.MEMSTORE_SIZE);
  double storefileSizeCost=storeFileSizeMultiplier * computeRegionLoadCost(clusterState,RegionLoadCostType.STOREFILE_SIZE);
  double readRequestCost=readRequestMultiplier * computeRegionLoadCost(clusterState,RegionLoadCostType.READ_REQUEST);
  double writeRequestCost=writeRequestMultiplier * computeRegionLoadCost(clusterState,RegionLoadCostType.WRITE_REQUEST);
  double total=moveCost + regionCountSkewCost + tableSkewCost+ localityCost+ memstoreSizeCost+ storefileSizeCost+ readRequestCost+ writeRequestCost;
  LOG.trace("Computed weights for a potential balancing total = " + total + " moveCost = "+ moveCost+ " regionCountSkewCost = "+ regionCountSkewCost+ " tableSkewCost = "+ tableSkewCost+ " localityCost = "+ localityCost+ " memstoreSizeCost = "+ memstoreSizeCost+ " storefileSizeCost = "+ storefileSizeCost);
  return total;
}
