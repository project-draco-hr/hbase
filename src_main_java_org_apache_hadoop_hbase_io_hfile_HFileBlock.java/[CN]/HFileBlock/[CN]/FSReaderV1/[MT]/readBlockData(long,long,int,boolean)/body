{
  if (uncompressedSizeWithMagic <= 0) {
    throw new IOException("Invalid uncompressedSize=" + uncompressedSizeWithMagic + " for a version 1 block");
  }
  if (onDiskSizeWithMagic <= 0 || onDiskSizeWithMagic >= Integer.MAX_VALUE) {
    throw new IOException("Invalid onDiskSize=" + onDiskSizeWithMagic + " (maximum allowed: "+ Integer.MAX_VALUE+ ")");
  }
  int onDiskSize=(int)onDiskSizeWithMagic;
  if (uncompressedSizeWithMagic < MAGIC_LENGTH) {
    throw new IOException("Uncompressed size for a version 1 block is " + uncompressedSizeWithMagic + " but must be at least "+ MAGIC_LENGTH);
  }
  ByteBuffer buf=ByteBuffer.allocate(uncompressedSizeWithMagic + HEADER_DELTA);
  int onDiskSizeWithoutHeader;
  if (compressAlgo == Compression.Algorithm.NONE) {
    if (onDiskSize != uncompressedSizeWithMagic) {
      throw new IOException("onDiskSize=" + onDiskSize + " and uncompressedSize="+ uncompressedSizeWithMagic+ " must be equal for version 1 with no compression");
    }
    readAtOffset(istream,buf.array(),buf.arrayOffset() + HEADER_DELTA,onDiskSize,false,offset,pread);
    onDiskSizeWithoutHeader=uncompressedSizeWithMagic - MAGIC_LENGTH;
  }
 else {
    InputStream bufferedBoundedStream=createBufferedBoundedStream(offset,onDiskSize,pread);
    Compression.decompress(buf.array(),buf.arrayOffset() + HEADER_DELTA,bufferedBoundedStream,onDiskSize,uncompressedSizeWithMagic,this.compressAlgo);
    onDiskSizeWithoutHeader=onDiskSize;
  }
  BlockType newBlockType=BlockType.parse(buf.array(),buf.arrayOffset() + HEADER_DELTA,MAGIC_LENGTH);
  HFileBlock b=new HFileBlock(newBlockType,onDiskSizeWithoutHeader,uncompressedSizeWithMagic - MAGIC_LENGTH,-1L,buf,FILL_HEADER,offset,MemStore.NO_PERSISTENT_TS,0,0,ChecksumType.NULL.getCode(),onDiskSizeWithoutHeader + HEADER_SIZE_NO_CHECKSUM);
  return b;
}
