{
  long ts;
  if (timestamp == null) {
    ts=HConstants.LATEST_TIMESTAMP;
  }
 else {
    ts=timestamp;
  }
  byte[] row=deleteRow.get(0).getRow();
  Delete delete=new Delete(row,ts,null);
  if (deleteType == DeleteType.FAMILY) {
    Set<byte[]> families=new TreeSet<byte[]>(Bytes.BYTES_COMPARATOR);
    for (    KeyValue kv : deleteRow) {
      if (families.add(kv.getFamily())) {
        delete.deleteFamily(kv.getFamily(),ts);
      }
    }
  }
 else   if (deleteType == DeleteType.COLUMN) {
    Set<Column> columns=new HashSet<Column>();
    for (    KeyValue kv : deleteRow) {
      Column column=new Column(kv.getFamily(),kv.getQualifier());
      if (columns.add(column)) {
        delete.deleteColumns(column.family,column.qualifier,ts);
      }
    }
  }
 else   if (deleteType == DeleteType.VERSION) {
    int noOfVersionsToDelete=0;
    if (timestamp == null) {
      for (      KeyValue kv : deleteRow) {
        delete.deleteColumn(kv.getFamily(),kv.getQualifier(),kv.getTimestamp());
        noOfVersionsToDelete++;
      }
    }
 else {
      Set<Column> columns=new HashSet<Column>();
      for (      KeyValue kv : deleteRow) {
        Column column=new Column(kv.getFamily(),kv.getQualifier());
        if (columns.add(column)) {
          delete.deleteColumn(column.family,column.qualifier,ts);
          noOfVersionsToDelete++;
        }
      }
    }
    delete.setAttribute(NO_OF_VERSIONS_TO_DELETE,Bytes.toBytes(noOfVersionsToDelete));
  }
  return delete;
}
