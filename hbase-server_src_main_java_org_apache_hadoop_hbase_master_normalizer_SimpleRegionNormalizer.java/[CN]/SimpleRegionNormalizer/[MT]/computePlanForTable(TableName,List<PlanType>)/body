{
  if (table == null || table.isSystemTable()) {
    LOG.debug("Normalization of system table " + table + " isn't allowed");
    return EmptyNormalizationPlan.getInstance();
  }
  List<HRegionInfo> tableRegions=masterServices.getAssignmentManager().getRegionStates().getRegionsOfTable(table);
  if (tableRegions == null || tableRegions.size() < MIN_REGION_COUNT) {
    int nrRegions=tableRegions == null ? 0 : tableRegions.size();
    LOG.debug("Table " + table + " has "+ nrRegions+ " regions, required min number"+ " of regions for normalizer to run is "+ MIN_REGION_COUNT+ ", not running normalizer");
    return EmptyNormalizationPlan.getInstance();
  }
  LOG.debug("Computing normalization plan for table: " + table + ", number of regions: "+ tableRegions.size());
  long totalSizeMb=0;
  ArrayList<Triple<HRegionInfo,Long,Integer>> regionsWithSize=new ArrayList<Triple<HRegionInfo,Long,Integer>>(tableRegions.size());
  for (int i=0; i < tableRegions.size(); i++) {
    HRegionInfo hri=tableRegions.get(i);
    long regionSize=getRegionSize(hri);
    regionsWithSize.add(new Triple<HRegionInfo,Long,Integer>(hri,regionSize,i));
    totalSizeMb+=regionSize;
  }
  Collections.sort(regionsWithSize,regionSizeComparator);
  Triple<HRegionInfo,Long,Integer> largestRegion=regionsWithSize.get(tableRegions.size() - 1);
  double avgRegionSize=totalSizeMb / (double)tableRegions.size();
  LOG.debug("Table " + table + ", total aggregated regions size: "+ totalSizeMb);
  LOG.debug("Table " + table + ", average region size: "+ avgRegionSize);
  if (types.contains(PlanType.SPLIT) && largestRegion.getSecond() > 2 * avgRegionSize) {
    LOG.debug("Table " + table + ", largest region "+ largestRegion.getFirst().getRegionNameAsString()+ " has size "+ largestRegion.getSecond()+ ", more than 2 times than avg size, splitting");
    return new SplitNormalizationPlan(largestRegion.getFirst(),null);
  }
  int candidateIdx=0;
  while (candidateIdx < tableRegions.size() - 1) {
    if (Math.abs(regionsWithSize.get(candidateIdx).getThird() - regionsWithSize.get(candidateIdx + 1).getThird()) == 1) {
      break;
    }
    candidateIdx++;
  }
  if (candidateIdx == tableRegions.size() - 1) {
    LOG.debug("No neighboring regions found for table: " + table);
    return EmptyNormalizationPlan.getInstance();
  }
  Triple<HRegionInfo,Long,Integer> candidateRegion=regionsWithSize.get(candidateIdx);
  Triple<HRegionInfo,Long,Integer> candidateRegion2=regionsWithSize.get(candidateIdx + 1);
  if (types.contains(PlanType.MERGE) && candidateRegion.getSecond() + candidateRegion2.getSecond() < avgRegionSize) {
    LOG.debug("Table " + table + ", smallest region size: "+ candidateRegion.getSecond()+ " and its smallest neighbor size: "+ candidateRegion2.getSecond()+ ", less than the avg size, merging them");
    return new MergeNormalizationPlan(candidateRegion.getFirst(),candidateRegion2.getFirst());
  }
  LOG.debug("No normalization needed, regions look good for table: " + table);
  return EmptyNormalizationPlan.getInstance();
}
