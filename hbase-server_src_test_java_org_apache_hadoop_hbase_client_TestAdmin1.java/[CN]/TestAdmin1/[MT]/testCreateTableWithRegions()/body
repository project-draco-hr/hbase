{
  TableName tableName=TableName.valueOf("testCreateTableWithRegions");
  byte[][] splitKeys={new byte[]{1,1,1},new byte[]{2,2,2},new byte[]{3,3,3},new byte[]{4,4,4},new byte[]{5,5,5},new byte[]{6,6,6},new byte[]{7,7,7},new byte[]{8,8,8},new byte[]{9,9,9}};
  int expectedRegions=splitKeys.length + 1;
  HTableDescriptor desc=new HTableDescriptor(tableName);
  desc.addFamily(new HColumnDescriptor(HConstants.CATALOG_FAMILY));
  admin.createTable(desc,splitKeys);
  boolean tableAvailable=admin.isTableAvailable(tableName,splitKeys);
  assertTrue("Table should be created with splitKyes + 1 rows in META",tableAvailable);
  HTable ht=new HTable(TEST_UTIL.getConfiguration(),tableName);
  Map<HRegionInfo,ServerName> regions=ht.getRegionLocations();
  assertEquals("Tried to create " + expectedRegions + " regions "+ "but only found "+ regions.size(),expectedRegions,regions.size());
  System.err.println("Found " + regions.size() + " regions");
  Iterator<HRegionInfo> hris=regions.keySet().iterator();
  HRegionInfo hri=hris.next();
  assertTrue(hri.getStartKey() == null || hri.getStartKey().length == 0);
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[0]));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[0]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[1]));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[1]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[2]));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[2]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[3]));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[3]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[4]));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[4]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[5]));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[5]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[6]));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[6]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[7]));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[7]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[8]));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[8]));
  assertTrue(hri.getEndKey() == null || hri.getEndKey().length == 0);
  verifyRoundRobinDistribution(ht,expectedRegions);
  ht.close();
  byte[] startKey={1,1,1,1,1,1,1,1,1,1};
  byte[] endKey={9,9,9,9,9,9,9,9,9,9};
  expectedRegions=10;
  TableName TABLE_2=TableName.valueOf(tableName.getNameAsString() + "_2");
  desc=new HTableDescriptor(TABLE_2);
  desc.addFamily(new HColumnDescriptor(HConstants.CATALOG_FAMILY));
  admin=new HBaseAdmin(TEST_UTIL.getConfiguration());
  admin.createTable(desc,startKey,endKey,expectedRegions);
  HTable ht2=new HTable(TEST_UTIL.getConfiguration(),TABLE_2);
  regions=ht2.getRegionLocations();
  assertEquals("Tried to create " + expectedRegions + " regions "+ "but only found "+ regions.size(),expectedRegions,regions.size());
  System.err.println("Found " + regions.size() + " regions");
  hris=regions.keySet().iterator();
  hri=hris.next();
  assertTrue(hri.getStartKey() == null || hri.getStartKey().length == 0);
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{1,1,1,1,1,1,1,1,1,1}));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{1,1,1,1,1,1,1,1,1,1}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{2,2,2,2,2,2,2,2,2,2}));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{2,2,2,2,2,2,2,2,2,2}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{3,3,3,3,3,3,3,3,3,3}));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{3,3,3,3,3,3,3,3,3,3}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{4,4,4,4,4,4,4,4,4,4}));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{4,4,4,4,4,4,4,4,4,4}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{5,5,5,5,5,5,5,5,5,5}));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{5,5,5,5,5,5,5,5,5,5}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{6,6,6,6,6,6,6,6,6,6}));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{6,6,6,6,6,6,6,6,6,6}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{7,7,7,7,7,7,7,7,7,7}));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{7,7,7,7,7,7,7,7,7,7}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{8,8,8,8,8,8,8,8,8,8}));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{8,8,8,8,8,8,8,8,8,8}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{9,9,9,9,9,9,9,9,9,9}));
  hri=hris.next();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{9,9,9,9,9,9,9,9,9,9}));
  assertTrue(hri.getEndKey() == null || hri.getEndKey().length == 0);
  verifyRoundRobinDistribution(ht2,expectedRegions);
  ht2.close();
  startKey=new byte[]{0,0,0,0,0,0};
  endKey=new byte[]{1,0,0,0,0,0};
  expectedRegions=5;
  TableName TABLE_3=TableName.valueOf(tableName.getNameAsString() + "_3");
  desc=new HTableDescriptor(TABLE_3);
  desc.addFamily(new HColumnDescriptor(HConstants.CATALOG_FAMILY));
  admin=new HBaseAdmin(TEST_UTIL.getConfiguration());
  admin.createTable(desc,startKey,endKey,expectedRegions);
  HTable ht3=new HTable(TEST_UTIL.getConfiguration(),TABLE_3);
  regions=ht3.getRegionLocations();
  assertEquals("Tried to create " + expectedRegions + " regions "+ "but only found "+ regions.size(),expectedRegions,regions.size());
  System.err.println("Found " + regions.size() + " regions");
  verifyRoundRobinDistribution(ht3,expectedRegions);
  ht3.close();
  splitKeys=new byte[][]{new byte[]{1,1,1},new byte[]{2,2,2},new byte[]{3,3,3},new byte[]{2,2,2}};
  TableName TABLE_4=TableName.valueOf(tableName.getNameAsString() + "_4");
  desc=new HTableDescriptor(TABLE_4);
  desc.addFamily(new HColumnDescriptor(HConstants.CATALOG_FAMILY));
  Admin ladmin=new HBaseAdmin(TEST_UTIL.getConfiguration());
  try {
    ladmin.createTable(desc,splitKeys);
    assertTrue("Should not be able to create this table because of " + "duplicate split keys",false);
  }
 catch (  IllegalArgumentException iae) {
  }
  ladmin.close();
}
