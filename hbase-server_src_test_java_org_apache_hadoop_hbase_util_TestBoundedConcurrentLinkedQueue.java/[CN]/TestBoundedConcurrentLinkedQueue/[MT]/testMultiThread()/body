{
  int offerThreadCount=10;
  int pollThreadCount=5;
  int duration=5000;
  final AtomicBoolean stop=new AtomicBoolean(false);
  Thread[] offerThreads=new Thread[offerThreadCount];
  for (int i=0; i < offerThreadCount; i++) {
    offerThreads[i]=new Thread("offer-thread-" + i){
      @Override public void run(){
        Random rand=new Random();
        while (!stop.get()) {
          queue.offer(rand.nextLong());
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
;
  }
  Thread[] pollThreads=new Thread[pollThreadCount];
  for (int i=0; i < pollThreadCount; i++) {
    pollThreads[i]=new Thread("poll-thread-" + i){
      @Override public void run(){
        while (!stop.get()) {
          queue.poll();
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
;
  }
  for (  Thread t : offerThreads) {
    t.start();
  }
  for (  Thread t : pollThreads) {
    t.start();
  }
  long startTime=System.currentTimeMillis();
  while (System.currentTimeMillis() - startTime < duration) {
    assertTrue(queue.size() <= CAPACITY);
    Thread.yield();
  }
  stop.set(true);
  for (  Thread t : offerThreads) {
    t.join();
  }
  for (  Thread t : pollThreads) {
    t.join();
  }
  assertTrue(queue.size() <= CAPACITY);
}
