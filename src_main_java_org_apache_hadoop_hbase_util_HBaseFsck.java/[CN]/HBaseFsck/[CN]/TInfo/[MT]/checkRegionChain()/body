{
  int originalErrorsCount=errors.getErrorList().size();
  Multimap<byte[],HbckInfo> regions=sc.calcCoverage();
  SortedSet<byte[]> splits=sc.getSplits();
  byte[] prevKey=null;
  for (  byte[] key : splits) {
    Collection<HbckInfo> ranges=regions.get(key);
    if (prevKey == null && !Bytes.equals(key,HConstants.EMPTY_BYTE_ARRAY)) {
      for (      HbckInfo rng : ranges) {
        errors.reportError(ERROR_CODE.FIRST_REGION_STARTKEY_NOT_EMPTY,"First region should start with an empty key.",this,rng);
      }
    }
    if (ranges.size() > 1) {
      ArrayList<HbckInfo> subRange=new ArrayList<HbckInfo>(ranges);
      for (      HbckInfo r1 : ranges) {
        subRange.remove(r1);
        for (        HbckInfo r2 : subRange) {
          if (Bytes.compareTo(r1.getStartKey(),r2.getStartKey()) == 0) {
            errors.reportError(ERROR_CODE.DUPE_STARTKEYS,"Multiple regions have the same startkey: " + Bytes.toStringBinary(key),this,r1);
            errors.reportError(ERROR_CODE.DUPE_STARTKEYS,"Multiple regions have the same startkey: " + Bytes.toStringBinary(key),this,r2);
          }
 else {
            errors.reportError(ERROR_CODE.OVERLAP_IN_REGION_CHAIN,"There is an overlap in the region chain.",this,r1);
          }
        }
      }
    }
    if (ranges.size() == 0) {
      byte[] holeStopKey=sc.getSplits().higher(key);
      if (holeStopKey != null) {
        errors.reportError(ERROR_CODE.HOLE_IN_REGION_CHAIN,"There is a hole in the region chain between " + Bytes.toString(key) + " and "+ Bytes.toString(holeStopKey));
      }
    }
    prevKey=key;
  }
  if (details) {
    dump(sc.getSplits(),regions);
  }
  return errors.getErrorList().size() == originalErrorsCount;
}
