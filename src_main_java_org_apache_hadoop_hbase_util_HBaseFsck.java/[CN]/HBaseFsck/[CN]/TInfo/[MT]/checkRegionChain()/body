{
  int originalErrorsCount=errors.getErrorList().size();
  Multimap<byte[],HbckInfo> regions=sc.calcCoverage();
  SortedSet<byte[]> splits=sc.getSplits();
  byte[] prevKey=null;
  byte[] problemKey=null;
  for (  byte[] key : splits) {
    Collection<HbckInfo> ranges=regions.get(key);
    if (prevKey == null && !Bytes.equals(key,HConstants.EMPTY_BYTE_ARRAY)) {
      for (      HbckInfo rng : ranges) {
        errors.reportError(ERROR_CODE.FIRST_REGION_STARTKEY_NOT_EMPTY,"First region should start with an empty key. When HBase is " + "online, create a new regio to plug the hole using hbck -fix",this,rng);
      }
    }
    for (    HbckInfo rng : ranges) {
      byte[] endKey=rng.getEndKey();
      endKey=(endKey.length == 0) ? null : endKey;
      if (Bytes.equals(rng.getStartKey(),endKey)) {
        errors.reportError(ERROR_CODE.DEGENERATE_REGION,"Region has the same start and end key.",this,rng);
      }
    }
    if (ranges.size() == 1) {
      if (problemKey != null) {
        LOG.warn("reached end of problem group: " + Bytes.toStringBinary(key));
      }
      problemKey=null;
    }
 else     if (ranges.size() > 1) {
      if (problemKey == null) {
        LOG.warn("Naming new problem group: " + Bytes.toStringBinary(key));
        problemKey=key;
      }
      overlapGroups.putAll(problemKey,ranges);
      ArrayList<HbckInfo> subRange=new ArrayList<HbckInfo>(ranges);
      for (      HbckInfo r1 : ranges) {
        subRange.remove(r1);
        for (        HbckInfo r2 : subRange) {
          if (Bytes.compareTo(r1.getStartKey(),r2.getStartKey()) == 0) {
            errors.reportError(ERROR_CODE.DUPE_STARTKEYS,"Multiple regions have the same startkey: " + Bytes.toStringBinary(key),this,r1);
            errors.reportError(ERROR_CODE.DUPE_STARTKEYS,"Multiple regions have the same startkey: " + Bytes.toStringBinary(key),this,r2);
          }
 else {
            errors.reportError(ERROR_CODE.OVERLAP_IN_REGION_CHAIN,"There is an overlap in the region chain.",this,r1);
          }
        }
      }
    }
 else     if (ranges.size() == 0) {
      if (problemKey != null) {
        LOG.warn("reached end of problem group: " + Bytes.toStringBinary(key));
      }
      problemKey=null;
      byte[] holeStopKey=sc.getSplits().higher(key);
      if (holeStopKey != null) {
        errors.reportError(ERROR_CODE.HOLE_IN_REGION_CHAIN,"There is a hole in the region chain between " + Bytes.toStringBinary(key) + " and "+ Bytes.toStringBinary(holeStopKey)+ ".  When HBase is online, create a new regioninfo and region "+ "dir to plug the hole.");
      }
    }
    prevKey=key;
  }
  if (details) {
    dump(splits,regions);
    dumpOverlapProblems(overlapGroups);
    System.out.println("There are " + overlapGroups.keySet().size() + " problem groups with "+ overlapGroups.size()+ " problem regions");
  }
  return errors.getErrorList().size() == originalErrorsCount;
}
