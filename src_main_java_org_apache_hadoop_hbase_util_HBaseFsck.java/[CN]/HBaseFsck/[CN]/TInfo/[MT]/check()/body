{
  byte[] last=new byte[0];
  byte[] next=new byte[0];
  TreeSet<byte[]> visited=new TreeSet<byte[]>(Bytes.BYTES_COMPARATOR);
  while (true) {
    if (!edges.containsKey(last)) {
      errors.detail("Chain of regions in table " + tableName + " is broken; edges does not contain "+ Bytes.toString(last));
      return false;
    }
    next=edges.get(last);
    if (visited.contains(next)) {
      errors.detail("Chain of regions in table " + tableName + " has a cycle around "+ Bytes.toString(next));
      return false;
    }
    visited.add(next);
    if (next.length == 0) {
      if (edges.size() != visited.size()) {
        errors.detail("Chain of regions in table " + tableName + " contains less elements than are listed in META; visited="+ visited.size()+ ", edges="+ edges.size());
        return false;
      }
      return true;
    }
    last=next;
  }
}
