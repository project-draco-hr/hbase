{
  ByteBuffer storedBlock;
  try {
    storedBlock=backingStore.alloc(toBeCached.getSerializedLength());
  }
 catch (  InterruptedException e) {
    LOG.warn("SlabAllocator was interrupted while waiting for block to become available");
    LOG.warn(e);
    return;
  }
  CacheablePair newEntry=new CacheablePair(toBeCached.getDeserializer(),storedBlock);
  toBeCached.serialize(storedBlock);
synchronized (this) {
    CacheablePair alreadyCached=backingMap.putIfAbsent(blockName,newEntry);
    if (alreadyCached != null) {
      backingStore.free(storedBlock);
      throw new RuntimeException("already cached " + blockName);
    }
    if (actionWatcher != null) {
      actionWatcher.onInsertion(blockName,this);
    }
  }
  newEntry.recentlyAccessed.set(System.nanoTime());
  this.size.addAndGet(newEntry.heapSize());
}
