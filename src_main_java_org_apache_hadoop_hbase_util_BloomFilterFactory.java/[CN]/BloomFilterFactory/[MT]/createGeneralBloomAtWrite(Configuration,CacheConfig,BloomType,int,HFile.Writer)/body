{
  if (!isGeneralBloomEnabled(conf)) {
    LOG.trace("Bloom filters are disabled by configuration for " + writer.getPath() + (conf == null ? " (configuration is null)" : ""));
    return null;
  }
 else   if (bloomType == BloomType.NONE) {
    LOG.trace("Bloom filter is turned off for the column family");
    return null;
  }
  float err=getErrorRate(conf);
  if (bloomType == BloomType.ROWCOL) {
    err=(float)(1 - Math.sqrt(1 - err));
  }
  int maxFold=conf.getInt(IO_STOREFILE_BLOOM_MAX_FOLD,MAX_ALLOWED_FOLD_FACTOR);
  if (HFile.getFormatVersion(conf) > HFile.MIN_FORMAT_VERSION) {
    CompoundBloomFilterWriter bloomWriter=new CompoundBloomFilterWriter(getBloomBlockSize(conf),err,Hash.getHashType(conf),maxFold,cacheConf.shouldCacheBloomsOnWrite(),bloomType == BloomType.ROWCOL ? KeyValue.KEY_COMPARATOR : Bytes.BYTES_RAWCOMPARATOR);
    writer.addInlineBlockWriter(bloomWriter);
    return bloomWriter;
  }
 else {
    int tooBig=conf.getInt(IO_STOREFILE_BLOOM_MAX_KEYS,128 * 1000 * 1000);
    if (maxKeys <= 0) {
      LOG.warn("Invalid maximum number of keys specified: " + maxKeys + ", not using Bloom filter");
      return null;
    }
 else     if (maxKeys < tooBig) {
      BloomFilterWriter bloom=new ByteBloomFilter((int)maxKeys,err,Hash.getHashType(conf),maxFold);
      bloom.allocBloom();
      return bloom;
    }
 else {
      LOG.debug("Skipping bloom filter because max keysize too large: " + maxKeys);
    }
  }
  return null;
}
