{
  Path hfofDir=new Path(dirPath);
  FileSystem fs=hfofDir.getFileSystem(getConf());
  if (!fs.exists(hfofDir)) {
    throw new FileNotFoundException("HFileOutputFormat dir " + hfofDir + " not found");
  }
  FileStatus[] familyDirStatuses=fs.listStatus(hfofDir);
  if (familyDirStatuses == null) {
    throw new FileNotFoundException("No families found in " + hfofDir);
  }
  HTableDescriptor htd=new HTableDescriptor(tableName);
  HColumnDescriptor hcd=null;
  byte[][] keys=null;
  TreeMap<byte[],Integer> map=new TreeMap<byte[],Integer>(Bytes.BYTES_COMPARATOR);
  for (  FileStatus stat : familyDirStatuses) {
    if (!stat.isDir()) {
      LOG.warn("Skipping non-directory " + stat.getPath());
      continue;
    }
    Path familyDir=stat.getPath();
    if (familyDir.getName().startsWith("_"))     continue;
    byte[] family=familyDir.getName().getBytes();
    hcd=new HColumnDescriptor(family);
    htd.addFamily(hcd);
    Path[] hfiles=FileUtil.stat2Paths(fs.listStatus(familyDir));
    for (    Path hfile : hfiles) {
      if (hfile.getName().startsWith("_"))       continue;
      HFile.Reader reader=new HFile.Reader(fs,hfile,null,false,false);
      final byte[] first, last;
      try {
        reader.loadFileInfo();
        first=reader.getFirstRowKey();
        last=reader.getLastRowKey();
        LOG.info("Trying to figure out region boundaries hfile=" + hfile + " first="+ Bytes.toStringBinary(first)+ " last="+ Bytes.toStringBinary(last));
        Integer value=map.containsKey(first) ? (Integer)map.get(first) : 0;
        map.put(first,value + 1);
        value=map.containsKey(last) ? (Integer)map.get(last) : 0;
        map.put(last,value - 1);
      }
  finally {
        reader.close();
      }
    }
  }
  keys=LoadIncrementalHFiles.inferBoundaries(map);
  try {
    this.hbAdmin.createTableAsync(htd,keys);
  }
 catch (  java.net.SocketTimeoutException e) {
    System.err.println("Caught Socket timeout.. Mostly caused by a slow region assignment by master!");
  }
  HTable table=new HTable(tableName);
  HConnection conn=table.getConnection();
  int ctr=0;
  while (!conn.isTableAvailable(table.getTableName()) && (ctr < TABLE_CREATE_MAX_RETRIES)) {
    LOG.info("Table " + tableName + "not yet available... Sleeping for 60 more seconds...");
    Thread.sleep(TABLE_CREATE_SLEEP);
    ctr++;
  }
  LOG.info("Table " + tableName + " is finally available!!");
}
