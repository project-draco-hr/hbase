{
  this.basedir=basedir;
  this.info=info;
  this.family=family;
  this.fs=fs;
  this.conf=conf;
  this.ttl=family.getTimeToLive();
  if (ttl != HConstants.FOREVER)   this.ttl*=1000;
  this.memcache=new Memcache(this.ttl);
  this.compactionDir=HRegion.getCompactionDir(basedir);
  this.storeName=new Text(this.info.getEncodedName() + "/" + this.family.getFamilyName());
  this.compactionThreshold=conf.getInt("hbase.hstore.compactionThreshold",3);
  this.desiredMaxFileSize=conf.getLong("hbase.hregion.max.filesize",DEFAULT_MAX_FILE_SIZE);
  this.storeSize=0L;
  if (family.getCompression() == HColumnDescriptor.CompressionType.BLOCK) {
    this.compression=SequenceFile.CompressionType.BLOCK;
  }
 else   if (family.getCompression() == HColumnDescriptor.CompressionType.RECORD) {
    this.compression=SequenceFile.CompressionType.RECORD;
  }
 else {
    this.compression=SequenceFile.CompressionType.NONE;
  }
  Path mapdir=HStoreFile.getMapDir(basedir,info.getEncodedName(),family.getFamilyName());
  if (!fs.exists(mapdir)) {
    fs.mkdirs(mapdir);
  }
  Path infodir=HStoreFile.getInfoDir(basedir,info.getEncodedName(),family.getFamilyName());
  if (!fs.exists(infodir)) {
    fs.mkdirs(infodir);
  }
  if (family.getBloomFilter() == null) {
    this.filterDir=null;
    this.bloomFilter=null;
  }
 else {
    this.filterDir=HStoreFile.getFilterDir(basedir,info.getEncodedName(),family.getFamilyName());
    if (!fs.exists(filterDir)) {
      fs.mkdirs(filterDir);
    }
    this.bloomFilter=loadOrCreateBloomFilter();
  }
  this.maxSeqId=-1L;
  this.storefiles.putAll(loadHStoreFiles(infodir,mapdir));
  if (LOG.isDebugEnabled()) {
    LOG.debug("Loaded " + this.storefiles.size() + " file(s) in hstore "+ this.storeName+ ", max sequence id "+ this.maxSeqId);
  }
  try {
    doReconstructionLog(reconstructionLog,maxSeqId,reporter);
  }
 catch (  IOException e) {
    LOG.warn("Exception processing reconstruction log " + reconstructionLog + " opening "+ this.storeName+ " -- continuing.  Probably DATA LOSS!",e);
  }
  boolean first=true;
  for (  Map.Entry<Long,HStoreFile> e : this.storefiles.entrySet()) {
    if (first) {
      this.readers.put(e.getKey(),e.getValue().getReader(this.fs,this.bloomFilter,family.isBlockCacheEnabled()));
      first=false;
    }
 else {
      this.readers.put(e.getKey(),e.getValue().getReader(this.fs,this.bloomFilter));
    }
  }
}
