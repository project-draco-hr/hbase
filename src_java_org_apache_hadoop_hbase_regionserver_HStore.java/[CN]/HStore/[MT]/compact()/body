{
synchronized (compactLock) {
    long maxId=-1;
    List<HStoreFile> filesToCompact=null;
synchronized (storefiles) {
      filesToCompact=new ArrayList<HStoreFile>(this.storefiles.values());
      if (!hasReferences(filesToCompact) && filesToCompact.size() < compactionThreshold) {
        return checkSplit();
      }
      if (!fs.exists(compactionDir) && !fs.mkdirs(compactionDir)) {
        LOG.warn("Mkdir on " + compactionDir.toString() + " failed");
        return checkSplit();
      }
      maxId=this.storefiles.lastKey().longValue();
    }
    Collections.reverse(filesToCompact);
    HStoreFile compactedOutputFile=new HStoreFile(conf,fs,this.compactionDir,info.getEncodedName(),family.getFamilyName(),-1L,null);
    if (LOG.isDebugEnabled()) {
      LOG.debug("started compaction of " + filesToCompact.size() + " files "+ filesToCompact.toString()+ " into "+ FSUtils.getPath(compactedOutputFile.getMapFilePath()));
    }
    MapFile.Writer compactedOut=compactedOutputFile.getWriter(this.fs,this.compression,this.bloomFilter);
    try {
      compactHStoreFiles(compactedOut,filesToCompact);
    }
  finally {
      compactedOut.close();
    }
    compactedOutputFile.writeInfo(fs,maxId);
    completeCompaction(filesToCompact,compactedOutputFile);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Completed compaction of " + this.storeName + " store size is "+ StringUtils.humanReadableInt(storeSize));
    }
  }
  return checkSplit();
}
