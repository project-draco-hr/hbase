{
  FileStatus infofiles[]=fs.listStatus(infodir);
  SortedMap<Long,HStoreFile> results=new TreeMap<Long,HStoreFile>();
  ArrayList<Path> mapfiles=new ArrayList<Path>(infofiles.length);
  for (int i=0; i < infofiles.length; i++) {
    Path p=infofiles[i].getPath();
    if (this.fs.getFileStatus(p).getLen() <= 0) {
      LOG.warn("Skipping " + p + " because its empty.  DATA LOSS?  Can "+ "this scenario be repaired?  HBASE-646");
      continue;
    }
    Matcher m=REF_NAME_PARSER.matcher(p.getName());
    boolean isReference=isReference(p,m);
    long fid=Long.parseLong(m.group(1));
    HStoreFile curfile=null;
    Reference reference=null;
    if (isReference) {
      reference=HStoreFile.readSplitInfo(p,fs);
    }
    curfile=new HStoreFile(conf,fs,basedir,this.info,family.getName(),fid,reference);
    long storeSeqId=-1;
    try {
      storeSeqId=curfile.loadInfo(fs);
      if (storeSeqId > this.maxSeqId) {
        this.maxSeqId=storeSeqId;
      }
    }
 catch (    IOException e) {
      LOG.info("HSTORE_LOGINFOFILE " + curfile + " does not contain a sequence number - ignoring");
    }
    Path mapfile=curfile.getMapFilePath();
    if (!fs.exists(mapfile)) {
      fs.delete(curfile.getInfoFilePath(),false);
      LOG.warn("Mapfile " + mapfile.toString() + " does not exist. "+ "Cleaned up info file.  Continuing...Probable DATA LOSS!!!");
      continue;
    }
    if (isEmptyDataFile(mapfile)) {
      curfile.delete();
      LOG.warn("Mapfile " + mapfile.toString() + " has empty data. "+ "Deleting.  Continuing...Probable DATA LOSS!!!  See HBASE-646.");
      continue;
    }
    if (isEmptyIndexFile(mapfile)) {
      try {
        this.fs.delete(new Path(mapfile,MapFile.INDEX_FILE_NAME),false);
        long count=MapFile.fix(this.fs,mapfile,HStoreKey.class,HBaseMapFile.VALUE_CLASS,false,this.conf);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Fixed index on " + mapfile.toString() + "; had "+ count+ " entries");
        }
      }
 catch (      Exception e) {
        LOG.warn("Failed fix of " + mapfile.toString() + "...continuing; Probable DATA LOSS!!!",e);
        continue;
      }
    }
    long length=curfile.length();
    storeSize+=length;
    if (LOG.isDebugEnabled()) {
      LOG.debug("loaded " + FSUtils.getPath(p) + ", isReference="+ isReference+ ", sequence id="+ storeSeqId+ ", length="+ length+ ", majorCompaction="+ curfile.isMajorCompaction());
    }
    results.put(Long.valueOf(storeSeqId),curfile);
    mapfiles.add(this.fs.makeQualified(mapfile));
  }
  cleanDataFiles(mapfiles,mapdir);
  return results;
}
