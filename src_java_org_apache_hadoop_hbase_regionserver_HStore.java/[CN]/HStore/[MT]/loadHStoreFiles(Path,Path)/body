{
  FileStatus infofiles[]=fs.listStatus(infodir);
  SortedMap<Long,HStoreFile> results=new TreeMap<Long,HStoreFile>();
  ArrayList<Path> mapfiles=new ArrayList<Path>(infofiles.length);
  for (int i=0; i < infofiles.length; i++) {
    Path p=infofiles[i].getPath();
    Matcher m=REF_NAME_PARSER.matcher(p.getName());
    boolean isReference=isReference(p,m);
    long fid=Long.parseLong(m.group(1));
    HStoreFile curfile=null;
    HStoreFile.Reference reference=null;
    if (isReference) {
      reference=HStoreFile.readSplitInfo(p,fs);
    }
    curfile=new HStoreFile(conf,fs,basedir,info.getEncodedName(),family.getName(),fid,reference);
    storeSize+=curfile.length();
    long storeSeqId=-1;
    try {
      storeSeqId=curfile.loadInfo(fs);
      if (storeSeqId > this.maxSeqId) {
        this.maxSeqId=storeSeqId;
      }
    }
 catch (    IOException e) {
      LOG.info("HSTORE_LOGINFOFILE " + curfile + " does not contain a sequence number - ignoring");
    }
    Path mapfile=curfile.getMapFilePath();
    if (!fs.exists(mapfile)) {
      fs.delete(curfile.getInfoFilePath(),false);
      LOG.warn("Mapfile " + mapfile.toString() + " does not exist. "+ "Cleaned up info file.  Continuing...");
      continue;
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("loaded " + FSUtils.getPath(p) + ", isReference="+ isReference+ ", sequence id="+ storeSeqId);
    }
    results.put(Long.valueOf(storeSeqId),curfile);
    mapfiles.add(mapfile);
  }
  FileStatus datfiles[]=fs.listStatus(mapdir);
  for (int i=0; i < datfiles.length; i++) {
    Path p=datfiles[i].getPath();
    if (!mapfiles.contains(fs.makeQualified(p))) {
      fs.delete(p,false);
    }
  }
  return results;
}
