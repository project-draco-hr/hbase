{
  FileStatus infofiles[]=fs.listStatus(infodir);
  SortedMap<Long,HStoreFile> results=new TreeMap<Long,HStoreFile>();
  ArrayList<Path> mapfiles=new ArrayList<Path>(infofiles.length);
  for (int i=0; i < infofiles.length; i++) {
    Path p=infofiles[i].getPath();
    if (this.fs.getFileStatus(p).getLen() <= 0) {
      LOG.warn("Skipping " + p + " because its empty.  DATA LOSS?  Can "+ "this scenario be repaired?  HBASE-646");
      continue;
    }
    Matcher m=REF_NAME_PARSER.matcher(p.getName());
    boolean isReference=isReference(p,m);
    long fid=Long.parseLong(m.group(1));
    HStoreFile curfile=null;
    HStoreFile.Reference reference=null;
    if (isReference) {
      reference=HStoreFile.readSplitInfo(p,fs);
    }
    curfile=new HStoreFile(conf,fs,basedir,info.getEncodedName(),family.getName(),fid,reference);
    long storeSeqId=-1;
    try {
      storeSeqId=curfile.loadInfo(fs);
      if (storeSeqId > this.maxSeqId) {
        this.maxSeqId=storeSeqId;
      }
    }
 catch (    IOException e) {
      LOG.info("HSTORE_LOGINFOFILE " + curfile + " does not contain a sequence number - ignoring");
    }
    Path mapfile=curfile.getMapFilePath();
    if (!fs.exists(mapfile)) {
      fs.delete(curfile.getInfoFilePath(),false);
      LOG.warn("Mapfile " + mapfile.toString() + " does not exist. "+ "Cleaned up info file.  Continuing...Probable DATA LOSS!!!");
      continue;
    }
    if (isEmptyDataFile(mapfile)) {
      curfile.delete();
      LOG.warn("Mapfile " + mapfile.toString() + " has empty data. "+ "Deleting.  Continuing...Probable DATA LOSS!!!  See HBASE-646.");
      continue;
    }
    if (isEmptyIndexFile(mapfile)) {
      try {
        this.fs.delete(new Path(mapfile,MapFile.INDEX_FILE_NAME),false);
        long count=MapFile.fix(this.fs,mapfile,HStoreFile.HbaseMapFile.KEY_CLASS,HStoreFile.HbaseMapFile.VALUE_CLASS,false,this.conf);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Fixed index on " + mapfile.toString() + "; had "+ count+ " entries");
        }
      }
 catch (      Exception e) {
        LOG.warn("Failed fix of " + mapfile.toString() + "...continuing; Probable DATA LOSS!!!",e);
        continue;
      }
    }
    storeSize+=curfile.length();
    if (LOG.isDebugEnabled()) {
      LOG.debug("loaded " + FSUtils.getPath(p) + ", isReference="+ isReference+ ", sequence id="+ storeSeqId);
    }
    results.put(Long.valueOf(storeSeqId),curfile);
    mapfiles.add(mapfile);
  }
  FileStatus datfiles[]=fs.listStatus(mapdir);
  for (int i=0; i < datfiles.length; i++) {
    Path p=datfiles[i].getPath();
    if (!mapfiles.contains(fs.makeQualified(p))) {
      fs.delete(p,true);
    }
  }
  return results;
}
