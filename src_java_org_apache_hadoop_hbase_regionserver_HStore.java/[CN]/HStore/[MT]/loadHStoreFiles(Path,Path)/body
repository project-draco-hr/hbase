{
  if (LOG.isDebugEnabled()) {
    LOG.debug("infodir: " + infodir.toString() + " mapdir: "+ mapdir.toString());
  }
  FileStatus infofiles[]=fs.listStatus(infodir);
  SortedMap<Long,HStoreFile> results=new TreeMap<Long,HStoreFile>();
  ArrayList<Path> mapfiles=new ArrayList<Path>(infofiles.length);
  for (int i=0; i < infofiles.length; i++) {
    Path p=infofiles[i].getPath();
    Matcher m=REF_NAME_PARSER.matcher(p.getName());
    boolean isReference=isReference(p,m);
    long fid=Long.parseLong(m.group(1));
    if (LOG.isDebugEnabled()) {
      LOG.debug("loading file " + p.toString() + ", isReference="+ isReference+ ", file id="+ fid);
    }
    HStoreFile curfile=null;
    HStoreFile.Reference reference=null;
    if (isReference) {
      reference=readSplitInfo(p,fs);
    }
    curfile=new HStoreFile(conf,fs,basedir,info.getEncodedName(),family.getFamilyName(),fid,reference);
    storeSize+=curfile.length();
    long storeSeqId=-1;
    try {
      storeSeqId=curfile.loadInfo(fs);
      if (storeSeqId > this.maxSeqId) {
        this.maxSeqId=storeSeqId;
      }
    }
 catch (    IOException e) {
      LOG.info("HSTORE_LOGINFOFILE " + curfile + " does not contain a sequence number - ignoring");
    }
    Path mapfile=curfile.getMapFilePath();
    if (!fs.exists(mapfile)) {
      fs.delete(curfile.getInfoFilePath());
      LOG.warn("Mapfile " + mapfile.toString() + " does not exist. "+ "Cleaned up info file.  Continuing...");
      continue;
    }
    results.put(storeSeqId,curfile);
    mapfiles.add(mapfile);
  }
  FileStatus datfiles[]=fs.listStatus(mapdir);
  for (int i=0; i < datfiles.length; i++) {
    Path p=datfiles[i].getPath();
    if (!mapfiles.contains(fs.makeQualified(p))) {
      fs.delete(p);
    }
  }
  return results;
}
