{
  if (this.storefiles.size() <= 0) {
    return null;
  }
  if (!force && (storeSize < this.desiredMaxFileSize)) {
    return null;
  }
  this.lock.readLock().lock();
  try {
    boolean splitable=true;
    long maxSize=0L;
    Long mapIndex=Long.valueOf(0L);
synchronized (storefiles) {
      for (      Map.Entry<Long,HStoreFile> e : storefiles.entrySet()) {
        HStoreFile curHSF=e.getValue();
        if (splitable) {
          splitable=!curHSF.isReference();
          if (!splitable) {
            if (LOG.isDebugEnabled()) {
              LOG.debug(curHSF + " is not splittable");
            }
            return null;
          }
        }
        long size=curHSF.length();
        if (size > maxSize) {
          maxSize=size;
          mapIndex=e.getKey();
        }
      }
    }
    HBaseMapFile.HBaseReader r=(HBaseMapFile.HBaseReader)this.readers.get(mapIndex);
    r.reset();
    HStoreKey firstKey=new HStoreKey();
    HStoreKey lastKey=new HStoreKey();
    r.next(firstKey,new ImmutableBytesWritable());
    r.finalKey(lastKey);
    HStoreKey mk=(HStoreKey)r.midKey();
    if (mk != null) {
      if (HStoreKey.equalsTwoRowKeys(info,mk.getRow(),firstKey.getRow()) && HStoreKey.equalsTwoRowKeys(info,mk.getRow(),lastKey.getRow())) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("cannot split because midkey is the same as first or last row");
        }
        return null;
      }
      return new StoreSize(maxSize,mk.getRow());
    }
  }
 catch (  IOException e) {
    LOG.warn("Failed getting store size for " + this.storeNameStr,e);
  }
 finally {
    this.lock.readLock().unlock();
  }
  return null;
}
