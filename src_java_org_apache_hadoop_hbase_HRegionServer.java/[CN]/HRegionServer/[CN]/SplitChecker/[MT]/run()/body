{
  while (!stopRequested) {
    long startTime=System.currentTimeMillis();
    Vector<HRegion> checkSplit=new Vector<HRegion>();
    locker.readLock().lock();
    try {
      checkSplit.addAll(regions.values());
    }
  finally {
      locker.readLock().unlock();
    }
    Vector<SplitRegion> toSplit=new Vector<SplitRegion>();
    for (Iterator<HRegion> it=checkSplit.iterator(); it.hasNext(); ) {
      HRegion cur=it.next();
      Text midKey=new Text();
      try {
        if (cur.needsSplit(midKey)) {
          toSplit.add(new SplitRegion(cur,midKey));
        }
      }
 catch (      IOException iex) {
        iex.printStackTrace();
      }
    }
    for (Iterator<SplitRegion> it=toSplit.iterator(); it.hasNext(); ) {
      SplitRegion r=it.next();
      locker.writeLock().lock();
      regions.remove(r.region.getRegionName());
      locker.writeLock().unlock();
      HRegion[] newRegions=null;
      try {
        Text oldRegion=r.region.getRegionName();
        LOG.info("splitting region: " + oldRegion);
        newRegions=r.region.closeAndSplit(r.midKey);
        Text tableToUpdate=(oldRegion.find(META_TABLE_NAME.toString()) == 0) ? ROOT_TABLE_NAME : META_TABLE_NAME;
        if (LOG.isDebugEnabled()) {
          LOG.debug("region split complete. updating meta");
        }
        client.openTable(tableToUpdate);
        long lockid=client.startUpdate(oldRegion);
        client.delete(lockid,COL_REGIONINFO);
        client.delete(lockid,COL_SERVER);
        client.delete(lockid,COL_STARTCODE);
        client.commit(lockid);
        for (int i=0; i < newRegions.length; i++) {
          ByteArrayOutputStream bytes=new ByteArrayOutputStream();
          DataOutputStream out=new DataOutputStream(bytes);
          newRegions[i].getRegionInfo().write(out);
          lockid=client.startUpdate(newRegions[i].getRegionName());
          client.put(lockid,COL_REGIONINFO,bytes.toByteArray());
          client.commit(lockid);
        }
        if (LOG.isDebugEnabled()) {
          LOG.debug("reporting region split to master");
        }
        reportSplit(newRegions[0].getRegionInfo(),newRegions[1].getRegionInfo());
        LOG.info("region split successful. old region=" + oldRegion + ", new regions: "+ newRegions[0].getRegionName()+ ", "+ newRegions[1].getRegionName());
        newRegions[0].close();
        newRegions[1].close();
      }
 catch (      IOException e) {
        e.printStackTrace();
        continue;
      }
    }
    long waitTime=stopRequested ? 0 : splitCheckFrequency - (System.currentTimeMillis() - startTime);
    if (waitTime > 0) {
      try {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Sleep splitChecker");
        }
        Thread.sleep(waitTime);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Wake splitChecker");
        }
      }
 catch (      InterruptedException iex) {
      }
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("splitChecker exiting");
  }
}
