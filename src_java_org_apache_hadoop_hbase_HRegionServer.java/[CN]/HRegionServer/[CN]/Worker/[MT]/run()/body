{
  for (ToDoEntry e=null; !stopRequested; ) {
synchronized (toDo) {
      while (toDo.size() == 0 && !stopRequested) {
        try {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Wait on todo");
          }
          toDo.wait(threadWakeFrequency);
          if (LOG.isDebugEnabled()) {
            LOG.debug("Wake on todo");
          }
        }
 catch (        InterruptedException ex) {
        }
      }
      if (stopRequested) {
        continue;
      }
      e=toDo.removeFirst();
    }
    try {
      if (LOG.isDebugEnabled()) {
        LOG.debug(e.msg.toString());
      }
switch (e.msg.getMsg()) {
case HMsg.MSG_REGION_OPEN:
        openRegion(e.msg.getRegionInfo());
      break;
case HMsg.MSG_REGION_CLOSE:
    closeRegion(e.msg.getRegionInfo(),true);
  break;
case HMsg.MSG_REGION_CLOSE_WITHOUT_REPORT:
closeRegion(e.msg.getRegionInfo(),false);
break;
default :
throw new AssertionError("Impossible state during msg processing.  Instruction: " + e.msg.toString());
}
}
 catch (IOException ie) {
if (e.tries < numRetries) {
LOG.warn(ie);
e.tries++;
synchronized (toDo) {
toDo.addLast(e);
}
}
 else {
LOG.error("unable to process message: " + e.msg.toString(),ie);
}
}
}
LOG.info("worker thread exiting");
}
