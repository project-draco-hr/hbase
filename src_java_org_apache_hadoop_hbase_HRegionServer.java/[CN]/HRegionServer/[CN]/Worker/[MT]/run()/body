{
  try {
    while (!stopRequested.get()) {
      ToDoEntry e=null;
      try {
        e=toDo.poll(threadWakeFrequency,TimeUnit.MILLISECONDS);
        if (e == null || stopRequested.get()) {
          continue;
        }
        LOG.info(e.msg.toString());
switch (e.msg.getMsg()) {
case HMsg.MSG_REGIONSERVER_QUIESCE:
          closeUserRegions();
        break;
case HMsg.MSG_REGION_OPEN:
      openRegion(e.msg.getRegionInfo());
    break;
case HMsg.MSG_REGION_CLOSE:
  closeRegion(e.msg.getRegionInfo(),true);
break;
case HMsg.MSG_REGION_CLOSE_WITHOUT_REPORT:
closeRegion(e.msg.getRegionInfo(),false);
break;
default :
throw new AssertionError("Impossible state during msg processing.  Instruction: " + e.msg.toString());
}
}
 catch (InterruptedException ex) {
}
catch (Exception ex) {
if (ex instanceof IOException) {
ex=RemoteExceptionHandler.checkIOException((IOException)ex);
}
if (e != null && e.tries < numRetries) {
LOG.warn(ex);
e.tries++;
try {
toDo.put(e);
}
 catch (InterruptedException ie) {
throw new RuntimeException("Putting into msgQueue was " + "interrupted.",ex);
}
}
 else {
LOG.error("unable to process message" + (e != null ? (": " + e.msg.toString()) : ""),ex);
if (!checkFileSystem()) {
break;
}
}
}
}
}
 catch (Throwable t) {
LOG.fatal("Unhandled exception",t);
}
 finally {
LOG.info("worker thread exiting");
}
}
