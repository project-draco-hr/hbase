{
  for (HMsg msg=null; !stopRequested; ) {
synchronized (toDo) {
      while (toDo.size() == 0 && !stopRequested) {
        try {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Wait on todo");
          }
          toDo.wait();
          if (LOG.isDebugEnabled()) {
            LOG.debug("Wake on todo");
          }
        }
 catch (        InterruptedException e) {
        }
      }
      if (stopRequested) {
        continue;
      }
      msg=toDo.remove(0);
    }
    try {
switch (msg.getMsg()) {
case HMsg.MSG_REGION_OPEN:
        if (LOG.isDebugEnabled()) {
          LOG.debug("MSG_REGION_OPEN");
        }
      openRegion(msg.getRegionInfo());
    break;
case HMsg.MSG_REGION_CLOSE:
  if (LOG.isDebugEnabled()) {
    LOG.debug("MSG_REGION_CLOSE");
  }
closeRegion(msg.getRegionInfo(),true);
break;
case HMsg.MSG_REGION_MERGE:
if (LOG.isDebugEnabled()) {
LOG.debug("MSG_REGION_MERGE");
}
throw new IOException("TODO: need to figure out merge");
case HMsg.MSG_CALL_SERVER_STARTUP:
if (LOG.isDebugEnabled()) {
LOG.debug("MSG_CALL_SERVER_STARTUP");
}
closeAllRegions();
continue;
case HMsg.MSG_REGIONSERVER_STOP:
if (LOG.isDebugEnabled()) {
LOG.debug("MSG_REGIONSERVER_STOP");
}
stopRequested=true;
continue;
case HMsg.MSG_REGION_CLOSE_WITHOUT_REPORT:
if (LOG.isDebugEnabled()) {
LOG.debug("MSG_REGION_CLOSE_WITHOUT_REPORT");
}
closeRegion(msg.getRegionInfo(),false);
break;
case HMsg.MSG_REGION_CLOSE_AND_DELETE:
if (LOG.isDebugEnabled()) {
LOG.debug("MSG_REGION_CLOSE_AND_DELETE");
}
closeAndDeleteRegion(msg.getRegionInfo());
break;
default :
throw new IOException("Impossible state during msg processing.  Instruction: " + msg);
}
}
 catch (IOException e) {
e.printStackTrace();
}
}
if (LOG.isDebugEnabled()) {
LOG.debug("worker thread exiting");
}
}
