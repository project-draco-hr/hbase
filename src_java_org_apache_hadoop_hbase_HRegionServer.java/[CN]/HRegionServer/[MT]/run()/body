{
  try {
    init(reportForDuty());
    long lastMsg=0;
    while (!stopRequested.get()) {
      for (int tries=0; !stopRequested.get(); ) {
        long now=System.currentTimeMillis();
        if (lastMsg != 0 && (now - lastMsg) >= serverLeaseTimeout) {
          LOG.fatal("unable to report to master for " + (now - lastMsg) + " milliseconds - aborting server");
          abort();
          break;
        }
        if ((now - lastMsg) >= msgInterval) {
          HMsg outboundArray[]=null;
synchronized (outboundMsgs) {
            outboundArray=this.outboundMsgs.toArray(new HMsg[outboundMsgs.size()]);
          }
          this.outboundMsgs.clear();
          try {
            this.serverInfo.setLoad(new HServerLoad(requestCount.get(),onlineRegions.size()));
            this.requestCount.set(0);
            HMsg msgs[]=this.hbaseMaster.regionServerReport(serverInfo,outboundArray);
            lastMsg=System.currentTimeMillis();
            boolean restart=false;
            for (int i=0; i < msgs.length && !stopRequested.get() && !restart; i++) {
switch (msgs[i].getMsg()) {
case HMsg.MSG_CALL_SERVER_STARTUP:
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Got call server startup message");
                }
              if (checkFileSystem()) {
                closeAllRegions();
synchronized (logRollerLock) {
                  try {
                    log.closeAndDelete();
                  }
 catch (                  Exception e) {
                    LOG.error("error closing and deleting HLog",e);
                  }
                  try {
                    serverInfo.setStartCode(System.currentTimeMillis());
                    log=setupHLog();
                  }
 catch (                  IOException e) {
                    this.abortRequested=true;
                    this.stopRequested.set(true);
                    e=RemoteExceptionHandler.checkIOException(e);
                    LOG.fatal("error restarting server",e);
                    break;
                  }
                }
                reportForDuty();
                restart=true;
              }
 else {
                LOG.fatal("file system available check failed. " + "Shutting down server.");
              }
            break;
case HMsg.MSG_REGIONSERVER_STOP:
          if (LOG.isDebugEnabled()) {
            LOG.debug("Got regionserver stop message");
          }
        stopRequested.set(true);
      break;
default :
    if (fsOk) {
      try {
        toDo.put(new ToDoEntry(msgs[i]));
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("Putting into msgQueue was " + "interrupted.",e);
      }
      if (msgs[i].getMsg() == HMsg.MSG_REGION_OPEN) {
        outboundMsgs.add(new HMsg(HMsg.MSG_REPORT_PROCESS_OPEN,msgs[i].getRegionInfo()));
      }
    }
}
}
if (restart || this.stopRequested.get()) {
toDo.clear();
break;
}
tries=0;
}
 catch (IOException e) {
e=RemoteExceptionHandler.checkIOException(e);
if (tries < this.numRetries) {
LOG.warn("Processing message (Retry: " + tries + ")",e);
tries++;
}
 else {
LOG.error("Exceeded max retries: " + this.numRetries,e);
if (!checkFileSystem()) {
  continue;
}
stop();
}
}
}
this.sleeper.sleep(lastMsg);
}
}
}
 catch (Throwable t) {
LOG.fatal("Unhandled exception. Aborting...",t);
abort();
}
this.leases.closeAfterLeasesExpire();
this.worker.stop();
this.server.stop();
if (this.infoServer != null) {
LOG.info("Stopping infoServer");
try {
this.infoServer.stop();
}
 catch (InterruptedException ex) {
ex.printStackTrace();
}
}
synchronized (cacheFlusherLock) {
this.cacheFlusher.interrupt();
}
synchronized (compactionLock) {
this.compactor.interrupt();
}
synchronized (splitterLock) {
this.splitter.interrupt();
}
synchronized (logRollerLock) {
this.logRoller.interrupt();
}
if (abortRequested) {
if (this.fsOk) {
try {
this.log.close();
LOG.info("On abort, closed hlog");
}
 catch (IOException e) {
LOG.error("Unable to close log in abort",RemoteExceptionHandler.checkIOException(e));
}
closeAllRegions();
}
LOG.info("aborting server at: " + serverInfo.getServerAddress().toString());
}
 else {
ArrayList<HRegion> closedRegions=closeAllRegions();
try {
log.closeAndDelete();
}
 catch (IOException e) {
LOG.error("Close and delete failed",RemoteExceptionHandler.checkIOException(e));
}
try {
HMsg[] exitMsg=new HMsg[closedRegions.size() + 1];
exitMsg[0]=new HMsg(HMsg.MSG_REPORT_EXITING);
int i=1;
for (HRegion region : closedRegions) {
exitMsg[i++]=new HMsg(HMsg.MSG_REPORT_CLOSE,region.getRegionInfo());
}
LOG.info("telling master that region server is shutting down at: " + serverInfo.getServerAddress().toString());
hbaseMaster.regionServerReport(serverInfo,exitMsg);
}
 catch (IOException e) {
LOG.warn("Failed to send exiting message to master: ",RemoteExceptionHandler.checkIOException(e));
}
LOG.info("stopping server at: " + serverInfo.getServerAddress().toString());
}
join();
LOG.info(Thread.currentThread().getName() + " exiting");
}
