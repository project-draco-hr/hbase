{
  int commonPrefix=0;
  previous.invalidate();
  do {
    int comp;
    if (samePrefixComparator != null) {
      commonPrefix=Math.min(commonPrefix,current.lastCommonPrefix);
      commonPrefix+=ByteBufferUtils.findCommonPrefix(key,offset + commonPrefix,length - commonPrefix,current.keyBuffer,commonPrefix,current.keyLength - commonPrefix);
      comp=samePrefixComparator.compareIgnoringPrefix(commonPrefix,key,offset,length,current.keyBuffer,0,current.keyLength);
    }
 else {
      comp=comparator.compare(key,offset,length,current.keyBuffer,0,current.keyLength);
    }
    if (comp == 0) {
      if (seekBefore) {
        if (!previous.isValid()) {
          throw new IllegalStateException("Cannot seekBefore if " + "positioned at the first key in the block: key=" + Bytes.toStringBinary(key,offset,length));
        }
        moveToPrevious();
        return 1;
      }
      return 0;
    }
    if (comp < 0) {
      if (previous.isValid()) {
        moveToPrevious();
      }
      return 1;
    }
    if (currentBuffer.hasRemaining()) {
      previous.copyFromNext(current);
      decodeNext();
    }
 else {
      break;
    }
  }
 while (true);
  return 1;
}
