{
  long totalRequestSize=buf.length;
  int offset=0;
  CodedInputStream cis=CodedInputStream.newInstance(buf,offset,buf.length);
  int headerSize=cis.readRawVarint32();
  offset=cis.getTotalBytesRead();
  RequestHeader header=RequestHeader.newBuilder().mergeFrom(buf,offset,headerSize).build();
  offset+=headerSize;
  int id=header.getCallId();
  if (LOG.isDebugEnabled()) {
    LOG.debug("RequestHeader " + TextFormat.shortDebugString(header) + " totalRequestSize: "+ totalRequestSize+ " bytes");
  }
  if ((totalRequestSize + callQueueSize.get()) > maxQueueSize) {
    final Call callTooBig=new Call(id,null,null,null,this,responder,totalRequestSize,null);
    ByteArrayOutputStream responseBuffer=new ByteArrayOutputStream();
    setupResponse(responseBuffer,callTooBig,new CallQueueTooBigException(),"Call queue is full, is ipc.server.max.callqueue.size too small?");
    responder.doRespond(callTooBig);
    return;
  }
  Method method=null;
  Message param=null;
  CellScanner cellScanner=null;
  try {
    if (header.hasRequestParam() && header.getRequestParam()) {
      method=methodCache.getMethod(this.protocol,header.getMethodName());
      Message m=methodCache.getMethodArgType(method);
      if (m != null) {
        Builder builder=null;
        builder=m.newBuilderForType();
        cis=CodedInputStream.newInstance(buf,offset,buf.length);
        int paramSize=cis.readRawVarint32();
        offset+=cis.getTotalBytesRead();
        if (builder != null) {
          builder.mergeFrom(buf,offset,paramSize);
          param=builder.build();
        }
        offset+=paramSize;
      }
    }
    if (header.hasCellBlockMeta()) {
      cellScanner=ipcUtil.createCellScanner(this.codec,this.compressionCodec,buf,offset,buf.length);
    }
  }
 catch (  Throwable t) {
    String msg="Unable to read call parameter from client " + getHostAddress();
    LOG.warn(msg,t);
    final Call readParamsFailedCall=new Call(id,null,null,null,this,responder,totalRequestSize,null);
    ByteArrayOutputStream responseBuffer=new ByteArrayOutputStream();
    setupResponse(responseBuffer,readParamsFailedCall,t,msg + "; " + t.getMessage());
    responder.doRespond(readParamsFailedCall);
    return;
  }
  Call call=null;
  if (header.hasTraceInfo()) {
    call=new Call(id,method,param,cellScanner,this,responder,totalRequestSize,new TraceInfo(header.getTraceInfo().getTraceId(),header.getTraceInfo().getParentId()));
  }
 else {
    call=new Call(id,method,param,cellScanner,this,responder,totalRequestSize,null);
  }
  callQueueSize.add(totalRequestSize);
  Pair<RequestHeader,Message> headerAndParam=new Pair<RequestHeader,Message>(header,param);
  if (priorityCallQueue != null && getQosLevel(headerAndParam) > highPriorityLevel) {
    priorityCallQueue.put(call);
  }
 else   if (replicationQueue != null && getQosLevel(headerAndParam) == HConstants.REPLICATION_QOS) {
    replicationQueue.put(call);
  }
 else {
    callQueue.put(call);
  }
}
