{
  DataInputStream dis=new DataInputStream(new ByteArrayInputStream(buf));
  RpcRequestHeader request=RpcRequestHeader.parseDelimitedFrom(dis);
  int id=request.getCallId();
  long callSize=buf.length;
  if (LOG.isDebugEnabled()) {
    LOG.debug(" got call #" + id + ", "+ callSize+ " bytes");
  }
  if ((callSize + callQueueSize.get()) > maxQueueSize) {
    final Call callTooBig=new Call(id,null,this,responder,callSize,null);
    ByteArrayOutputStream responseBuffer=new ByteArrayOutputStream();
    setupResponse(responseBuffer,callTooBig,Status.FATAL,IOException.class.getName(),"Call queue is full, is ipc.server.max.callqueue.size too small?");
    responder.doRespond(callTooBig);
    return;
  }
  RpcRequestBody rpcRequestBody;
  try {
    rpcRequestBody=RpcRequestBody.parseDelimitedFrom(dis);
  }
 catch (  Throwable t) {
    LOG.warn("Unable to read call parameters for client " + getHostAddress(),t);
    final Call readParamsFailedCall=new Call(id,null,this,responder,callSize,null);
    ByteArrayOutputStream responseBuffer=new ByteArrayOutputStream();
    setupResponse(responseBuffer,readParamsFailedCall,Status.FATAL,t.getClass().getName(),"IPC server unable to read call parameters: " + t.getMessage());
    responder.doRespond(readParamsFailedCall);
    return;
  }
  Call call;
  if (request.hasTinfo()) {
    call=new Call(id,rpcRequestBody,this,responder,callSize,new TraceInfo(request.getTinfo().getTraceId(),request.getTinfo().getParentId()));
  }
 else {
    call=new Call(id,rpcRequestBody,this,responder,callSize,null);
  }
  callQueueSize.add(callSize);
  if (priorityCallQueue != null && getQosLevel(rpcRequestBody) > highPriorityLevel) {
    priorityCallQueue.put(call);
    updateCallQueueLenMetrics(priorityCallQueue);
  }
 else   if (replicationQueue != null && getQosLevel(rpcRequestBody) == HConstants.REPLICATION_QOS) {
    replicationQueue.put(call);
    updateCallQueueLenMetrics(replicationQueue);
  }
 else {
    callQueue.put(call);
    updateCallQueueLenMetrics(callQueue);
  }
}
