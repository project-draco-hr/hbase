{
  this.bindAddress=bindAddress;
  this.conf=conf;
  this.port=port;
  this.handlerCount=handlerCount;
  this.priorityHandlerCount=priorityHandlerCount;
  this.socketSendBufferSize=0;
  this.maxQueueLength=this.conf.getInt("ipc.server.max.callqueue.length",handlerCount * DEFAULT_MAX_CALLQUEUE_LENGTH_PER_HANDLER);
  this.maxQueueSize=this.conf.getInt("ipc.server.max.callqueue.size",DEFAULT_MAX_CALLQUEUE_SIZE);
  this.readThreads=conf.getInt("ipc.server.read.threadpool.size",10);
  this.callQueue=new LinkedBlockingQueue<Call>(maxQueueLength);
  if (priorityHandlerCount > 0) {
    this.priorityCallQueue=new LinkedBlockingQueue<Call>(maxQueueLength);
  }
 else {
    this.priorityCallQueue=null;
  }
  this.highPriorityLevel=highPriorityLevel;
  this.maxIdleTime=2 * conf.getInt("ipc.client.connection.maxidletime",1000);
  this.maxConnectionsToNuke=conf.getInt("ipc.client.kill.max",10);
  this.thresholdIdleConnections=conf.getInt("ipc.client.idlethreshold",4000);
  this.purgeTimeout=conf.getLong("ipc.client.call.purge.timeout",2 * HConstants.DEFAULT_HBASE_RPC_TIMEOUT);
  this.numOfReplicationHandlers=conf.getInt("hbase.regionserver.replication.handler.count",3);
  if (numOfReplicationHandlers > 0) {
    this.replicationQueue=new LinkedBlockingQueue<Call>(maxQueueSize);
  }
  listener=new Listener();
  this.port=listener.getAddress().getPort();
  this.rpcMetrics=new HBaseRpcMetrics(serverName,Integer.toString(this.port));
  this.tcpNoDelay=conf.getBoolean("ipc.server.tcpnodelay",true);
  this.tcpKeepAlive=conf.getBoolean("ipc.server.tcpkeepalive",true);
  this.warnDelayedCalls=conf.getInt(WARN_DELAYED_CALLS,DEFAULT_WARN_DELAYED_CALLS);
  this.delayedCalls=new AtomicInteger(0);
  responder=new Responder();
  this.authorize=conf.getBoolean(HADOOP_SECURITY_AUTHORIZATION,false);
  this.isSecurityEnabled=UserGroupInformation.isSecurityEnabled();
  if (isSecurityEnabled) {
    HBaseSaslRpcServer.init(conf);
  }
}
