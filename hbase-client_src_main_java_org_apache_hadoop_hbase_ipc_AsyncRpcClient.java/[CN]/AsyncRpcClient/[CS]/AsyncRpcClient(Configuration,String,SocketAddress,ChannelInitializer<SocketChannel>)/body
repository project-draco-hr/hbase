{
  super(configuration,clusterId,localAddress);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Starting async Hbase RPC client");
  }
  Pair<EventLoopGroup,Class<? extends Channel>> eventLoopGroupAndChannelClass;
  this.useGlobalEventLoopGroup=conf.getBoolean(USE_GLOBAL_EVENT_LOOP_GROUP,true);
  if (useGlobalEventLoopGroup) {
    eventLoopGroupAndChannelClass=getGlobalEventLoopGroup(configuration);
  }
 else {
    eventLoopGroupAndChannelClass=createEventLoopGroup(configuration);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Use " + (useGlobalEventLoopGroup ? "global" : "individual") + " event loop group "+ eventLoopGroupAndChannelClass.getFirst().getClass().getSimpleName());
  }
  this.connections=new PoolMap<>(getPoolType(configuration),getPoolSize(configuration));
  this.failedServers=new FailedServers(configuration);
  int operationTimeout=configuration.getInt(HConstants.HBASE_CLIENT_OPERATION_TIMEOUT,HConstants.DEFAULT_HBASE_CLIENT_OPERATION_TIMEOUT);
  this.bootstrap=new Bootstrap();
  bootstrap.group(eventLoopGroupAndChannelClass.getFirst()).channel(eventLoopGroupAndChannelClass.getSecond()).option(ChannelOption.ALLOCATOR,PooledByteBufAllocator.DEFAULT).option(ChannelOption.TCP_NODELAY,tcpNoDelay).option(ChannelOption.SO_KEEPALIVE,tcpKeepAlive).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,operationTimeout);
  if (channelInitializer == null) {
    channelInitializer=DEFAULT_CHANNEL_INITIALIZER;
  }
  bootstrap.handler(channelInitializer);
  if (localAddress != null) {
    bootstrap.localAddress(localAddress);
  }
}
