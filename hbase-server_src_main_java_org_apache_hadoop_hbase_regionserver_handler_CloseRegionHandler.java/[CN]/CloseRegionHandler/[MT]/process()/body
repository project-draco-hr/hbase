{
  try {
    String name=regionInfo.getRegionNameAsString();
    LOG.debug("Processing close of " + name);
    String encodedRegionName=regionInfo.getEncodedName();
    HRegion region=this.rsServices.getFromOnlineRegions(encodedRegionName);
    if (region == null) {
      LOG.warn("Received CLOSE for region " + name + " but currently not serving - ignoring");
      if (zk) {
        LOG.error("The znode is not modified as we are not serving " + name);
      }
      return;
    }
    try {
      if (zk && !ZKAssign.checkClosingState(server.getZooKeeper(),regionInfo,expectedVersion)) {
        return;
      }
      if (region.close(abort) == null) {
        LOG.warn("Can't close region: was already closed during close(): " + regionInfo.getRegionNameAsString());
        return;
      }
    }
 catch (    KeeperException ke) {
      server.abort("Unrecoverable exception while checking state with zk " + regionInfo.getRegionNameAsString() + ", still finishing close",ke);
      throw new RuntimeException(ke);
    }
catch (    IOException ioe) {
      server.abort("Unrecoverable exception while closing region " + regionInfo.getRegionNameAsString() + ", still finishing close",ioe);
      throw new RuntimeException(ioe);
    }
    this.rsServices.removeFromOnlineRegions(region,destination);
    if (this.zk) {
      if (setClosedState(this.expectedVersion,region)) {
        LOG.debug("Set closed state in zk for " + name + " on "+ this.server.getServerName());
      }
 else {
        LOG.debug("Set closed state in zk UNSUCCESSFUL for " + name + " on "+ this.server.getServerName());
      }
    }
    LOG.debug("Closed " + region.getRegionNameAsString());
  }
  finally {
    this.rsServices.getRegionsInTransitionInRS().remove(this.regionInfo.getEncodedNameAsBytes());
  }
}
