{
  try {
    String name=regionInfo.getRegionNameAsString();
    LOG.debug("Processing close of " + name);
    String encodedRegionName=regionInfo.getEncodedName();
    HRegion region=this.rsServices.getFromOnlineRegions(encodedRegionName);
    if (region == null) {
      LOG.warn("Received CLOSE for region " + name + " but currently not serving - ignoring");
      if (zk) {
        LOG.error("The znode is not modified as we are not serving " + name);
      }
      return;
    }
    try {
      if (zk && !ZKAssign.checkClosingState(server.getZooKeeper(),regionInfo,expectedVersion)) {
        return;
      }
      if (region.close(abort) == null) {
        LOG.warn("Can't close region: was already closed during close(): " + regionInfo.getRegionNameAsString());
        return;
      }
    }
 catch (    Throwable t) {
      server.abort("Unrecoverable exception while closing region " + regionInfo.getRegionNameAsString() + ", still finishing close",t);
      throw new RuntimeException(t);
    }
    this.rsServices.removeFromOnlineRegions(regionInfo.getEncodedName(),destination);
    if (this.zk) {
      if (setClosedState(this.expectedVersion,region)) {
        LOG.debug("set region closed state in zk successfully for region " + name + " sn name: "+ this.server.getServerName());
      }
 else {
        LOG.debug("set region closed state in zk unsuccessfully for region " + name + " sn name: "+ this.server.getServerName());
      }
    }
    LOG.debug("Closed region " + region.getRegionNameAsString());
  }
  finally {
    this.rsServices.getRegionsInTransitionInRS().remove(this.regionInfo.getEncodedNameAsBytes());
  }
}
