{
  try {
    long rowKeyBase;
    byte[][] columnFamilies=dataGenerator.getColumnFamilies();
    while ((rowKeyBase=nextKeyToWrite.getAndIncrement()) < endKey) {
      byte[] rowKey=dataGenerator.getDeterministicUniqueKey(rowKeyBase);
      Put put=new Put(rowKey);
      numKeys.addAndGet(1);
      int columnCount=0;
      for (      byte[] cf : columnFamilies) {
        byte[][] columns=dataGenerator.generateColumnsForCf(rowKey,cf);
        int numTags;
        if (minNumTags == maxNumTags) {
          numTags=minNumTags;
        }
 else {
          numTags=minNumTags + random.nextInt(maxNumTags - minNumTags);
        }
        Tag[] tags=new Tag[numTags];
        for (        byte[] column : columns) {
          byte[] value=dataGenerator.generateValue(rowKey,cf,column);
          byte[] tag=LoadTestTool.generateData(random,minTagLength + random.nextInt(maxTagLength - minTagLength));
          if (useTags) {
            for (int n=0; n < numTags; n++) {
              Tag t=new Tag((byte)n,tag);
              tags[n]=t;
            }
            put.add(cf,column,value,tags);
          }
 else {
            put.add(cf,column,value);
          }
          ++columnCount;
          if (!isMultiPut) {
            insert(table,put,rowKeyBase);
            numCols.addAndGet(1);
            put=new Put(rowKey);
          }
        }
        long rowKeyHash=Arrays.hashCode(rowKey);
        put.add(cf,MUTATE_INFO,HConstants.EMPTY_BYTE_ARRAY);
        put.add(cf,INCREMENT,Bytes.toBytes(rowKeyHash));
        if (!isMultiPut) {
          insert(table,put,rowKeyBase);
          numCols.addAndGet(1);
          put=new Put(rowKey);
        }
      }
      if (isMultiPut) {
        if (verbose) {
          LOG.debug("Preparing put for key = [" + rowKey + "], "+ columnCount+ " columns");
        }
        insert(table,put,rowKeyBase);
        numCols.addAndGet(columnCount);
      }
      if (trackWroteKeys) {
        wroteKeys.add(rowKeyBase);
      }
    }
  }
  finally {
    try {
      table.close();
    }
 catch (    IOException e) {
      LOG.error("Error closing table",e);
    }
    numThreadsWorking.decrementAndGet();
  }
}
