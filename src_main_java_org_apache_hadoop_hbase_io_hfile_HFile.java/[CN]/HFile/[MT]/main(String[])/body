{
  try {
    Options options=new Options();
    options.addOption("v","verbose",false,"Verbose output; emits file and meta data delimiters");
    options.addOption("p","printkv",false,"Print key/value pairs");
    options.addOption("e","printkey",false,"Print keys");
    options.addOption("m","printmeta",false,"Print meta data of file");
    options.addOption("b","printblocks",false,"Print block index meta data");
    options.addOption("k","checkrow",false,"Enable row order check; looks for out-of-order keys");
    options.addOption("a","checkfamily",false,"Enable family check");
    options.addOption("f","file",true,"File to scan. Pass full-path; e.g. hdfs://a:9000/hbase/.META./12/34");
    options.addOption("r","region",true,"Region to scan. Pass region name; e.g. '.META.,,1'");
    if (args.length == 0) {
      HelpFormatter formatter=new HelpFormatter();
      formatter.printHelp("HFile ",options,true);
      System.exit(-1);
    }
    CommandLineParser parser=new PosixParser();
    CommandLine cmd=parser.parse(options,args);
    boolean verbose=cmd.hasOption("v");
    boolean printValue=cmd.hasOption("p");
    boolean printKey=cmd.hasOption("e") || printValue;
    boolean printMeta=cmd.hasOption("m");
    boolean printBlocks=cmd.hasOption("b");
    boolean checkRow=cmd.hasOption("k");
    boolean checkFamily=cmd.hasOption("a");
    Configuration conf=HBaseConfiguration.create();
    conf.set("fs.defaultFS",conf.get(org.apache.hadoop.hbase.HConstants.HBASE_DIR));
    conf.set("fs.default.name",conf.get(org.apache.hadoop.hbase.HConstants.HBASE_DIR));
    ArrayList<Path> files=new ArrayList<Path>();
    if (cmd.hasOption("f")) {
      files.add(new Path(cmd.getOptionValue("f")));
    }
    if (cmd.hasOption("r")) {
      String regionName=cmd.getOptionValue("r");
      byte[] rn=Bytes.toBytes(regionName);
      byte[][] hri=HRegionInfo.parseRegionName(rn);
      Path rootDir=FSUtils.getRootDir(conf);
      Path tableDir=new Path(rootDir,Bytes.toString(hri[0]));
      String enc=HRegionInfo.encodeRegionName(rn);
      Path regionDir=new Path(tableDir,enc);
      if (verbose)       System.out.println("region dir -> " + regionDir);
      List<Path> regionFiles=getStoreFiles(FileSystem.get(conf),regionDir);
      if (verbose)       System.out.println("Number of region files found -> " + regionFiles.size());
      if (verbose) {
        int i=1;
        for (        Path p : regionFiles) {
          if (verbose)           System.out.println("Found file[" + i++ + "] -> "+ p);
        }
      }
      files.addAll(regionFiles);
    }
    for (    Path file : files) {
      if (verbose)       System.out.println("Scanning -> " + file);
      FileSystem fs=file.getFileSystem(conf);
      if (!fs.exists(file)) {
        System.err.println("ERROR, file doesnt exist: " + file);
        continue;
      }
      HFile.Reader reader=new HFile.Reader(fs,file,null,false,false);
      Map<byte[],byte[]> fileInfo=reader.loadFileInfo();
      int count=0;
      if (verbose || printKey || checkRow|| checkFamily) {
        HFileScanner scanner=reader.getScanner(false,false);
        scanner.seekTo();
        KeyValue pkv=null;
        do {
          KeyValue kv=scanner.getKeyValue();
          if (printKey) {
            System.out.print("K: " + kv);
            if (printValue) {
              System.out.print(" V: " + Bytes.toStringBinary(kv.getValue()));
            }
            System.out.println();
          }
          if (checkRow && pkv != null) {
            if (Bytes.compareTo(pkv.getRow(),kv.getRow()) > 0) {
              System.err.println("WARNING, previous row is greater then" + " current row\n\tfilename -> " + file + "\n\tprevious -> "+ Bytes.toStringBinary(pkv.getKey())+ "\n\tcurrent  -> "+ Bytes.toStringBinary(kv.getKey()));
            }
          }
          if (checkFamily) {
            String fam=Bytes.toString(kv.getFamily());
            if (!file.toString().contains(fam)) {
              System.err.println("WARNING, filename does not match kv family," + "\n\tfilename -> " + file + "\n\tkeyvalue -> "+ Bytes.toStringBinary(kv.getKey()));
            }
            if (pkv != null && Bytes.compareTo(pkv.getFamily(),kv.getFamily()) != 0) {
              System.err.println("WARNING, previous kv has different family" + " compared to current key\n\tfilename -> " + file + "\n\tprevious -> "+ Bytes.toStringBinary(pkv.getKey())+ "\n\tcurrent  -> "+ Bytes.toStringBinary(kv.getKey()));
            }
          }
          pkv=kv;
          count++;
        }
 while (scanner.next());
      }
      if (verbose || printKey) {
        System.out.println("Scanned kv count -> " + count);
      }
      if (printMeta) {
        System.out.println("Block index size as per heapsize: " + reader.indexSize());
        System.out.println(reader.toString());
        System.out.println(reader.getTrailerInfo());
        System.out.println("Fileinfo:");
        for (        Map.Entry<byte[],byte[]> e : fileInfo.entrySet()) {
          System.out.print(Bytes.toString(e.getKey()) + " = ");
          if (Bytes.compareTo(e.getKey(),Bytes.toBytes("MAX_SEQ_ID_KEY")) == 0) {
            long seqid=Bytes.toLong(e.getValue());
            System.out.println(seqid);
          }
 else           if (Bytes.compareTo(e.getKey(),Bytes.toBytes("TIMERANGE")) == 0) {
            TimeRangeTracker timeRangeTracker=new TimeRangeTracker();
            Writables.copyWritable(e.getValue(),timeRangeTracker);
            System.out.println(timeRangeTracker.getMinimumTimestamp() + "...." + timeRangeTracker.getMaximumTimestamp());
          }
 else           if (Bytes.compareTo(e.getKey(),FileInfo.AVG_KEY_LEN) == 0 || Bytes.compareTo(e.getKey(),FileInfo.AVG_VALUE_LEN) == 0) {
            System.out.println(Bytes.toInt(e.getValue()));
          }
 else {
            System.out.println(Bytes.toStringBinary(e.getValue()));
          }
        }
        ByteBuffer b=reader.getMetaBlock("BLOOM_FILTER_META",false);
        if (b != null) {
          BloomFilter bloomFilter=new ByteBloomFilter(b);
          System.out.println("BloomSize: " + bloomFilter.getByteSize());
          System.out.println("No of Keys in bloom: " + bloomFilter.getKeyCount());
          System.out.println("Max Keys for bloom: " + bloomFilter.getMaxKeys());
        }
 else {
          System.out.println("Could not get bloom data from meta block");
        }
      }
      if (printBlocks) {
        System.out.println("Block Index:");
        System.out.println(reader.blockIndex);
      }
      reader.close();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}
