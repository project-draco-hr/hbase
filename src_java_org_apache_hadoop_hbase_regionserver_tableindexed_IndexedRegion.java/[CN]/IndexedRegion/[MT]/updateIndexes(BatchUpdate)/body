{
  List<IndexSpecification> indexesToUpdate=new LinkedList<IndexSpecification>();
  for (  IndexSpecification index : getIndexes()) {
    if (possiblyAppliesToIndex(index,batchUpdate)) {
      indexesToUpdate.add(index);
    }
  }
  if (indexesToUpdate.size() == 0) {
    return;
  }
  NavigableSet<byte[]> neededColumns=getColumnsForIndexes(indexesToUpdate);
  NavigableMap<byte[],byte[]> newColumnValues=getColumnsFromBatchUpdate(batchUpdate);
  Map<byte[],Cell> oldColumnCells=super.getFull(batchUpdate.getRow(),neededColumns,HConstants.LATEST_TIMESTAMP,1,null);
  for (  BatchOperation op : batchUpdate) {
    if (!op.isPut()) {
      Cell current=oldColumnCells.get(op.getColumn());
      if (current != null) {
        Cell[] older=Cell.createSingleCellArray(super.get(batchUpdate.getRow(),op.getColumn(),current.getTimestamp(),1));
        if (older != null && older.length > 0) {
          newColumnValues.put(op.getColumn(),older[0].getValue());
        }
      }
    }
  }
  for (  Entry<byte[],Cell> oldEntry : oldColumnCells.entrySet()) {
    if (!newColumnValues.containsKey(oldEntry.getKey())) {
      newColumnValues.put(oldEntry.getKey(),oldEntry.getValue().getValue());
    }
  }
  Iterator<IndexSpecification> indexIterator=indexesToUpdate.iterator();
  while (indexIterator.hasNext()) {
    IndexSpecification indexSpec=indexIterator.next();
    if (!IndexMaintenanceUtils.doesApplyToIndex(indexSpec,newColumnValues)) {
      indexIterator.remove();
    }
  }
  SortedMap<byte[],byte[]> oldColumnValues=convertToValueMap(oldColumnCells);
  for (  IndexSpecification indexSpec : indexesToUpdate) {
    removeOldIndexEntry(indexSpec,batchUpdate.getRow(),oldColumnValues);
    updateIndex(indexSpec,batchUpdate.getRow(),newColumnValues);
  }
}
