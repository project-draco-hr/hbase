{
  boolean keepSeeking=false;
  Cell key=originalKey;
  do {
    Cell firstKeyOnRow=CellUtil.createFirstOnRow(key);
    SortedSet<Cell> cellHead=cellSetAtCreation.headSet(firstKeyOnRow);
    Cell cellSetBeforeRow=cellHead.isEmpty() ? null : cellHead.last();
    SortedSet<Cell> snapshotHead=snapshotAtCreation.headSet(firstKeyOnRow);
    Cell snapshotBeforeRow=snapshotHead.isEmpty() ? null : snapshotHead.last();
    Cell lastCellBeforeRow=getHighest(cellSetBeforeRow,snapshotBeforeRow);
    if (lastCellBeforeRow == null) {
      theNext=null;
      return false;
    }
    Cell firstKeyOnPreviousRow=CellUtil.createFirstOnRow(lastCellBeforeRow);
    this.stopSkippingCellsIfNextRow=true;
    seek(firstKeyOnPreviousRow);
    this.stopSkippingCellsIfNextRow=false;
    if (peek() == null || comparator.compareRows(peek(),firstKeyOnPreviousRow) > 0) {
      keepSeeking=true;
      key=firstKeyOnPreviousRow;
      continue;
    }
 else {
      keepSeeking=false;
    }
  }
 while (keepSeeking);
  return true;
}
