{
  final byte[] tableName=Bytes.toBytes("testRollBackShudBeSuccessfulIfStoreFileIsEmpty");
  createTableAndWait(tableName,HConstants.CATALOG_FAMILY);
  List<HRegion> regions=cluster.getRegions(tableName);
  HRegionInfo hri=getAndCheckSingleTableRegion(regions);
  int tableRegionIndex=ensureTableRegionNotOnSameServerAsMeta(admin,hri);
  int regionServerIndex=cluster.getServerWith(regions.get(0).getRegionName());
  HRegionServer regionServer=cluster.getRegionServer(regionServerIndex);
  this.admin.setBalancerRunning(false,true);
  cluster.getMaster().setCatalogJanitorEnabled(false);
  try {
    HRegionServer server=cluster.getRegionServer(tableRegionIndex);
    printOutRegions(server,"Initial regions: ");
    final HRegion region=findSplittableRegion(regions);
    assertTrue("not able to find a splittable region",region != null);
    SplitTransaction st=new MockedSplitTransaction(region,Bytes.toBytes("row2"));
    try {
      st.prepare();
      st.execute(regionServer,regionServer);
    }
 catch (    IOException e) {
      List<HRegion> daughters=cluster.getRegions(tableName);
      assertTrue(daughters.size() == 1);
      String node=ZKAssign.getNodeName(regionServer.getZooKeeper(),region.getRegionInfo().getEncodedName());
      assertFalse(ZKUtil.checkExists(regionServer.getZooKeeper(),node) == -1);
      assertTrue(st.rollback(regionServer,regionServer));
      assertTrue(ZKUtil.checkExists(regionServer.getZooKeeper(),node) == -1);
    }
  }
  finally {
    admin.setBalancerRunning(true,false);
    cluster.getMaster().setCatalogJanitorEnabled(true);
  }
}
