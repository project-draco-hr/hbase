{
  final TableName tableName=TableName.valueOf("testRITStateForRollback");
  try {
    HTable t=createTableAndWait(tableName.getName(),Bytes.toBytes("cf"));
    final List<HRegion> regions=cluster.getRegions(tableName);
    final HRegionInfo hri=getAndCheckSingleTableRegion(regions);
    int regionServerIndex=cluster.getServerWith(regions.get(0).getRegionName());
    final HRegionServer regionServer=cluster.getRegionServer(regionServerIndex);
    insertData(tableName.getName(),admin,t);
    t.close();
    this.admin.setBalancerRunning(false,true);
    cluster.getMaster().setCatalogJanitorEnabled(false);
    final HRegion region=findSplittableRegion(regions);
    assertTrue("not able to find a splittable region",region != null);
    region.getCoprocessorHost().load(FailingSplitRegionObserver.class,Coprocessor.PRIORITY_USER,region.getBaseConf());
    this.admin.split(region.getRegionName(),new byte[]{42});
    FailingSplitRegionObserver.latch.await();
    LOG.info("Waiting for region to come out of RIT");
    TESTING_UTIL.waitFor(60000,1000,new Waiter.Predicate<Exception>(){
      @Override public boolean evaluate() throws Exception {
        RegionStates regionStates=cluster.getMaster().getAssignmentManager().getRegionStates();
        Map<String,RegionState> rit=regionStates.getRegionsInTransition();
        return !rit.containsKey(hri.getEncodedName());
      }
    }
);
  }
  finally {
    admin.setBalancerRunning(true,false);
    cluster.getMaster().setCatalogJanitorEnabled(true);
    TESTING_UTIL.deleteTable(tableName);
  }
}
