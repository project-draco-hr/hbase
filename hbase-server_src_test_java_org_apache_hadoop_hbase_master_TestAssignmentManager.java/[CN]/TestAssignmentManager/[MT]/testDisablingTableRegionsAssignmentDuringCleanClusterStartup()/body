{
  this.server.getConfiguration().setClass(HConstants.HBASE_MASTER_LOADBALANCER_CLASS,MockedLoadBalancer.class,LoadBalancer.class);
  Mockito.when(this.serverManager.getOnlineServers()).thenReturn(new HashMap<ServerName,ServerLoad>(0));
  List<ServerName> destServers=new ArrayList<ServerName>(1);
  destServers.add(SERVERNAME_A);
  Mockito.when(this.serverManager.createDestinationServersList()).thenReturn(destServers);
  HTU.getConfiguration().setInt(HConstants.MASTER_PORT,0);
  CoordinatedStateManager csm=CoordinatedStateManagerFactory.getCoordinatedStateManager(HTU.getConfiguration());
  Server server=new HMaster(HTU.getConfiguration(),csm);
  AssignmentManagerWithExtrasForTesting am=setUpMockedAssignmentManager(server,this.serverManager);
  Whitebox.setInternalState(server,"metaTableLocator",Mockito.mock(MetaTableLocator.class));
  Whitebox.setInternalState(server,"shortCircuitConnection",am.getConnection());
  AtomicBoolean gate=new AtomicBoolean(false);
  if (balancer instanceof MockedLoadBalancer) {
    ((MockedLoadBalancer)balancer).setGateVariable(gate);
  }
  try {
    am.getTableStateManager().setTableState(REGIONINFO.getTable(),Table.State.DISABLING);
    am.joinCluster();
    assertFalse("Assign should not be invoked for disabling table regions during clean cluster startup.",gate.get());
    assertTrue("Table should be disabled.",am.getTableStateManager().isTableState(REGIONINFO.getTable(),Table.State.DISABLED));
  }
  finally {
    this.server.getConfiguration().setClass(HConstants.HBASE_MASTER_LOADBALANCER_CLASS,SimpleLoadBalancer.class,LoadBalancer.class);
    am.getTableStateManager().setTableState(REGIONINFO.getTable(),Table.State.ENABLED);
    am.shutdown();
  }
}
