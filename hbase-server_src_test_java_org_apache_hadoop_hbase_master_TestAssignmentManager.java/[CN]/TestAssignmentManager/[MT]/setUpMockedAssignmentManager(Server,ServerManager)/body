{
  CatalogTracker ct=Mockito.mock(CatalogTracker.class);
  ClientProtos.ClientService.BlockingInterface ri=Mockito.mock(ClientProtos.ClientService.BlockingInterface.class);
  Result r=MetaMockingUtil.getMetaTableRowResult(REGIONINFO,SERVERNAME_A);
  final ScanResponse.Builder builder=ScanResponse.newBuilder();
  builder.setMoreResults(true);
  builder.addCellsPerResult(r.size());
  final List<CellScannable> rows=new ArrayList<CellScannable>(1);
  rows.add(r);
  Answer<ScanResponse> ans=new Answer<ClientProtos.ScanResponse>(){
    @Override public ScanResponse answer(    InvocationOnMock invocation) throws Throwable {
      PayloadCarryingRpcController controller=(PayloadCarryingRpcController)invocation.getArguments()[0];
      if (controller != null) {
        controller.setCellScanner(CellUtil.createCellScanner(rows));
      }
      return builder.build();
    }
  }
;
  if (enabling) {
    Mockito.when(ri.scan((RpcController)Mockito.any(),(ScanRequest)Mockito.any())).thenAnswer(ans).thenAnswer(ans).thenAnswer(ans).thenAnswer(ans).thenAnswer(ans).thenReturn(ScanResponse.newBuilder().setMoreResults(false).build());
  }
 else {
    Mockito.when(ri.scan((RpcController)Mockito.any(),(ScanRequest)Mockito.any())).thenAnswer(ans);
  }
  GetResponse.Builder getBuilder=GetResponse.newBuilder();
  getBuilder.setResult(ProtobufUtil.toResult(r));
  Mockito.when(ri.get((RpcController)Mockito.any(),(GetRequest)Mockito.any())).thenReturn(getBuilder.build());
  HConnection connection=HConnectionTestingUtility.getMockedConnectionAndDecorate(HTU.getConfiguration(),null,ri,SERVERNAME_B,REGIONINFO);
  Mockito.when(ct.getConnection()).thenReturn(connection);
  ExecutorService executor=startupMasterExecutor("mockedAMExecutor");
  this.balancer=LoadBalancerFactory.getLoadBalancer(server.getConfiguration());
  AssignmentManagerWithExtrasForTesting am=new AssignmentManagerWithExtrasForTesting(server,manager,ct,this.balancer,executor,new NullTableLockManager());
  return am;
}
