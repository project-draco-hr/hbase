{
  this.server.getConfiguration().setClass(HConstants.HBASE_MASTER_LOADBALANCER_CLASS,MockedLoadBalancer.class,LoadBalancer.class);
  AssignmentManagerWithExtrasForTesting am=setUpMockedAssignmentManager(this.server,this.serverManager);
  try {
    AtomicBoolean gate=new AtomicBoolean(false);
    if (balancer instanceof MockedLoadBalancer) {
      ((MockedLoadBalancer)balancer).setGateVariable(gate);
    }
    ZKAssign.createNodeOffline(this.watcher,REGIONINFO,SERVERNAME_A);
    int v=ZKAssign.getVersion(this.watcher,REGIONINFO);
    ZKAssign.transitionNode(this.watcher,REGIONINFO,SERVERNAME_A,EventType.M_ZK_REGION_OFFLINE,EventType.RS_ZK_REGION_FAILED_OPEN,v);
    String path=ZKAssign.getNodeName(this.watcher,REGIONINFO.getEncodedName());
    am.getRegionStates().updateRegionState(REGIONINFO,State.OPENING,SERVERNAME_A);
    am.regionPlans.put(REGIONINFO.getEncodedName(),new RegionPlan(REGIONINFO,null,SERVERNAME_A));
    RegionPlan regionPlan=am.regionPlans.get(REGIONINFO.getEncodedName());
    List<ServerName> serverList=new ArrayList<ServerName>(2);
    serverList.add(SERVERNAME_B);
    Mockito.when(this.serverManager.createDestinationServersList(SERVERNAME_A)).thenReturn(serverList);
    am.nodeDataChanged(path);
    while (!gate.get()) {
      Thread.sleep(10);
    }
    RegionPlan newRegionPlan=am.regionPlans.get(REGIONINFO.getEncodedName());
    while (newRegionPlan == null) {
      Thread.sleep(10);
      newRegionPlan=am.regionPlans.get(REGIONINFO.getEncodedName());
    }
    assertNotSame("Same region plan should not come",regionPlan,newRegionPlan);
    assertTrue("Destination servers should be different.",!(regionPlan.getDestination().equals(newRegionPlan.getDestination())));
    Mocking.waitForRegionPendingOpenInRIT(am,REGIONINFO.getEncodedName());
  }
  finally {
    this.server.getConfiguration().setClass(HConstants.HBASE_MASTER_LOADBALANCER_CLASS,SimpleLoadBalancer.class,LoadBalancer.class);
    am.getExecutorService().shutdown();
    am.shutdown();
  }
}
