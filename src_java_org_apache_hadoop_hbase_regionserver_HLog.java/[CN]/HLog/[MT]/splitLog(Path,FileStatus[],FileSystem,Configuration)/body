{
  Map<byte[],SequenceFile.Writer> logWriters=new TreeMap<byte[],SequenceFile.Writer>(Bytes.BYTES_COMPARATOR);
  try {
    for (int i=0; i < logfiles.length; i++) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Splitting " + (i + 1) + " of "+ logfiles.length+ ": "+ logfiles[i].getPath()+ ", length="+ logfiles[i].getLen());
      }
      long length=logfiles[i].getLen();
      HLogKey key=new HLogKey();
      KeyValue val=new KeyValue();
      try {
        SequenceFile.Reader in=new SequenceFile.Reader(fs,logfiles[i].getPath(),conf);
        try {
          int count=0;
          for (; in.next(key,val); count++) {
            byte[] tableName=key.getTablename();
            byte[] regionName=key.getRegionName();
            SequenceFile.Writer w=logWriters.get(regionName);
            if (w == null) {
              Path logfile=new Path(HRegion.getRegionDir(HTableDescriptor.getTableDir(rootDir,tableName),HRegionInfo.encodeRegionName(regionName)),HREGION_OLDLOGFILE_NAME);
              Path oldlogfile=null;
              SequenceFile.Reader old=null;
              if (fs.exists(logfile)) {
                LOG.warn("Old log file " + logfile + " already exists. Copying existing file to new file");
                oldlogfile=new Path(logfile.toString() + ".old");
                fs.rename(logfile,oldlogfile);
                old=new SequenceFile.Reader(fs,oldlogfile,conf);
              }
              w=SequenceFile.createWriter(fs,conf,logfile,HLogKey.class,KeyValue.class,getCompressionType(conf));
              logWriters.put(regionName,w);
              if (LOG.isDebugEnabled()) {
                LOG.debug("Creating new log file writer for path " + logfile + " and region "+ Bytes.toString(regionName));
              }
              if (old != null) {
                HLogKey oldkey=new HLogKey();
                KeyValue oldval=new KeyValue();
                for (; old.next(oldkey,oldval); count++) {
                  if (LOG.isDebugEnabled() && count > 0 && count % 10000 == 0) {
                    LOG.debug("Copied " + count + " edits");
                  }
                  w.append(oldkey,oldval);
                }
                old.close();
                fs.delete(oldlogfile,true);
              }
            }
            w.append(key,val);
          }
          if (LOG.isDebugEnabled()) {
            LOG.debug("Applied " + count + " total edits from "+ logfiles[i].getPath().toString());
          }
        }
 catch (        IOException e) {
          e=RemoteExceptionHandler.checkIOException(e);
          if (!(e instanceof EOFException)) {
            LOG.warn("Exception processing " + logfiles[i].getPath() + " -- continuing. Possible DATA LOSS!",e);
          }
        }
 finally {
          try {
            in.close();
          }
 catch (          IOException e) {
            LOG.warn("Close in finally threw exception -- continuing",e);
          }
          fs.delete(logfiles[i].getPath(),true);
        }
      }
 catch (      IOException e) {
        if (length <= 0) {
          LOG.warn("Empty log, continuing: " + logfiles[i]);
          continue;
        }
        throw e;
      }
    }
  }
  finally {
    for (    SequenceFile.Writer w : logWriters.values()) {
      w.close();
    }
  }
}
