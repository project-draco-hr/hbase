{
  byte[] regionToFlush=null;
  this.cacheFlushLock.lock();
  try {
    if (closed) {
      return regionToFlush;
    }
synchronized (updateLock) {
      Path oldFile=cleanupCurrentWriter();
      this.old_filenum=this.filenum;
      this.filenum=System.currentTimeMillis();
      Path newPath=computeFilename(this.filenum);
      this.writer=SequenceFile.createWriter(this.fs,this.conf,newPath,HLogKey.class,HLogEdit.class,fs.getConf().getInt("io.file.buffer.size",4096),fs.getDefaultReplication(),this.blocksize,SequenceFile.CompressionType.NONE,new DefaultCodec(),null,new Metadata());
      LOG.info((oldFile != null ? "Closed " + oldFile + ", entries="+ this.numEntries+ ". " : "") + "New log writer: " + FSUtils.getPath(newPath));
      if (this.outputfiles.size() > 0) {
        if (this.lastSeqWritten.size() <= 0) {
          LOG.debug("Last sequence written is empty. Deleting all old hlogs");
          for (          Map.Entry<Long,Path> e : this.outputfiles.entrySet()) {
            deleteLogFile(e.getValue(),e.getKey());
          }
          this.outputfiles.clear();
        }
 else {
          regionToFlush=cleanOldLogs();
        }
      }
      this.numEntries.set(0);
      updateLock.notifyAll();
    }
  }
  finally {
    this.cacheFlushLock.unlock();
  }
  return regionToFlush;
}
