{
  this.cacheFlushLock.lock();
  try {
    if (closed) {
      return;
    }
synchronized (updateLock) {
      if (this.writer != null) {
        this.writer.close();
        Path p=computeFilename(old_filenum);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Closing current log writer " + FSUtils.getPath(p));
        }
        if (filenum > 0) {
synchronized (this.sequenceLock) {
            this.outputfiles.put(Long.valueOf(this.logSeqNum - 1),p);
          }
        }
      }
      old_filenum=filenum;
      filenum=System.currentTimeMillis();
      Path newPath=computeFilename(filenum);
      this.writer=SequenceFile.createWriter(this.fs,this.conf,newPath,HLogKey.class,HLogEdit.class,getCompressionType(this.conf));
      LOG.info("New log writer created at " + FSUtils.getPath(newPath));
      if (this.outputfiles.size() > 0) {
        if (this.lastSeqWritten.size() <= 0) {
          LOG.debug("Last sequence written is empty. Deleting all old hlogs");
          for (          Map.Entry<Long,Path> e : this.outputfiles.entrySet()) {
            deleteLogFile(e.getValue(),e.getKey());
          }
          this.outputfiles.clear();
        }
 else {
          Long oldestOutstandingSeqNum=Collections.min(this.lastSeqWritten.values());
          TreeSet<Long> sequenceNumbers=new TreeSet<Long>(this.outputfiles.headMap((Long.valueOf(oldestOutstandingSeqNum.longValue() + 1L))).keySet());
          if (LOG.isDebugEnabled()) {
            byte[] oldestRegion=null;
            for (            Map.Entry<byte[],Long> e : this.lastSeqWritten.entrySet()) {
              if (e.getValue().longValue() == oldestOutstandingSeqNum.longValue()) {
                oldestRegion=e.getKey();
                break;
              }
            }
            if (LOG.isDebugEnabled() && sequenceNumbers.size() > 0) {
              LOG.debug("Found " + sequenceNumbers.size() + " logs to remove "+ "using oldest outstanding seqnum of "+ oldestOutstandingSeqNum+ " from region "+ oldestRegion);
            }
          }
          if (sequenceNumbers.size() > 0) {
            for (            Long seq : sequenceNumbers) {
              deleteLogFile(this.outputfiles.remove(seq),seq);
            }
          }
        }
      }
      this.numEntries=0;
    }
  }
  finally {
    this.cacheFlushLock.unlock();
  }
}
