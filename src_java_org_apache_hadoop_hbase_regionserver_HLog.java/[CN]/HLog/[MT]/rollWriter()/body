{
  if (this.writer != null && this.numEntries.get() <= 0) {
    return null;
  }
  byte[] regionToFlush=null;
  this.cacheFlushLock.lock();
  try {
    if (closed) {
      return regionToFlush;
    }
synchronized (updateLock) {
      Path oldFile=cleanupCurrentWriter(this.filenum);
      this.filenum=System.currentTimeMillis();
      Path newPath=computeFilename(this.filenum);
      this.writer=SequenceFile.createWriter(this.fs,this.conf,newPath,HLogKey.class,KeyValue.class,fs.getConf().getInt("io.file.buffer.size",4096),fs.getDefaultReplication(),this.blocksize,SequenceFile.CompressionType.NONE,new DefaultCodec(),null,new Metadata());
      LOG.info((oldFile != null ? "Roll " + FSUtils.getPath(oldFile) + ", entries="+ this.numEntries.get()+ ", calcsize="+ this.editsSize.get()+ ", filesize="+ this.fs.getFileStatus(oldFile).getLen()+ ". " : "") + "New hlog " + FSUtils.getPath(newPath));
      if (this.outputfiles.size() > 0) {
        if (this.lastSeqWritten.size() <= 0) {
          LOG.debug("Last sequence written is empty. Deleting all old hlogs");
          for (          Map.Entry<Long,Path> e : this.outputfiles.entrySet()) {
            deleteLogFile(e.getValue(),e.getKey());
          }
          this.outputfiles.clear();
        }
 else {
          regionToFlush=cleanOldLogs();
        }
      }
      this.numEntries.set(0);
      this.editsSize.set(0);
      updateLock.notifyAll();
    }
  }
  finally {
    this.cacheFlushLock.unlock();
  }
  return regionToFlush;
}
