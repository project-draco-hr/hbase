{
  if (!fs.exists(srcDir)) {
    return;
  }
  FileStatus logfiles[]=fs.listStatus(srcDir);
  if (logfiles == null || logfiles.length == 0) {
    return;
  }
  LOG.info("splitting " + logfiles.length + " log(s) in "+ srcDir.toString());
  Map<byte[],SequenceFile.Writer> logWriters=new TreeMap<byte[],SequenceFile.Writer>(Bytes.BYTES_COMPARATOR);
  try {
    for (int i=0; i < logfiles.length; i++) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Splitting " + i + " of "+ logfiles.length+ ": "+ logfiles[i].getPath());
      }
      if (logfiles[i].getLen() <= 0) {
        LOG.info("Skipping " + logfiles[i].toString() + " because zero length");
        continue;
      }
      HLogKey key=new HLogKey();
      HLogEdit val=new HLogEdit();
      SequenceFile.Reader in=new SequenceFile.Reader(fs,logfiles[i].getPath(),conf);
      try {
        int count=0;
        for (; in.next(key,val); count++) {
          byte[] tableName=key.getTablename();
          byte[] regionName=key.getRegionName();
          SequenceFile.Writer w=logWriters.get(regionName);
          if (w == null) {
            Path logfile=new Path(HRegion.getRegionDir(HTableDescriptor.getTableDir(rootDir,tableName),HRegionInfo.encodeRegionName(regionName)),HREGION_OLDLOGFILE_NAME);
            Path oldlogfile=null;
            SequenceFile.Reader old=null;
            if (fs.exists(logfile)) {
              LOG.warn("Old log file " + logfile + " already exists. Copying existing file to new file");
              oldlogfile=new Path(logfile.toString() + ".old");
              fs.rename(logfile,oldlogfile);
              old=new SequenceFile.Reader(fs,oldlogfile,conf);
            }
            w=SequenceFile.createWriter(fs,conf,logfile,HLogKey.class,HLogEdit.class,getCompressionType(conf));
            logWriters.put(regionName,w);
            if (LOG.isDebugEnabled()) {
              LOG.debug("Creating new log file writer for path " + logfile + " and region "+ regionName);
            }
            if (old != null) {
              HLogKey oldkey=new HLogKey();
              HLogEdit oldval=new HLogEdit();
              for (; old.next(oldkey,oldval); count++) {
                if (LOG.isDebugEnabled() && count > 0 && count % 10000 == 0) {
                  LOG.debug("Copied " + count + " edits");
                }
                w.append(oldkey,oldval);
              }
              old.close();
              fs.delete(oldlogfile,true);
            }
          }
          w.append(key,val);
        }
        if (LOG.isDebugEnabled()) {
          LOG.debug("Applied " + count + " total edits from "+ logfiles[i].getPath().toString());
        }
      }
 catch (      IOException e) {
        e=RemoteExceptionHandler.checkIOException(e);
        if (!(e instanceof EOFException)) {
          LOG.warn("Exception processing " + logfiles[i].getPath() + " -- continuing. Possible DATA LOSS!",e);
        }
      }
 finally {
        try {
          in.close();
        }
 catch (        IOException e) {
          LOG.warn("Close in finally threw exception -- continuing",e);
        }
        fs.delete(logfiles[i].getPath(),true);
      }
    }
  }
  finally {
    for (    SequenceFile.Writer w : logWriters.values()) {
      w.close();
    }
  }
  try {
    fs.delete(srcDir,true);
  }
 catch (  IOException e) {
    e=RemoteExceptionHandler.checkIOException(e);
    IOException io=new IOException("Cannot delete: " + srcDir);
    io.initCause(e);
    throw io;
  }
  LOG.info("log file splitting completed for " + srcDir.toString());
}
