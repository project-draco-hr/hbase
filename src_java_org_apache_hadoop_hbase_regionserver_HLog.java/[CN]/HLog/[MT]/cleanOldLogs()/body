{
  byte[] regionToFlush=null;
  Long oldestOutstandingSeqNum=getOldestOutstandingSeqNum();
  TreeSet<Long> sequenceNumbers=new TreeSet<Long>(this.outputfiles.headMap((Long.valueOf(oldestOutstandingSeqNum.longValue() + 1L))).keySet());
  byte[] oldestRegion=null;
  if (LOG.isDebugEnabled()) {
    oldestRegion=getOldestRegion(oldestOutstandingSeqNum);
    LOG.debug("Found " + sequenceNumbers.size() + " logs to remove "+ " out of total "+ this.outputfiles.size()+ "; "+ "oldest outstanding seqnum is "+ oldestOutstandingSeqNum+ " from region "+ Bytes.toString(oldestRegion));
  }
  if (sequenceNumbers.size() > 0) {
    for (    Long seq : sequenceNumbers) {
      deleteLogFile(this.outputfiles.remove(seq),seq);
    }
  }
  int countOfLogs=this.outputfiles.size() - sequenceNumbers.size();
  if (countOfLogs > this.maxLogs) {
    regionToFlush=oldestRegion != null ? oldestRegion : getOldestRegion(oldestOutstandingSeqNum);
    LOG.info("Too many logs: logs=" + countOfLogs + ", maxlogs="+ this.maxLogs+ "; forcing flush of region with oldest edits: "+ Bytes.toString(regionToFlush));
  }
  return regionToFlush;
}
