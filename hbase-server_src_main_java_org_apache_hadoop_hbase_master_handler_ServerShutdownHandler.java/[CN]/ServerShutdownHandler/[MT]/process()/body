{
  boolean hasLogReplayWork=false;
  final ServerName serverName=this.serverName;
  try {
    AssignmentManager am=services.getAssignmentManager();
    if (isCarryingMeta() || !am.isFailoverCleanupDone()) {
      this.services.getServerManager().processDeadServer(serverName,this.shouldSplitHlog);
      return;
    }
    NavigableMap<HRegionInfo,Result> hris=null;
    while (!this.server.isStopped()) {
      try {
        this.server.getCatalogTracker().waitForMeta();
        if (!this.server.isStopped()) {
          hris=MetaReader.getServerUserRegions(this.server.getCatalogTracker(),this.serverName);
        }
        break;
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw (InterruptedIOException)new InterruptedIOException().initCause(e);
      }
catch (      IOException ioe) {
        LOG.info("Received exception accessing hbase:meta during server shutdown of " + serverName + ", retrying hbase:meta read",ioe);
      }
    }
    if (this.server.isStopped()) {
      throw new IOException("Server is stopped");
    }
    this.services.getMasterFileSystem().setLogRecoveryMode();
    boolean distributedLogReplay=(this.services.getMasterFileSystem().getLogRecoveryMode() == RecoveryMode.LOG_REPLAY);
    try {
      if (this.shouldSplitHlog) {
        LOG.info("Splitting logs for " + serverName + " before assignment.");
        if (distributedLogReplay) {
          LOG.info("Mark regions in recovery before assignment.");
          Set<ServerName> serverNames=new HashSet<ServerName>();
          serverNames.add(serverName);
          this.services.getMasterFileSystem().prepareLogReplay(serverNames);
        }
 else {
          this.services.getMasterFileSystem().splitLog(serverName);
        }
        am.getRegionStates().logSplit(serverName);
      }
 else {
        LOG.info("Skipping log splitting for " + serverName);
      }
    }
 catch (    IOException ioe) {
      resubmit(serverName,ioe);
    }
    List<HRegionInfo> regionsInTransition=am.processServerShutdown(serverName);
    LOG.info("Reassigning " + ((hris == null) ? 0 : hris.size()) + " region(s) that "+ (serverName == null ? "null" : serverName)+ " was carrying (and "+ regionsInTransition.size()+ " regions(s) that were opening on this server)");
    List<HRegionInfo> toAssignRegions=new ArrayList<HRegionInfo>();
    toAssignRegions.addAll(regionsInTransition);
    if (hris != null) {
      RegionStates regionStates=am.getRegionStates();
      for (      Map.Entry<HRegionInfo,Result> e : hris.entrySet()) {
        HRegionInfo hri=e.getKey();
        if (regionsInTransition.contains(hri)) {
          continue;
        }
        String encodedName=hri.getEncodedName();
        Lock lock=am.acquireRegionLock(encodedName);
        try {
          RegionState rit=regionStates.getRegionTransitionState(hri);
          if (processDeadRegion(hri,e.getValue(),am,server.getCatalogTracker())) {
            ServerName addressFromAM=regionStates.getRegionServerOfRegion(hri);
            if (addressFromAM != null && !addressFromAM.equals(this.serverName)) {
              LOG.info("Skip assigning region " + hri.getRegionNameAsString() + " because it has been opened in "+ addressFromAM.getServerName());
              continue;
            }
            if (rit != null) {
              if (rit.getServerName() != null && !rit.isOnServer(serverName)) {
                LOG.info("Skip assigning region in transition on other server" + rit);
                continue;
              }
              try {
                LOG.info("Reassigning region with rs = " + rit + " and deleting zk node if exists");
                ZKAssign.deleteNodeFailSilent(services.getZooKeeper(),hri);
                regionStates.updateRegionState(hri,State.OFFLINE);
              }
 catch (              KeeperException ke) {
                this.server.abort("Unexpected ZK exception deleting unassigned node " + hri,ke);
                return;
              }
            }
 else             if (regionStates.isRegionInState(hri,State.SPLITTING_NEW,State.MERGING_NEW)) {
              regionStates.regionOffline(hri);
            }
            toAssignRegions.add(hri);
          }
 else           if (rit != null) {
            if (rit.isPendingCloseOrClosing() && am.getTableStateManager().isTableState(hri.getTable(),ZooKeeperProtos.Table.State.DISABLED,ZooKeeperProtos.Table.State.DISABLING)) {
              regionStates.updateRegionState(hri,State.OFFLINE);
              am.deleteClosingOrClosedNode(hri,rit.getServerName());
              am.offlineDisabledRegion(hri);
            }
 else {
              LOG.warn("THIS SHOULD NOT HAPPEN: unexpected region in transition " + rit + " not to be assigned by SSH of server "+ serverName);
            }
          }
        }
  finally {
          lock.unlock();
        }
      }
    }
    try {
      am.assign(toAssignRegions);
    }
 catch (    InterruptedException ie) {
      LOG.error("Caught " + ie + " during round-robin assignment");
      throw (InterruptedIOException)new InterruptedIOException().initCause(ie);
    }
    if (this.shouldSplitHlog && distributedLogReplay) {
      for (      HRegionInfo hri : toAssignRegions) {
        try {
          if (!am.waitOnRegionToClearRegionsInTransition(hri,regionAssignmentWaitTimeout)) {
            LOG.warn("Region " + hri.getEncodedName() + " didn't complete assignment in time");
          }
        }
 catch (        InterruptedException ie) {
          throw new InterruptedIOException("Caught " + ie + " during waitOnRegionToClearRegionsInTransition");
        }
      }
      this.services.getExecutorService().submit(new LogReplayHandler(this.server,this.services,this.deadServers,this.serverName));
      hasLogReplayWork=true;
    }
  }
  finally {
    this.deadServers.finish(serverName);
  }
  if (!hasLogReplayWork) {
    LOG.info("Finished processing of shutdown of " + serverName);
  }
}
