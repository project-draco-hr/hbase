{
  boolean hasLogReplayWork=false;
  final ServerName serverName=this.serverName;
  try {
    AssignmentManager am=services.getAssignmentManager();
    ServerManager serverManager=services.getServerManager();
    if (isCarryingMeta() || !am.isFailoverCleanupDone()) {
      serverManager.processDeadServer(serverName,this.shouldSplitWal);
      return;
    }
    Set<HRegionInfo> hris=null;
    try {
      server.getMetaTableLocator().waitMetaRegionLocation(server.getZooKeeper());
      if (BaseLoadBalancer.tablesOnMaster(server.getConfiguration())) {
        while (!this.server.isStopped() && serverManager.countOfRegionServers() < 2) {
          Thread.sleep(100);
        }
      }
      hris=am.getRegionStates().getServerRegions(serverName);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
      throw (InterruptedIOException)new InterruptedIOException().initCause(e);
    }
    if (this.server.isStopped()) {
      throw new IOException("Server is stopped");
    }
    this.services.getMasterFileSystem().setLogRecoveryMode();
    boolean distributedLogReplay=(this.services.getMasterFileSystem().getLogRecoveryMode() == RecoveryMode.LOG_REPLAY);
    try {
      if (this.shouldSplitWal) {
        if (distributedLogReplay) {
          LOG.info("Mark regions in recovery for crashed server " + serverName + " before assignment; regions="+ hris);
          MasterFileSystem mfs=this.services.getMasterFileSystem();
          mfs.prepareLogReplay(serverName,hris);
        }
 else {
          LOG.info("Splitting logs for " + serverName + " before assignment; region count="+ (hris == null ? 0 : hris.size()));
          this.services.getMasterFileSystem().splitLog(serverName);
        }
        am.getRegionStates().logSplit(serverName);
      }
 else {
        LOG.info("Skipping log splitting for " + serverName);
      }
    }
 catch (    IOException ioe) {
      resubmit(serverName,ioe);
    }
    List<HRegionInfo> toAssignRegions=new ArrayList<HRegionInfo>();
    int replicaCount=services.getConfiguration().getInt(HConstants.META_REPLICAS_NUM,HConstants.DEFAULT_META_REPLICA_NUM);
    for (int i=1; i < replicaCount; i++) {
      HRegionInfo metaHri=RegionReplicaUtil.getRegionInfoForReplica(HRegionInfo.FIRST_META_REGIONINFO,i);
      if (am.isCarryingMetaReplica(serverName,metaHri)) {
        LOG.info("Reassigning meta replica" + metaHri + " that was on "+ serverName);
        toAssignRegions.add(metaHri);
      }
    }
    List<HRegionInfo> regionsInTransition=am.processServerShutdown(serverName);
    LOG.info("Reassigning " + ((hris == null) ? 0 : hris.size()) + " region(s) that "+ (serverName == null ? "null" : serverName)+ " was carrying (and "+ regionsInTransition.size()+ " regions(s) that were opening on this server)");
    toAssignRegions.addAll(regionsInTransition);
    if (hris != null && !hris.isEmpty()) {
      RegionStates regionStates=am.getRegionStates();
      for (      HRegionInfo hri : hris) {
        if (regionsInTransition.contains(hri)) {
          continue;
        }
        String encodedName=hri.getEncodedName();
        Lock lock=am.acquireRegionLock(encodedName);
        try {
          RegionState rit=regionStates.getRegionTransitionState(hri);
          if (processDeadRegion(hri,am)) {
            ServerName addressFromAM=regionStates.getRegionServerOfRegion(hri);
            if (addressFromAM != null && !addressFromAM.equals(this.serverName)) {
              LOG.info("Skip assigning region " + hri.getRegionNameAsString() + " because it has been opened in "+ addressFromAM.getServerName());
              continue;
            }
            if (rit != null) {
              if (rit.getServerName() != null && !rit.isOnServer(serverName)) {
                LOG.info("Skip assigning region in transition on other server" + rit);
                continue;
              }
              LOG.info("Reassigning region with rs = " + rit);
              regionStates.updateRegionState(hri,RegionState.State.OFFLINE);
            }
 else             if (regionStates.isRegionInState(hri,RegionState.State.SPLITTING_NEW,RegionState.State.MERGING_NEW)) {
              regionStates.updateRegionState(hri,RegionState.State.OFFLINE);
            }
            toAssignRegions.add(hri);
          }
 else           if (rit != null) {
            if ((rit.isClosing() || rit.isFailedClose() || rit.isOffline()) && am.getTableStateManager().isTableState(hri.getTable(),TableState.State.DISABLED,TableState.State.DISABLING) || am.getReplicasToClose().contains(hri)) {
              regionStates.updateRegionState(hri,RegionState.State.OFFLINE);
              am.offlineDisabledRegion(hri);
            }
 else {
              LOG.warn("THIS SHOULD NOT HAPPEN: unexpected region in transition " + rit + " not to be assigned by SSH of server "+ serverName);
            }
          }
        }
  finally {
          lock.unlock();
        }
      }
    }
    try {
      am.assign(toAssignRegions);
    }
 catch (    InterruptedException ie) {
      LOG.error("Caught " + ie + " during round-robin assignment");
      throw (InterruptedIOException)new InterruptedIOException().initCause(ie);
    }
catch (    IOException ioe) {
      LOG.info("Caught " + ioe + " during region assignment, will retry");
      serverManager.processDeadServer(serverName,this.shouldSplitWal && distributedLogReplay);
      return;
    }
    if (this.shouldSplitWal && distributedLogReplay) {
      for (      HRegionInfo hri : toAssignRegions) {
        try {
          if (!am.waitOnRegionToClearRegionsInTransition(hri,regionAssignmentWaitTimeout)) {
            LOG.warn("Region " + hri.getEncodedName() + " didn't complete assignment in time");
          }
        }
 catch (        InterruptedException ie) {
          throw new InterruptedIOException("Caught " + ie + " during waitOnRegionToClearRegionsInTransition");
        }
      }
      this.services.getExecutorService().submit(new LogReplayHandler(this.server,this.services,this.deadServers,this.serverName));
      hasLogReplayWork=true;
    }
  }
  finally {
    this.deadServers.finish(serverName);
  }
  if (!hasLogReplayWork) {
    LOG.info("Finished processing of shutdown of " + serverName);
  }
}
