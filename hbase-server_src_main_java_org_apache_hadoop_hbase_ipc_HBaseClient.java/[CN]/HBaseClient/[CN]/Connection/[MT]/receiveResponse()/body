{
  if (shouldCloseConnection.get()) {
    return;
  }
  touch();
  try {
    RpcResponseHeader response=RpcResponseHeader.parseDelimitedFrom(in);
    if (response == null) {
      throw new EOFException();
    }
    int id=response.getCallId();
    if (LOG.isDebugEnabled())     LOG.debug(getName() + " got value #" + id);
    Call call=calls.get(id);
    Status status=response.getStatus();
    if (status == Status.SUCCESS) {
      Message rpcResponseType;
      try {
        rpcResponseType=ProtobufRpcClientEngine.Invoker.getReturnProtoType(getMethod(remoteId.getProtocol(),call.param.getMethodName()));
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
      Builder builder=rpcResponseType.newBuilderForType();
      builder.mergeDelimitedFrom(in);
      Message value=builder.build();
      if (call != null) {
        call.setValue(value);
      }
      calls.remove(id);
    }
 else     if (status == Status.ERROR) {
      RpcException exceptionResponse=RpcException.parseDelimitedFrom(in);
      if (call != null) {
        call.setException(new RemoteException(exceptionResponse.getExceptionName(),exceptionResponse.getStackTrace()));
        calls.remove(id);
      }
    }
 else     if (status == Status.FATAL) {
      RpcException exceptionResponse=RpcException.parseDelimitedFrom(in);
      markClosed(new RemoteException(exceptionResponse.getExceptionName(),exceptionResponse.getStackTrace()));
    }
  }
 catch (  IOException e) {
    if (e instanceof SocketTimeoutException && remoteId.rpcTimeout > 0) {
      closeException=e;
    }
 else {
      markClosed(e);
    }
  }
 finally {
    if (remoteId.rpcTimeout > 0) {
      cleanupCalls(remoteId.rpcTimeout);
    }
  }
}
