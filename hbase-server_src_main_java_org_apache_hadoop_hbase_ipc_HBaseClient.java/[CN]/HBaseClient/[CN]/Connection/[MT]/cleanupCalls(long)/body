{
  Iterator<Entry<Integer,Call>> itor=calls.entrySet().iterator();
  while (itor.hasNext()) {
    Call c=itor.next().getValue();
    long waitTime=EnvironmentEdgeManager.currentTimeMillis() - c.getStartTime();
    if (waitTime >= rpcTimeout) {
      if (this.closeException == null) {
        this.closeException=new CallTimeoutException("Call id=" + c.id + ", waitTime="+ waitTime+ ", rpcTimetout="+ rpcTimeout);
      }
      c.setException(this.closeException);
synchronized (c) {
        c.notifyAll();
      }
      itor.remove();
    }
 else {
      break;
    }
  }
  try {
    if (!calls.isEmpty()) {
      Call firstCall=calls.get(calls.firstKey());
      long maxWaitTime=EnvironmentEdgeManager.currentTimeMillis() - firstCall.getStartTime();
      if (maxWaitTime < rpcTimeout) {
        rpcTimeout-=maxWaitTime;
      }
    }
    if (!shouldCloseConnection.get()) {
      closeException=null;
      if (socket != null) {
        socket.setSoTimeout((int)rpcTimeout);
      }
    }
  }
 catch (  SocketException e) {
    LOG.debug("Couldn't lower timeout, which may result in longer than expected calls");
  }
}
