{
  System.out.println("Reading file of type: " + fileType);
  Path path=new Path(ROOT_DIR,fileType + ".Performance");
  System.out.println("Input file size: " + fs.getFileStatus(path).getLen());
  long totalBytesRead=0;
  ByteBuffer val;
  ByteBuffer key;
  startTime();
  FSDataInputStream fin=fs.open(path);
  if ("HFile".equals(fileType)) {
    HFile.Reader reader=new HFile.Reader(path,fs.open(path),fs.getFileStatus(path).getLen(),null,false,false);
    reader.loadFileInfo();
switch (method) {
case 0:
case 1:
default :
{
        HFileScanner scanner=reader.getScanner(false,false);
        scanner.seekTo();
        for (long l=0; l < rows; l++) {
          key=scanner.getKey();
          val=scanner.getValue();
          totalBytesRead+=key.limit() + val.limit();
          scanner.next();
        }
      }
    break;
}
}
 else if ("SequenceFile".equals(fileType)) {
SequenceFile.Reader reader;
reader=new SequenceFile.Reader(fs,path,new Configuration());
if (reader.getCompressionCodec() != null) {
  printlnWithTimestamp("Compression codec class: " + reader.getCompressionCodec().getClass());
}
 else printlnWithTimestamp("Compression codec class: " + "none");
BytesWritable keyBsw=new BytesWritable();
BytesWritable valBsw=new BytesWritable();
for (long l=0; l < rows; l++) {
  reader.next(keyBsw,valBsw);
  totalBytesRead+=keyBsw.getSize() + valBsw.getSize();
}
reader.close();
}
 else {
throw new IOException("File Type not supported.");
}
fin.close();
stopTime();
printlnWithTimestamp("Finished in " + getIntervalMillis() + "ms");
printlnWithTimestamp("Data read: ");
printlnWithTimestamp("  rate  = " + totalBytesRead / getIntervalMillis() * 1000 / 1024 / 1024 + "MB/s");
printlnWithTimestamp("  total = " + totalBytesRead + "B");
printlnWithTimestamp("File read: ");
printlnWithTimestamp("  rate  = " + fs.getFileStatus(path).getLen() / getIntervalMillis() * 1000 / 1024 / 1024 + "MB/s");
printlnWithTimestamp("  total = " + fs.getFileStatus(path).getLen() + "B");
}
