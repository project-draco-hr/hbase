{
  htable1.setWriteBufferSize(1024);
  htable1.setAutoFlush(false);
  for (int i=0; i < NB_ROWS_IN_BIG_BATCH; i++) {
    Put put=new Put(Bytes.toBytes(i));
    put.add(famName,row,row);
    htable1.put(put);
  }
  htable1.flushCommits();
  Scan scan=new Scan();
  ResultScanner scanner=htable1.getScanner(scan);
  Result[] res=scanner.next(NB_ROWS_IN_BIG_BATCH);
  scanner.close();
  assertEquals(NB_ROWS_IN_BIG_BATCH,res.length);
  scan=new Scan();
  for (int i=0; i < NB_RETRIES; i++) {
    scanner=htable2.getScanner(scan);
    res=scanner.next(NB_ROWS_IN_BIG_BATCH);
    scanner.close();
    if (res.length != NB_ROWS_IN_BIG_BATCH) {
      if (i == NB_RETRIES - 1) {
        int lastRow=-1;
        for (        Result result : res) {
          int currentRow=Bytes.toInt(result.getRow());
          for (int row=lastRow + 1; row < currentRow; row++) {
            LOG.error("Row missing: " + row);
          }
          lastRow=currentRow;
        }
        LOG.error("Last row: " + lastRow);
        fail("Waited too much time for normal batch replication, " + res.length + " instead of "+ NB_ROWS_IN_BIG_BATCH);
      }
 else {
        LOG.info("Only got " + res.length + " rows");
        Thread.sleep(SLEEP_TIME);
      }
    }
 else {
      break;
    }
  }
}
