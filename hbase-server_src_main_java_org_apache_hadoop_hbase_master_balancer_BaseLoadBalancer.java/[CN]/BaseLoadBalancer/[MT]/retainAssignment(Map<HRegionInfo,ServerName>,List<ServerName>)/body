{
  metricsBalancer.incrMiscInvocations();
  if (regions == null || regions.isEmpty()) {
    return null;
  }
  List<ServerName> backupMasters=normalizeServers(servers);
  int numServers=servers == null ? 0 : servers.size();
  int numBackupMasters=backupMasters == null ? 0 : backupMasters.size();
  if (numServers == 0 && numBackupMasters == 0) {
    LOG.warn("Wanted to do retain assignment but no servers to assign to");
    return null;
  }
  Map<ServerName,List<HRegionInfo>> assignments=new TreeMap<ServerName,List<HRegionInfo>>();
  if (numServers + numBackupMasters == 1) {
    ServerName server=numServers > 0 ? servers.get(0) : backupMasters.get(0);
    assignments.put(server,new ArrayList<HRegionInfo>(regions.keySet()));
    return assignments;
  }
  ArrayListMultimap<String,ServerName> serversByHostname=ArrayListMultimap.create();
  for (  ServerName server : servers) {
    assignments.put(server,new ArrayList<HRegionInfo>());
    if (!server.equals(masterServerName)) {
      serversByHostname.put(server.getHostname(),server);
    }
  }
  if (numBackupMasters > 0) {
    for (    ServerName server : backupMasters) {
      assignments.put(server,new ArrayList<HRegionInfo>());
    }
  }
  Set<String> oldHostsNoLongerPresent=Sets.newTreeSet();
  boolean masterIncluded=servers.contains(masterServerName);
  int numRandomAssignments=0;
  int numRetainedAssigments=0;
  Cluster cluster=createCluster(servers,regions.keySet(),backupMasters,tablesOnMaster);
  for (  Map.Entry<HRegionInfo,ServerName> entry : regions.entrySet()) {
    HRegionInfo region=entry.getKey();
    ServerName oldServerName=entry.getValue();
    List<ServerName> localServers=new ArrayList<ServerName>();
    if (oldServerName != null) {
      localServers=serversByHostname.get(oldServerName.getHostname());
    }
    if (masterIncluded && shouldBeOnMaster(region)) {
      assignments.get(masterServerName).add(region);
      if (localServers.contains(masterServerName)) {
        numRetainedAssigments++;
      }
 else {
        numRandomAssignments++;
      }
    }
 else     if (localServers.isEmpty()) {
      ServerName randomServer=randomAssignment(cluster,region,servers,backupMasters);
      assignments.get(randomServer).add(region);
      numRandomAssignments++;
      if (oldServerName != null)       oldHostsNoLongerPresent.add(oldServerName.getHostname());
    }
 else     if (localServers.size() == 1) {
      ServerName target=localServers.get(0);
      assignments.get(target).add(region);
      cluster.doAssignRegion(region,target);
      numRetainedAssigments++;
    }
 else {
      if (localServers.contains(oldServerName)) {
        assignments.get(oldServerName).add(region);
        cluster.doAssignRegion(region,oldServerName);
      }
 else {
        ServerName target=null;
        for (        ServerName tmp : localServers) {
          if (tmp.getPort() == oldServerName.getPort()) {
            target=tmp;
            break;
          }
        }
        if (target == null) {
          target=randomAssignment(cluster,region,localServers,backupMasters);
        }
        assignments.get(target).add(region);
      }
      numRetainedAssigments++;
    }
  }
  String randomAssignMsg="";
  if (numRandomAssignments > 0) {
    randomAssignMsg=numRandomAssignments + " regions were assigned " + "to random hosts, since the old hosts for these regions are no "+ "longer present in the cluster. These hosts were:\n  "+ Joiner.on("\n  ").join(oldHostsNoLongerPresent);
  }
  LOG.info("Reassigned " + regions.size() + " regions. "+ numRetainedAssigments+ " retained the pre-restart assignment. "+ randomAssignMsg);
  return assignments;
}
