{
  boolean masterIncluded=servers.contains(masterServerName);
  int numServers=servers.size();
  int skipServers=numServers;
  if (masterIncluded) {
    skipServers--;
  }
  int max=(int)Math.ceil((float)numRegions / skipServers);
  int serverIdx=0;
  if (numServers > 1) {
    serverIdx=RANDOM.nextInt(numServers);
  }
  int regionIdx=0;
  for (int j=0; j < numServers; j++) {
    ServerName server=servers.get((j + serverIdx) % numServers);
    if (masterIncluded && server.equals(masterServerName)) {
      continue;
    }
    List<HRegionInfo> serverRegions=new ArrayList<HRegionInfo>(max);
    for (int i=regionIdx; i < numRegions; i+=skipServers) {
      HRegionInfo region=regions.get(offset + i % numRegions);
      if (masterRegions == null || !shouldBeOnMaster(region)) {
        if (cluster.wouldLowerAvailability(region,server)) {
          unassignedRegions.add(region);
        }
 else {
          serverRegions.add(region);
          cluster.doAssignRegion(region,server);
        }
        continue;
      }
      masterRegions.add(region);
    }
    assignments.put(server,serverRegions);
    regionIdx++;
  }
}
