{
  metricsBalancer.incrMiscInvocations();
  if (!excludedServers.isEmpty() && servers != null) {
    servers.removeAll(excludedServers);
  }
  if (regions.isEmpty() || servers.isEmpty()) {
    return null;
  }
  Map<ServerName,List<HRegionInfo>> assignments=new TreeMap<ServerName,List<HRegionInfo>>();
  int numServers=servers.size();
  if (numServers == 1) {
    assignments.put(servers.get(0),new ArrayList<HRegionInfo>(regions));
    return assignments;
  }
  int numRegions=regions.size();
  boolean masterIncluded=servers.contains(masterServerName);
  int skipServers=numServers;
  if (masterIncluded) {
    skipServers--;
  }
  int max=(int)Math.ceil((float)numRegions / skipServers);
  int serverIdx=RANDOM.nextInt(numServers);
  int regionIdx=0;
  for (int j=0; j < numServers; j++) {
    ServerName server=servers.get((j + serverIdx) % numServers);
    if (server.equals(masterServerName)) {
      continue;
    }
    List<HRegionInfo> serverRegions=new ArrayList<HRegionInfo>(max);
    for (int i=regionIdx; i < numRegions; i+=skipServers) {
      HRegionInfo region=regions.get(i % numRegions);
      if (!(masterIncluded && shouldBeOnMaster(region))) {
        serverRegions.add(region);
        continue;
      }
      List<HRegionInfo> masterRegions=assignments.get(masterServerName);
      if (masterRegions == null) {
        masterRegions=new ArrayList<HRegionInfo>(max);
        assignments.put(masterServerName,masterRegions);
      }
      masterRegions.add(region);
    }
    assignments.put(server,serverRegions);
    regionIdx++;
  }
  return assignments;
}
