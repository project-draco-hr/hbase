{
  metricsBalancer.incrMiscInvocations();
  if (regions == null || regions.isEmpty()) {
    return null;
  }
  List<ServerName> backupMasters=normalizeServers(servers);
  int numServers=servers == null ? 0 : servers.size();
  int numBackupMasters=backupMasters == null ? 0 : backupMasters.size();
  if (numServers == 0 && numBackupMasters == 0) {
    LOG.warn("Wanted to do round robin assignment but no servers to assign to");
    return null;
  }
  Map<ServerName,List<HRegionInfo>> assignments=new TreeMap<ServerName,List<HRegionInfo>>();
  if (numServers + numBackupMasters == 1) {
    ServerName server=numServers > 0 ? servers.get(0) : backupMasters.get(0);
    assignments.put(server,new ArrayList<HRegionInfo>(regions));
    return assignments;
  }
  List<HRegionInfo> masterRegions=null;
  if (numServers > 0 && servers.contains(masterServerName)) {
    masterRegions=new ArrayList<HRegionInfo>();
    if (numServers == 1) {
      numServers=0;
    }
  }
  Cluster cluster=createCluster(servers,regions,backupMasters,tablesOnMaster);
  List<HRegionInfo> unassignedRegions=new ArrayList<HRegionInfo>();
  int total=regions.size();
  int numRegions=total * numBackupMasters / (numServers * backupMasterWeight + numBackupMasters);
  if (numRegions > 0) {
    roundRobinAssignment(cluster,regions,unassignedRegions,0,numRegions,backupMasters,masterRegions,assignments);
  }
  int remainder=total - numRegions;
  if (remainder > 0) {
    roundRobinAssignment(cluster,regions,unassignedRegions,numRegions,remainder,servers,masterRegions,assignments);
  }
  if (masterRegions != null && !masterRegions.isEmpty()) {
    assignments.put(masterServerName,masterRegions);
    for (    HRegionInfo r : masterRegions) {
      cluster.doAssignRegion(r,masterServerName);
    }
  }
  List<HRegionInfo> lastFewRegions=new ArrayList<HRegionInfo>();
  int serverIdx=RANDOM.nextInt(numServers);
  for (  HRegionInfo region : unassignedRegions) {
    boolean assigned=false;
    for (int j=0; j < numServers; j++) {
      ServerName serverName=servers.get((j + serverIdx) % numServers);
      if (serverName.equals(masterServerName)) {
        continue;
      }
      if (!cluster.wouldLowerAvailability(region,serverName)) {
        List<HRegionInfo> serverRegions=assignments.get(serverName);
        if (serverRegions == null) {
          serverRegions=new ArrayList<HRegionInfo>();
          assignments.put(serverName,serverRegions);
        }
        serverRegions.add(region);
        cluster.doAssignRegion(region,serverName);
        serverIdx=(j + serverIdx + 1) % numServers;
        assigned=true;
        break;
      }
    }
    if (!assigned) {
      lastFewRegions.add(region);
    }
  }
  for (  HRegionInfo region : lastFewRegions) {
    ServerName server=null;
    if (numServers == 0) {
      int i=RANDOM.nextInt(backupMasters.size());
      server=backupMasters.get(i);
    }
 else {
      do {
        int i=RANDOM.nextInt(numServers);
        server=servers.get(i);
      }
 while (numServers > 1 && server.equals(masterServerName));
    }
    List<HRegionInfo> serverRegions=assignments.get(server);
    if (serverRegions == null) {
      serverRegions=new ArrayList<HRegionInfo>();
      assignments.put(server,serverRegions);
    }
    serverRegions.add(region);
    cluster.doAssignRegion(region,server);
  }
  return assignments;
}
