{
  while (true) {
    long originalPosition=this.inputStream.getPos();
    if (trailerPresent && originalPosition == this.walEditsStopOffset)     return false;
    WALKey.Builder builder=WALKey.newBuilder();
    int size=0;
    try {
      int originalAvailable=this.inputStream.available();
      try {
        int firstByte=this.inputStream.read();
        if (firstByte == -1) {
          throw new EOFException("First byte is negative");
        }
        size=CodedInputStream.readRawVarint32(firstByte,this.inputStream);
        if (this.inputStream.available() < size) {
          throw new EOFException("Available stream not enough for edit, " + "inputStream.available()= " + this.inputStream.available() + ", "+ "entry size= "+ size);
        }
        final InputStream limitedInput=new LimitInputStream(this.inputStream,size);
        builder.mergeFrom(limitedInput);
      }
 catch (      InvalidProtocolBufferException ipbe) {
        throw (EOFException)new EOFException("Invalid PB, EOF? Ignoring; originalPosition=" + originalPosition + ", currentPosition="+ this.inputStream.getPos()+ ", messageSize="+ size+ ", originalAvailable="+ originalAvailable+ ", currentAvailable="+ this.inputStream.available()).initCause(ipbe);
      }
      if (!builder.isInitialized()) {
        throw new EOFException("Partial PB while reading WAL, " + "probably an unexpected EOF, ignoring");
      }
      WALKey walKey=builder.build();
      entry.getKey().readFieldsFromPb(walKey,this.byteStringUncompressor);
      if (!walKey.hasFollowingKvCount() || 0 == walKey.getFollowingKvCount()) {
        LOG.trace("WALKey has no KVs that follow it; trying the next one");
        continue;
      }
      int expectedCells=walKey.getFollowingKvCount();
      long posBefore=this.inputStream.getPos();
      try {
        int actualCells=entry.getEdit().readFromCells(cellDecoder,expectedCells);
        if (expectedCells != actualCells) {
          throw new EOFException("Only read " + actualCells);
        }
      }
 catch (      Exception ex) {
        String posAfterStr="<unknown>";
        try {
          posAfterStr=this.inputStream.getPos() + "";
        }
 catch (        Throwable t) {
          LOG.trace("Error getting pos for error message - ignoring",t);
        }
        String message=" while reading " + expectedCells + " WAL KVs; started reading at "+ posBefore+ " and read up to "+ posAfterStr;
        IOException realEofEx=extractHiddenEof(ex);
        throw (EOFException)new EOFException("EOF " + message).initCause(realEofEx != null ? realEofEx : ex);
      }
      if (trailerPresent && this.inputStream.getPos() > this.walEditsStopOffset) {
        LOG.error("Read WALTrailer while reading WALEdits. hlog: " + this.path + ", inputStream.getPos(): "+ this.inputStream.getPos()+ ", walEditsStopOffset: "+ this.walEditsStopOffset);
        throw new EOFException("Read WALTrailer while reading WALEdits");
      }
    }
 catch (    EOFException eof) {
      LOG.trace("Encountered a malformed edit, seeking back to last good position in file",eof);
      seekOnFs(originalPosition);
      return false;
    }
    return true;
  }
}
