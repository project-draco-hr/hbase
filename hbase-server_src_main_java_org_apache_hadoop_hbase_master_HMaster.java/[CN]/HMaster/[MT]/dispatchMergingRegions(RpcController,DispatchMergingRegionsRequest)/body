{
  final byte[] encodedNameOfRegionA=request.getRegionA().getValue().toByteArray();
  final byte[] encodedNameOfRegionB=request.getRegionB().getValue().toByteArray();
  final boolean forcible=request.getForcible();
  if (request.getRegionA().getType() != RegionSpecifierType.ENCODED_REGION_NAME || request.getRegionB().getType() != RegionSpecifierType.ENCODED_REGION_NAME) {
    LOG.warn("mergeRegions specifier type: expected: " + RegionSpecifierType.ENCODED_REGION_NAME + " actual: region_a="+ request.getRegionA().getType()+ ", region_b="+ request.getRegionB().getType());
  }
  RegionState regionStateA=assignmentManager.getRegionStates().getRegionState(Bytes.toString(encodedNameOfRegionA));
  RegionState regionStateB=assignmentManager.getRegionStates().getRegionState(Bytes.toString(encodedNameOfRegionB));
  if (regionStateA == null || regionStateB == null) {
    throw new ServiceException(new UnknownRegionException(Bytes.toStringBinary(regionStateA == null ? encodedNameOfRegionA : encodedNameOfRegionB)));
  }
  if (!forcible && !HRegionInfo.areAdjacent(regionStateA.getRegion(),regionStateB.getRegion())) {
    throw new ServiceException("Unable to merge not adjacent regions " + regionStateA.getRegion().getRegionNameAsString() + ", "+ regionStateB.getRegion().getRegionNameAsString()+ " where forcible = "+ forcible);
  }
  try {
    dispatchMergingRegions(regionStateA.getRegion(),regionStateB.getRegion(),forcible);
  }
 catch (  IOException ioe) {
    throw new ServiceException(ioe);
  }
  return DispatchMergingRegionsResponse.newBuilder().build();
}
