{
  if (!this.balanceSwitch)   return false;
  int maximumBalanceTime=getBalancerCutoffTime();
  long cutoffTime=System.currentTimeMillis() + maximumBalanceTime;
  boolean balancerRan;
synchronized (this.balancer) {
    if (this.assignmentManager.getRegionStates().isRegionsInTransition()) {
      Map<String,RegionState> regionsInTransition=this.assignmentManager.getRegionStates().getRegionsInTransition();
      LOG.debug("Not running balancer because " + regionsInTransition.size() + " region(s) in transition: "+ org.apache.commons.lang.StringUtils.abbreviate(regionsInTransition.toString(),256));
      return false;
    }
    if (this.serverManager.areDeadServersInProgress()) {
      LOG.debug("Not running balancer because processing dead regionserver(s): " + this.serverManager.getDeadServers());
      return false;
    }
    if (this.cpHost != null) {
      try {
        if (this.cpHost.preBalance()) {
          LOG.debug("Coprocessor bypassing balancer request");
          return false;
        }
      }
 catch (      IOException ioe) {
        LOG.error("Error invoking master coprocessor preBalance()",ioe);
        return false;
      }
    }
    Map<String,Map<ServerName,List<HRegionInfo>>> assignmentsByTable=this.assignmentManager.getRegionStates().getAssignmentsByTable();
    List<RegionPlan> plans=new ArrayList<RegionPlan>();
    this.balancer.setClusterStatus(getClusterStatus());
    for (    Map<ServerName,List<HRegionInfo>> assignments : assignmentsByTable.values()) {
      List<RegionPlan> partialPlans=this.balancer.balanceCluster(assignments);
      if (partialPlans != null)       plans.addAll(partialPlans);
    }
    int rpCount=0;
    long totalRegPlanExecTime=0;
    balancerRan=plans != null;
    if (plans != null && !plans.isEmpty()) {
      for (      RegionPlan plan : plans) {
        LOG.info("balance " + plan);
        long balStartTime=System.currentTimeMillis();
        this.assignmentManager.balance(plan);
        totalRegPlanExecTime+=System.currentTimeMillis() - balStartTime;
        rpCount++;
        if (rpCount < plans.size() && (System.currentTimeMillis() + (totalRegPlanExecTime / rpCount)) > cutoffTime) {
          LOG.debug("No more balancing till next balance run; maximumBalanceTime=" + maximumBalanceTime);
          break;
        }
      }
    }
    if (this.cpHost != null) {
      try {
        this.cpHost.postBalance();
      }
 catch (      IOException ioe) {
        LOG.error("Error invoking master coprocessor postBalance()",ioe);
      }
    }
  }
  return balancerRan;
}
