{
  this.service.startExecutorService(ExecutorType.MASTER_OPEN_REGION,conf.getInt("hbase.master.executor.openregion.threads",5));
  this.service.startExecutorService(ExecutorType.MASTER_CLOSE_REGION,conf.getInt("hbase.master.executor.closeregion.threads",5));
  this.service.startExecutorService(ExecutorType.MASTER_SERVER_OPERATIONS,conf.getInt("hbase.master.executor.serverops.threads",5));
  this.service.startExecutorService(ExecutorType.MASTER_META_SERVER_OPERATIONS,conf.getInt("hbase.master.executor.meta.serverops.threads",5));
  this.service.startExecutorService(ExecutorType.M_LOG_REPLAY_OPS,conf.getInt("hbase.master.executor.logreplayops.threads",10));
  this.service.startExecutorService(ExecutorType.MASTER_TABLE_OPERATIONS,1);
  startProcedureExecutor();
  int cleanerInterval=conf.getInt("hbase.master.cleaner.interval",60 * 1000);
  this.logCleaner=new LogCleaner(cleanerInterval,this,conf,getMasterWalManager().getFileSystem(),getMasterWalManager().getOldLogDir());
  getChoreService().scheduleChore(logCleaner);
  Path archiveDir=HFileArchiveUtil.getArchivePath(conf);
  this.hfileCleaner=new HFileCleaner(cleanerInterval,this,conf,getMasterFileSystem().getFileSystem(),archiveDir);
  getChoreService().scheduleChore(hfileCleaner);
  serviceStarted=true;
  if (LOG.isTraceEnabled()) {
    LOG.trace("Started service threads");
  }
  if (conf.getClass("hbase.region.replica.replication.replicationQueues.class",ReplicationFactory.defaultReplicationQueueClass) == ReplicationQueuesZKImpl.class && !conf.getBoolean(HConstants.ZOOKEEPER_USEMULTI,true)) {
    try {
      replicationZKLockCleanerChore=new ReplicationZKLockCleanerChore(this,this,cleanerInterval,this.getZooKeeper(),this.conf);
      getChoreService().scheduleChore(replicationZKLockCleanerChore);
    }
 catch (    Exception e) {
      LOG.error("start replicationZKLockCleanerChore failed",e);
    }
  }
}
