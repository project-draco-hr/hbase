{
  byte[] row=Bytes.toBytes(URLDecoder.decode(pathSegments[2],HConstants.UTF8_ENCODING));
  String timestampStr=null;
  if (pathSegments.length == 4) {
    timestampStr=pathSegments[3];
    if (timestampStr.equals("timestamps")) {
      doMethodNotAllowed(response,"Not yet supported by hbase");
      return;
    }
  }
  String[] column_params=request.getParameterValues(COLUMN);
  byte[][] columns=null;
  if (column_params != null && column_params.length > 0) {
    List<String> available_columns=new ArrayList<String>();
    for (    String column_param : column_params) {
      if (column_param.length() > 0 && table.getTableDescriptor().hasFamily(Bytes.toBytes(column_param))) {
        available_columns.add(column_param);
      }
    }
    columns=Bytes.toByteArrays(available_columns.toArray(new String[0]));
  }
  String[] version_params=request.getParameterValues(VERSION);
  int version=0;
  if (version_params != null && version_params.length == 1) {
    version=Integer.parseInt(version_params[0]);
  }
  if (version > 0 && columns != null) {
    Map<byte[],Cell[]> result=new TreeMap<byte[],Cell[]>(Bytes.BYTES_COMPARATOR);
    for (    byte[] col : columns) {
      Cell[] cells=timestampStr == null ? table.get(row,col,version) : table.get(row,col,Long.parseLong(timestampStr),version);
      if (cells != null) {
        result.put(col,cells);
      }
    }
    if (result == null || result.size() == 0) {
      doNotFound(response,"Row not found!");
    }
 else {
switch (ContentType.getContentType(request.getHeader(ACCEPT))) {
case XML:
        outputRowWithMultiVersionsXml(request,response,result);
      break;
case MIME:
default :
    doNotAcceptable(response,"Unsupported Accept Header Content: " + request.getHeader(CONTENT_TYPE));
}
}
}
 else {
Map<byte[],Cell> result=timestampStr == null ? table.getRow(row,columns) : table.getRow(row,columns,Long.parseLong(timestampStr));
if (result == null || result.size() == 0) {
doNotFound(response,"Row not found!");
}
 else {
switch (ContentType.getContentType(request.getHeader(ACCEPT))) {
case XML:
  outputRowXml(request,response,result);
break;
case MIME:
default :
doNotAcceptable(response,"Unsupported Accept Header Content: " + request.getHeader(CONTENT_TYPE));
}
}
}
}
