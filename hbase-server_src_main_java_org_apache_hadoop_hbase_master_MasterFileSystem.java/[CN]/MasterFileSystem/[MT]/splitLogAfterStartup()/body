{
  boolean retrySplitting=!conf.getBoolean("hbase.hlog.split.skip.errors",HLog.SPLIT_SKIP_ERRORS_DEFAULT);
  Path logsDirPath=new Path(this.rootdir,HConstants.HREGION_LOGDIR_NAME);
  do {
    List<ServerName> serverNames=new ArrayList<ServerName>();
    try {
      if (!this.fs.exists(logsDirPath))       return;
      FileStatus[] logFolders=FSUtils.listStatus(this.fs,logsDirPath,null);
      Set<ServerName> onlineServers=((HMaster)master).getServerManager().getOnlineServers().keySet();
      if (logFolders == null || logFolders.length == 0) {
        LOG.debug("No log files to split, proceeding...");
        return;
      }
      for (      FileStatus status : logFolders) {
        String sn=status.getPath().getName();
        if (sn.endsWith(HLog.SPLITTING_EXT)) {
          sn=sn.substring(0,sn.length() - HLog.SPLITTING_EXT.length());
        }
        ServerName serverName=ServerName.parseServerName(sn);
        if (!onlineServers.contains(serverName)) {
          LOG.info("Log folder " + status.getPath() + " doesn't belong "+ "to a known region server, splitting");
          serverNames.add(serverName);
        }
 else {
          LOG.info("Log folder " + status.getPath() + " belongs to an existing region server");
        }
      }
      splitLog(serverNames);
      retrySplitting=false;
    }
 catch (    IOException ioe) {
      LOG.warn("Failed splitting of " + serverNames,ioe);
      if (!checkFileSystem()) {
        LOG.warn("Bad Filesystem, exiting");
        Runtime.getRuntime().halt(1);
      }
      try {
        if (retrySplitting) {
          Thread.sleep(conf.getInt("hbase.hlog.split.failure.retry.interval",30 * 1000));
        }
      }
 catch (      InterruptedException e) {
        LOG.warn("Interrupted, aborting since cannot return w/o splitting");
        Thread.currentThread().interrupt();
        retrySplitting=false;
        Runtime.getRuntime().halt(1);
      }
    }
  }
 while (retrySplitting);
}
