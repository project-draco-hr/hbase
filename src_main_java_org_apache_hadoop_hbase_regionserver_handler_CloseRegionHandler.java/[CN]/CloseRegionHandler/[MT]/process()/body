{
  try {
    String name=regionInfo.getRegionNameAsString();
    LOG.debug("Processing close of " + name);
    String encodedRegionName=regionInfo.getEncodedName();
    HRegion region=this.rsServices.getFromOnlineRegions(encodedRegionName);
    if (region == null) {
      LOG.warn("Received CLOSE for region " + name + " but currently not serving");
      return;
    }
    int expectedVersion=FAILED;
    if (this.zk) {
      expectedVersion=getCurrentVersion();
      if (expectedVersion == FAILED)       return;
    }
    try {
      if (region.close(abort) == null) {
        LOG.warn("Can't close region: was already closed during close(): " + regionInfo.getRegionNameAsString());
        return;
      }
    }
 catch (    Throwable t) {
      server.abort("Unrecoverable exception while closing region " + regionInfo.getRegionNameAsString() + ", still finishing close",t);
      throw new RuntimeException(t);
    }
    this.rsServices.removeFromOnlineRegions(regionInfo.getEncodedName());
    if (this.zk)     setClosedState(expectedVersion,region);
    LOG.debug("Closed region " + region.getRegionNameAsString());
  }
  finally {
    this.rsServices.getRegionsInTransitionInRS().remove(this.regionInfo.getEncodedNameAsBytes());
  }
}
