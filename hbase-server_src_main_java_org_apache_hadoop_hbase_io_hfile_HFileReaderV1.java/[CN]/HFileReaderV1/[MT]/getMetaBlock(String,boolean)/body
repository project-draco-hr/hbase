{
  if (trailer.getMetaIndexCount() == 0) {
    return null;
  }
  if (metaBlockIndexReader == null) {
    throw new IOException("Meta index not loaded");
  }
  byte[] nameBytes=Bytes.toBytes(metaBlockName);
  int block=metaBlockIndexReader.rootBlockContainingKey(nameBytes,0,nameBytes.length);
  if (block == -1)   return null;
  long offset=metaBlockIndexReader.getRootBlockOffset(block);
  long nextOffset;
  if (block == metaBlockIndexReader.getRootBlockCount() - 1) {
    nextOffset=trailer.getFileInfoOffset();
  }
 else {
    nextOffset=metaBlockIndexReader.getRootBlockOffset(block + 1);
  }
  long startTimeNs=System.nanoTime();
  BlockCacheKey cacheKey=new BlockCacheKey(name,offset,DataBlockEncoding.NONE,BlockType.META);
  BlockCategory effectiveCategory=BlockCategory.META;
  if (metaBlockName.equals(HFileWriterV1.BLOOM_FILTER_META_KEY) || metaBlockName.equals(HFileWriterV1.BLOOM_FILTER_DATA_KEY)) {
    effectiveCategory=BlockCategory.BLOOM;
  }
synchronized (metaBlockIndexReader.getRootBlockKey(block)) {
    if (cacheConf.isBlockCacheEnabled()) {
      HFileBlock cachedBlock=(HFileBlock)cacheConf.getBlockCache().getBlock(cacheKey,cacheConf.shouldCacheBlockOnRead(effectiveCategory),false);
      if (cachedBlock != null) {
        return cachedBlock.getBufferWithoutHeader();
      }
    }
    HFileBlock hfileBlock=fsBlockReader.readBlockData(offset,nextOffset - offset,metaBlockIndexReader.getRootBlockDataSize(block),true);
    hfileBlock.expectType(BlockType.META);
    final long delta=System.nanoTime() - startTimeNs;
    HFile.offerReadLatency(delta,true);
    if (cacheBlock && cacheConf.shouldCacheBlockOnRead(effectiveCategory)) {
      cacheConf.getBlockCache().cacheBlock(cacheKey,hfileBlock,cacheConf.isInMemory());
    }
    return hfileBlock.getBufferWithoutHeader();
  }
}
