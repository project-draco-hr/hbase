{
  this.lock.readLock().lock();
  try {
    KeyValue firstKv=KeyValue.createFirstOnRow(row,family,qualifier);
    KeyValue newKv;
    SortedSet<KeyValue> snSs=snapshot.tailSet(firstKv);
    if (!snSs.isEmpty()) {
      KeyValue snKv=snSs.first();
      if (snKv.matchingRow(firstKv) && snKv.matchingQualifier(firstKv)) {
        if (snKv.getTimestamp() == now) {
          now+=1;
        }
      }
    }
    SortedSet<KeyValue> ss=kvset.tailSet(firstKv);
    Iterator<KeyValue> it=ss.iterator();
    while (it.hasNext()) {
      KeyValue kv=it.next();
      if (!firstKv.matchingColumn(family,qualifier) || !firstKv.matchingRow(kv)) {
        break;
      }
      if (firstKv.matchingQualifier(kv)) {
        if (kv.getType() == KeyValue.Type.Put.getCode()) {
          now=Math.max(now,kv.getTimestamp());
        }
      }
    }
    newKv=new KeyValue(row,family,qualifier,now,Bytes.toBytes(newValue));
    long addedSize=add(newKv);
    ss=kvset.tailSet(firstKv);
    it=ss.iterator();
    while (it.hasNext()) {
      KeyValue kv=it.next();
      if (kv == newKv) {
        continue;
      }
      if (!firstKv.matchingColumn(family,qualifier) || !firstKv.matchingRow(kv)) {
        break;
      }
      if (firstKv.matchingQualifier(kv)) {
        if (kv.getType() == KeyValue.Type.Put.getCode()) {
          addedSize-=heapSizeChange(kv,false);
          it.remove();
        }
      }
    }
    return addedSize;
  }
  finally {
    this.lock.readLock().unlock();
  }
}
