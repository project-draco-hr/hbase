{
  ArrayList<HMsg> returnMsgs=new ArrayList<HMsg>();
  Map<byte[],HRegionInfo> regionsToKill=master.regionManager.removeMarkedToClose(serverName);
  for (int i=0; i < incomingMsgs.length; i++) {
    HRegionInfo region=incomingMsgs[i].getRegionInfo();
    LOG.info("Received " + incomingMsgs[i] + " from "+ serverName);
switch (incomingMsgs[i].getType()) {
case MSG_REPORT_PROCESS_OPEN:
      master.regionManager.updateAssignmentDeadline(region);
    break;
case MSG_REPORT_OPEN:
  processRegionOpen(serverName,serverInfo,region,returnMsgs);
break;
case MSG_REPORT_CLOSE:
processRegionClose(serverInfo,region);
break;
case MSG_REPORT_SPLIT:
processSplitRegion(serverName,serverInfo,region,incomingMsgs[++i],incomingMsgs[++i],returnMsgs);
break;
default :
throw new IOException("Impossible state during message processing. Instruction: " + incomingMsgs[i].getType());
}
}
if (regionsToKill != null) {
for (HRegionInfo i : regionsToKill.values()) {
returnMsgs.add(new HMsg(HMsg.Type.MSG_REGION_CLOSE,i));
master.regionManager.setClosing(i.getRegionName());
}
}
master.regionManager.assignRegions(serverInfo,serverName,mostLoadedRegions,returnMsgs);
return returnMsgs.toArray(new HMsg[returnMsgs.size()]);
}
