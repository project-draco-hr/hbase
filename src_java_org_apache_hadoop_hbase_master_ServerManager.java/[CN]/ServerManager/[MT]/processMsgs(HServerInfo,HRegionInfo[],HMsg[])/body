{
  ArrayList<HMsg> returnMsgs=new ArrayList<HMsg>();
  if (serverInfo.getServerAddress() == null) {
    throw new NullPointerException("Server address cannot be null; " + "hbase-958 debugging");
  }
  int openingCount=0;
  for (int i=0; i < incomingMsgs.length; i++) {
    HRegionInfo region=incomingMsgs[i].getRegionInfo();
    LOG.info("Processing " + incomingMsgs[i] + " from "+ serverInfo.getServerName()+ "; "+ (i + 1)+ " of "+ incomingMsgs.length);
switch (incomingMsgs[i].getType()) {
case MSG_REPORT_PROCESS_OPEN:
      openingCount++;
    break;
case MSG_REPORT_OPEN:
  processRegionOpen(serverInfo,region,returnMsgs);
break;
case MSG_REPORT_CLOSE:
processRegionClose(region);
break;
case MSG_REPORT_SPLIT:
processSplitRegion(region,incomingMsgs[++i],incomingMsgs[++i]);
break;
default :
LOG.warn("Impossible state during message processing. Instruction: " + incomingMsgs[i].getType());
}
}
synchronized (master.regionManager) {
for (HRegionInfo i : master.regionManager.getMarkedToClose(serverInfo.getServerName())) {
returnMsgs.add(new HMsg(HMsg.Type.MSG_REGION_CLOSE,i));
master.regionManager.setPendingClose(i.getRegionNameAsString());
}
if (openingCount < this.nobalancingCount) {
this.master.regionManager.assignRegions(serverInfo,mostLoadedRegions,returnMsgs);
}
this.master.regionManager.applyActions(serverInfo,returnMsgs);
}
return returnMsgs.toArray(new HMsg[returnMsgs.size()]);
}
