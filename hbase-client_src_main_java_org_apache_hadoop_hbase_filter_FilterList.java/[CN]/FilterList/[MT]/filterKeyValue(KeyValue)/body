{
  this.referenceKV=v;
  KeyValue transformed=v;
  ReturnCode rc=operator == Operator.MUST_PASS_ONE ? ReturnCode.SKIP : ReturnCode.INCLUDE;
  for (  Filter filter : filters) {
    if (operator == Operator.MUST_PASS_ALL) {
      if (filter.filterAllRemaining()) {
        return ReturnCode.NEXT_ROW;
      }
      ReturnCode code=filter.filterKeyValue(v);
switch (code) {
case INCLUDE_AND_NEXT_COL:
        rc=ReturnCode.INCLUDE_AND_NEXT_COL;
case INCLUDE:
      transformed=filter.transform(transformed);
    continue;
default :
  return code;
}
}
 else if (operator == Operator.MUST_PASS_ONE) {
if (filter.filterAllRemaining()) {
continue;
}
switch (filter.filterKeyValue(v)) {
case INCLUDE:
if (rc != ReturnCode.INCLUDE_AND_NEXT_COL) {
  rc=ReturnCode.INCLUDE;
}
transformed=filter.transform(transformed);
break;
case INCLUDE_AND_NEXT_COL:
rc=ReturnCode.INCLUDE_AND_NEXT_COL;
transformed=filter.transform(transformed);
break;
case NEXT_ROW:
break;
case SKIP:
break;
case NEXT_COL:
break;
case SEEK_NEXT_USING_HINT:
break;
default :
throw new IllegalStateException("Received code is not valid.");
}
}
}
this.transformedKV=transformed;
return rc;
}
