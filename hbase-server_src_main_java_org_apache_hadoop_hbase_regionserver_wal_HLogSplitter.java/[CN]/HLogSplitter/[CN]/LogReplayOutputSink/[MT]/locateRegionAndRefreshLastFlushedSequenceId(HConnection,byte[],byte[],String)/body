{
  HRegionLocation loc=onlineRegions.get(originalEncodedRegionName);
  if (loc != null)   return loc;
  loc=hconn.getRegionLocation(table,row,false);
  if (loc == null) {
    throw new IOException("Can't locate location for row:" + Bytes.toString(row) + " of table:"+ Bytes.toString(table));
  }
  Long lastFlushedSequenceId=-1l;
  loc=waitUntilRegionOnline(loc,row,this.waitRegionOnlineTimeOut);
  Long cachedLastFlushedSequenceId=lastFlushedSequenceIds.get(loc.getRegionInfo().getEncodedName());
  onlineRegions.put(loc.getRegionInfo().getEncodedName(),loc);
  RegionStoreSequenceIds ids=SplitLogManager.getRegionFlushedSequenceId(watcher,failedServerName,loc.getRegionInfo().getEncodedName());
  if (ids != null) {
    lastFlushedSequenceId=ids.getLastFlushedSequenceId();
    Map<byte[],Long> storeIds=new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);
    List<StoreSequenceId> maxSeqIdInStores=ids.getStoreSequenceIdList();
    for (    StoreSequenceId id : maxSeqIdInStores) {
      storeIds.put(id.getFamilyName().toByteArray(),id.getSequenceId());
    }
    regionMaxSeqIdInStores.put(loc.getRegionInfo().getEncodedName(),storeIds);
  }
  if (cachedLastFlushedSequenceId == null || lastFlushedSequenceId > cachedLastFlushedSequenceId) {
    lastFlushedSequenceIds.put(loc.getRegionInfo().getEncodedName(),lastFlushedSequenceId);
  }
 else   if (loc.getRegionInfo().isRecovering() == false) {
    lastFlushedSequenceIds.put(loc.getRegionInfo().getEncodedName(),Long.MAX_VALUE);
    LOG.info("logReplay skip region: " + loc.getRegionInfo().getEncodedName() + " because it's not in recovering.");
  }
  return loc;
}
