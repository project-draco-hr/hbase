{
  boolean isCorrupted=false;
  Preconditions.checkState(status == null);
  boolean skipErrors=conf.getBoolean("hbase.hlog.split.skip.errors",HLog.SPLIT_SKIP_ERRORS_DEFAULT);
  int interval=conf.getInt("hbase.splitlog.report.interval.loglines",1024);
  Path logPath=logfile.getPath();
  boolean outputSinkStarted=false;
  boolean progress_failed=false;
  int editsCount=0;
  int editsSkipped=0;
  try {
    status=TaskMonitor.get().createStatus("Splitting log file " + logfile.getPath() + "into a temporary staging area.");
    long logLength=logfile.getLen();
    LOG.info("Splitting hlog: " + logPath + ", length="+ logLength);
    LOG.info("DistributedLogReplay = " + this.distributedLogReplay);
    status.setStatus("Opening log file");
    if (reporter != null && !reporter.progress()) {
      progress_failed=true;
      return false;
    }
    Reader in=null;
    try {
      in=getReader(fs,logfile,conf,skipErrors,reporter);
    }
 catch (    CorruptedLogFileException e) {
      LOG.warn("Could not get reader, corrupted log file " + logPath,e);
      ZKSplitLog.markCorrupted(rootDir,logfile.getPath().getName(),fs);
      isCorrupted=true;
    }
    if (in == null) {
      status.markComplete("Was nothing to split in log file");
      LOG.warn("Nothing to split in log file " + logPath);
      return true;
    }
    if (watcher != null) {
      try {
        disablingOrDisabledTables=ZKTable.getDisabledOrDisablingTables(watcher);
      }
 catch (      KeeperException e) {
        throw new IOException("Can't get disabling/disabled tables",e);
      }
    }
    int numOpenedFilesBeforeReporting=conf.getInt("hbase.splitlog.report.openedfiles",3);
    int numOpenedFilesLastCheck=0;
    outputSink.setReporter(reporter);
    outputSink.startWriterThreads();
    outputSinkStarted=true;
    Entry entry;
    Long lastFlushedSequenceId=-1L;
    ServerName serverName=HLogUtil.getServerNameFromHLogDirectoryName(logPath);
    String serverNameStr=(serverName == null) ? "" : serverName.getServerName();
    while ((entry=getNextLogLine(in,logPath,skipErrors)) != null) {
      byte[] region=entry.getKey().getEncodedRegionName();
      String key=Bytes.toString(region);
      lastFlushedSequenceId=lastFlushedSequenceIds.get(key);
      if (lastFlushedSequenceId == null) {
        if (this.distributedLogReplay) {
          lastFlushedSequenceId=SplitLogManager.getLastFlushedSequenceId(this.watcher,serverNameStr,key);
        }
 else         if (sequenceIdChecker != null) {
          lastFlushedSequenceId=sequenceIdChecker.getLastSequenceId(region);
        }
        if (lastFlushedSequenceId != null) {
          lastFlushedSequenceIds.put(key,lastFlushedSequenceId);
        }
 else {
          lastFlushedSequenceId=-1L;
        }
      }
      if (lastFlushedSequenceId >= entry.getKey().getLogSeqNum()) {
        editsSkipped++;
        continue;
      }
      entryBuffers.appendEntry(entry);
      editsCount++;
      int moreWritersFromLastCheck=this.getNumOpenWriters() - numOpenedFilesLastCheck;
      if (editsCount % interval == 0 || moreWritersFromLastCheck > numOpenedFilesBeforeReporting) {
        numOpenedFilesLastCheck=this.getNumOpenWriters();
        String countsStr=(editsCount - (editsSkipped + outputSink.getSkippedEdits())) + " edits, skipped " + editsSkipped+ " edits.";
        status.setStatus("Split " + countsStr);
        if (reporter != null && !reporter.progress()) {
          progress_failed=true;
          return false;
        }
      }
    }
  }
 catch (  InterruptedException ie) {
    IOException iie=new InterruptedIOException();
    iie.initCause(ie);
    throw iie;
  }
catch (  CorruptedLogFileException e) {
    LOG.warn("Could not parse, corrupted log file " + logPath,e);
    ZKSplitLog.markCorrupted(rootDir,logfile.getPath().getName(),fs);
    isCorrupted=true;
  }
catch (  IOException e) {
    e=RemoteExceptionHandler.checkIOException(e);
    throw e;
  }
 finally {
    LOG.info("Finishing writing output logs and closing down.");
    if (outputSinkStarted) {
      progress_failed=outputSink.finishWritingAndClose() == null;
    }
    String msg="Processed " + editsCount + " edits across "+ outputSink.getNumberOfRecoveredRegions()+ " regions; log file="+ logPath+ " is corrupted = "+ isCorrupted+ " progress failed = "+ progress_failed;
    LOG.info(msg);
    status.markComplete(msg);
  }
  return !progress_failed;
}
