{
  List<RegionEnvironment> configured=new ArrayList<RegionEnvironment>();
  for (  Map.Entry<ImmutableBytesWritable,ImmutableBytesWritable> e : region.getTableDesc().getValues().entrySet()) {
    String key=Bytes.toString(e.getKey().get());
    String spec=Bytes.toString(e.getValue().get());
    if (key.startsWith("COPROCESSOR")) {
      try {
        Matcher matcher=attrSpecMatch1.matcher(spec);
        if (!matcher.matches()) {
          matcher=attrSpecMatch2.matcher(spec);
        }
        if (matcher.matches()) {
          Path path=new Path(matcher.group(1));
          String className=matcher.group(2);
          int priority=Integer.valueOf(matcher.group(3));
          String cfgSpec=null;
          try {
            cfgSpec=matcher.group(4);
          }
 catch (          IndexOutOfBoundsException ex) {
          }
          if (cfgSpec != null) {
            Configuration newConf=HBaseConfiguration.create();
            Matcher m=cfgSpecMatch.matcher(cfgSpec);
            while (m.find()) {
              newConf.set(m.group(1),m.group(2));
            }
            configured.add(load(path,className,priority,newConf));
          }
 else {
            configured.add(load(path,className,priority,conf));
          }
          LOG.info("Load coprocessor " + className + " from HTD of "+ Bytes.toString(region.getTableDesc().getName())+ " successfully.");
        }
 else {
          throw new RuntimeException("specification does not match pattern");
        }
      }
 catch (      Exception ex) {
        LOG.warn("attribute '" + key + "' has invalid coprocessor specification '"+ spec+ "'");
        LOG.warn(StringUtils.stringifyException(ex));
      }
    }
  }
  coprocessors.addAll(configured);
}
