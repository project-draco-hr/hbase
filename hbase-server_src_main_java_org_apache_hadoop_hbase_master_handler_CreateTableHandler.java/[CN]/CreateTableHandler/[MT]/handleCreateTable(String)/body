{
  int regionNumber=newRegions.length;
  ThreadPoolExecutor regionOpenAndInitThreadPool=getRegionOpenAndInitThreadPool("RegionOpenAndInitThread-" + tableName,regionNumber);
  CompletionService<HRegion> completionService=new ExecutorCompletionService<HRegion>(regionOpenAndInitThreadPool);
  FSTableDescriptors.createTableDescriptor(this.hTableDescriptor,this.conf);
  List<HRegionInfo> regionInfos=new ArrayList<HRegionInfo>();
  for (  final HRegionInfo newRegion : newRegions) {
    completionService.submit(new Callable<HRegion>(){
      public HRegion call() throws IOException {
        HRegion region=HRegion.createHRegion(newRegion,fileSystemManager.getRootDir(),conf,hTableDescriptor,null,false,true);
        region.close();
        return region;
      }
    }
);
  }
  try {
    for (int i=0; i < regionNumber; i++) {
      Future<HRegion> future=completionService.take();
      HRegion region=future.get();
      regionInfos.add(region.getRegionInfo());
    }
  }
 catch (  InterruptedException e) {
    throw new InterruptedIOException(e.getMessage());
  }
catch (  ExecutionException e) {
    throw new IOException(e.getCause());
  }
 finally {
    regionOpenAndInitThreadPool.shutdownNow();
  }
  if (regionInfos.size() > 0) {
    MetaEditor.addRegionsToMeta(this.catalogTracker,regionInfos);
  }
  try {
    List<HRegionInfo> regions=Arrays.asList(newRegions);
    assignmentManager.getRegionStates().createRegionStates(regions);
    assignmentManager.assign(regions);
  }
 catch (  InterruptedException ie) {
    LOG.error("Caught " + ie + " during round-robin assignment");
    throw new IOException(ie);
  }
  try {
    assignmentManager.getZKTable().setEnabledTable(this.hTableDescriptor.getNameAsString());
  }
 catch (  KeeperException e) {
    throw new IOException("Unable to ensure that the table will be" + " enabled because of a ZooKeeper issue",e);
  }
}
