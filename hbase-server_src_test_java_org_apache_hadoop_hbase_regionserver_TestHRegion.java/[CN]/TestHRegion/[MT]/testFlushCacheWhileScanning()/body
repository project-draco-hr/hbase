{
  byte[] tableName=Bytes.toBytes("testFlushCacheWhileScanning");
  byte[] family=Bytes.toBytes("family");
  int numRows=1000;
  int flushAndScanInterval=10;
  int compactInterval=10 * flushAndScanInterval;
  String method="testFlushCacheWhileScanning";
  this.region=initHRegion(tableName,method,conf,family);
  try {
    FlushThread flushThread=new FlushThread();
    flushThread.start();
    Scan scan=new Scan();
    scan.addFamily(family);
    scan.setFilter(new SingleColumnValueFilter(family,qual1,CompareOp.EQUAL,new BinaryComparator(Bytes.toBytes(5L))));
    int expectedCount=0;
    List<KeyValue> res=new ArrayList<KeyValue>();
    boolean toggle=true;
    for (long i=0; i < numRows; i++) {
      Put put=new Put(Bytes.toBytes(i));
      put.setDurability(Durability.SKIP_WAL);
      put.add(family,qual1,Bytes.toBytes(i % 10));
      region.put(put);
      if (i != 0 && i % compactInterval == 0) {
        region.compactStores(true);
      }
      if (i % 10 == 5L) {
        expectedCount++;
      }
      if (i != 0 && i % flushAndScanInterval == 0) {
        res.clear();
        InternalScanner scanner=region.getScanner(scan);
        if (toggle) {
          flushThread.flush();
        }
        while (scanner.next(res))         ;
        if (!toggle) {
          flushThread.flush();
        }
        assertEquals("i=" + i,expectedCount,res.size());
        toggle=!toggle;
      }
    }
    flushThread.done();
    flushThread.join();
    flushThread.checkNoError();
  }
  finally {
    HRegion.closeHRegion(this.region);
    this.region=null;
  }
}
