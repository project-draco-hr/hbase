{
  byte[] tableName=Bytes.toBytes("testWritesWhileGetting");
  int testCount=100;
  int numRows=1;
  int numFamilies=10;
  int numQualifiers=100;
  int compactInterval=100;
  byte[][] families=new byte[numFamilies][];
  for (int i=0; i < numFamilies; i++) {
    families[i]=Bytes.toBytes("family" + i);
  }
  byte[][] qualifiers=new byte[numQualifiers][];
  for (int i=0; i < numQualifiers; i++) {
    qualifiers[i]=Bytes.toBytes("qual" + i);
  }
  Configuration conf=HBaseConfiguration.create(this.conf);
  String method="testWritesWhileGetting";
  conf.setInt("hbase.hstore.compaction.min",1);
  conf.setInt("hbase.hstore.compaction.max",1000);
  this.region=initHRegion(tableName,method,conf,families);
  PutThread putThread=null;
  MultithreadedTestUtil.TestContext ctx=new MultithreadedTestUtil.TestContext(conf);
  try {
    putThread=new PutThread(numRows,families,qualifiers);
    putThread.start();
    putThread.waitForFirstPut();
    ctx.addThread(new RepeatingTestThread(ctx){
      private int flushesSinceCompact=0;
      private final int maxFlushesSinceCompact=20;
      public void doAnAction() throws Exception {
        if (region.flushcache()) {
          ++flushesSinceCompact;
        }
        if (flushesSinceCompact == maxFlushesSinceCompact) {
          region.compactStores(false);
          flushesSinceCompact=0;
        }
      }
    }
);
    ctx.startThreads();
    Get get=new Get(Bytes.toBytes("row0"));
    Result result=null;
    int expectedCount=numFamilies * numQualifiers;
    long prevTimestamp=0L;
    for (int i=0; i < testCount; i++) {
      boolean previousEmpty=result == null || result.isEmpty();
      result=region.get(get,null);
      if (!result.isEmpty() || !previousEmpty || i > compactInterval) {
        assertEquals("i=" + i,expectedCount,result.size());
        long timestamp=0;
        for (        KeyValue kv : result.raw()) {
          if (Bytes.equals(kv.getFamily(),families[0]) && Bytes.equals(kv.getQualifier(),qualifiers[0])) {
            timestamp=kv.getTimestamp();
          }
        }
        assertTrue(timestamp >= prevTimestamp);
        prevTimestamp=timestamp;
        KeyValue previousKV=null;
        for (        KeyValue kv : result.raw()) {
          byte[] thisValue=kv.getValue();
          if (previousKV != null) {
            if (Bytes.compareTo(previousKV.getValue(),thisValue) != 0) {
              LOG.warn("These two KV should have the same value." + " Previous KV:" + previousKV + "(memStoreTS:"+ previousKV.getMemstoreTS()+ ")"+ ", New KV: "+ kv+ "(memStoreTS:"+ kv.getMemstoreTS()+ ")");
              assertEquals(0,Bytes.compareTo(previousKV.getValue(),thisValue));
            }
          }
          previousKV=kv;
        }
      }
    }
  }
  finally {
    if (putThread != null)     putThread.done();
    region.flushcache();
    if (putThread != null) {
      putThread.join();
      putThread.checkNoError();
    }
    ctx.stop();
    HRegion.closeHRegion(this.region);
    this.region=null;
  }
}
