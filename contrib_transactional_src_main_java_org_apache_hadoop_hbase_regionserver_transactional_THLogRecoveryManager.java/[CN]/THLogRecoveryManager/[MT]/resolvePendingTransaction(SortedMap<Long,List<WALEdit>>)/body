{
  SortedMap<Long,List<WALEdit>> commitedTransactionsById=new TreeMap<Long,List<WALEdit>>();
  LOG.info("Region log has " + pendingTransactionsById.size() + " unfinished transactions. Going to the transaction log to resolve");
  for (  Entry<Long,List<WALEdit>> entry : pendingTransactionsById.entrySet()) {
    if (entry.getValue().isEmpty()) {
      LOG.debug("Skipping resolving trx [" + entry.getKey() + "] has no writes.");
    }
    TransactionLogger.TransactionStatus transactionStatus=getGlobalTransactionLog().getStatusForTransaction(entry.getKey());
    if (transactionStatus == null) {
      throw new RuntimeException("Cannot resolve tranasction [" + entry.getKey() + "] from global tx log.");
    }
switch (transactionStatus) {
case ABORTED:
      break;
case COMMITTED:
    commitedTransactionsById.put(entry.getKey(),entry.getValue());
  break;
case PENDING:
LOG.warn("Transaction [" + entry.getKey() + "] is still pending. Asumming it will not commit."+ " If it eventually does commit, then we loose transactional semantics.");
break;
}
}
return commitedTransactionsById;
}
