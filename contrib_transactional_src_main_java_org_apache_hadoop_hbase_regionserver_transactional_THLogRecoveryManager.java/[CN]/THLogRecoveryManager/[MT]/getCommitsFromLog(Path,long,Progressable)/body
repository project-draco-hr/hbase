{
  if (reconstructionLog == null || !fileSystem.exists(reconstructionLog)) {
    return null;
  }
  FileStatus[] stats=fileSystem.listStatus(reconstructionLog);
  if (stats == null || stats.length == 0) {
    LOG.warn("Passed reconstruction log " + reconstructionLog + " is zero-length");
    return null;
  }
  SortedMap<Long,List<WALEdit>> pendingTransactionsById=new TreeMap<Long,List<WALEdit>>();
  Set<Long> commitedTransactions=new HashSet<Long>();
  Set<Long> abortedTransactions=new HashSet<Long>();
  HLog.Reader reader=HLog.getReader(fileSystem,reconstructionLog,conf);
  try {
    long skippedEdits=0;
    long totalEdits=0;
    long startCount=0;
    long writeCount=0;
    long abortCount=0;
    long commitCount=0;
    int reportInterval=conf.getInt("hbase.hstore.report.interval.edits",2000);
    HLog.Entry entry;
    while ((entry=reader.next()) != null) {
      THLogKey key=(THLogKey)entry.getKey();
      WALEdit val=entry.getEdit();
      if (LOG.isTraceEnabled()) {
        LOG.trace("Processing edit: key: " + key.toString() + " val: "+ val.toString());
      }
      if (key.getLogSeqNum() < maxSeqID) {
        skippedEdits++;
        continue;
      }
      if (key.getTrxOp() == null || !Bytes.equals(key.getRegionName(),regionInfo.getRegionName())) {
        continue;
      }
      long transactionId=key.getTransactionId();
      List<WALEdit> updates=pendingTransactionsById.get(transactionId);
switch (key.getTrxOp()) {
case OP:
        if (updates == null) {
          updates=new ArrayList<WALEdit>();
          pendingTransactionsById.put(transactionId,updates);
          startCount++;
        }
      updates.add(val);
    val=new WALEdit();
  writeCount++;
break;
case ABORT:
if (updates == null) {
LOG.error("Processing abort for transaction: " + transactionId + ", but have not seen start message");
throw new IOException("Corrupted transaction log");
}
abortedTransactions.add(transactionId);
pendingTransactionsById.remove(transactionId);
abortCount++;
break;
case COMMIT:
if (updates == null) {
LOG.error("Processing commit for transaction: " + transactionId + ", but have not seen start message");
throw new IOException("Corrupted transaction log");
}
if (abortedTransactions.contains(transactionId)) {
LOG.error("Processing commit for transaction: " + transactionId + ", but also have abort message");
throw new IOException("Corrupted transaction log");
}
if (commitedTransactions.contains(transactionId)) {
LOG.error("Processing commit for transaction: " + transactionId + ", but have already commited transaction with that id");
throw new IOException("Corrupted transaction log");
}
pendingTransactionsById.remove(transactionId);
commitedTransactions.add(transactionId);
commitCount++;
break;
default :
throw new IllegalStateException("Unexpected log entry type");
}
totalEdits++;
if (reporter != null && (totalEdits % reportInterval) == 0) {
reporter.progress();
}
}
if (LOG.isDebugEnabled()) {
LOG.debug("Read " + totalEdits + " tranasctional operations (skipped "+ skippedEdits+ " because sequence id <= "+ maxSeqID+ "): "+ startCount+ " starts, "+ writeCount+ " writes, "+ abortCount+ " aborts, and "+ commitCount+ " commits.");
}
}
  finally {
reader.close();
}
if (pendingTransactionsById.size() > 0) {
return resolvePendingTransaction(pendingTransactionsById);
}
return null;
}
