{
  if (cmd.hasOption(OPT_ZK_QUORUM)) {
    conf.set(HConstants.ZOOKEEPER_QUORUM,cmd.getOptionValue(OPT_ZK_QUORUM));
  }
  if (isInitOnly) {
    LOG.info("Initializing only; no reads or writes");
    initTestTable();
    return 0;
  }
  if (!isSkipInit) {
    initTestTable();
  }
  LoadTestDataGenerator dataGen=null;
  if (cmd.hasOption(OPT_GENERATOR)) {
    String[] clazzAndArgs=cmd.getOptionValue(OPT_GENERATOR).split(COLON);
    dataGen=getLoadGeneratorInstance(clazzAndArgs[0]);
    String[] args=clazzAndArgs.length == 1 ? new String[0] : Arrays.copyOfRange(clazzAndArgs,1,clazzAndArgs.length);
    dataGen.initialize(args);
  }
 else {
    dataGen=new MultiThreadedAction.DefaultDataGenerator(minColDataSize,maxColDataSize,minColsPerKey,maxColsPerKey,COLUMN_FAMILY);
  }
  if (isWrite) {
    writerThreads=new MultiThreadedWriter(dataGen,conf,tableName);
    writerThreads.setMultiPut(isMultiPut);
  }
  if (isUpdate) {
    updaterThreads=new MultiThreadedUpdater(dataGen,conf,tableName,updatePercent);
    updaterThreads.setBatchUpdate(isBatchUpdate);
  }
  if (isRead) {
    readerThreads=new MultiThreadedReader(dataGen,conf,tableName,verifyPercent);
    readerThreads.setMaxErrors(maxReadErrors);
    readerThreads.setKeyWindow(keyWindow);
  }
  if (isUpdate && isWrite) {
    LOG.info("Concurrent write/update workload: making updaters aware of the " + "write point");
    updaterThreads.linkToWriter(writerThreads);
  }
  if (isRead && (isUpdate || isWrite)) {
    LOG.info("Concurrent write/read workload: making readers aware of the " + "write point");
    readerThreads.linkToWriter(isUpdate ? updaterThreads : writerThreads);
  }
  if (isWrite) {
    System.out.println("Starting to write data...");
    writerThreads.start(startKey,endKey,numWriterThreads);
  }
  if (isUpdate) {
    LOG.info("Starting to mutate data...");
    System.out.println("Starting to mutate data...");
    updaterThreads.start(startKey,endKey,numUpdaterThreads);
  }
  if (isRead) {
    System.out.println("Starting to read data...");
    readerThreads.start(startKey,endKey,numReaderThreads);
  }
  if (isWrite) {
    writerThreads.waitForFinish();
  }
  if (isUpdate) {
    updaterThreads.waitForFinish();
  }
  if (isRead) {
    readerThreads.waitForFinish();
  }
  boolean success=true;
  if (isWrite) {
    success=success && writerThreads.getNumWriteFailures() == 0;
  }
  if (isUpdate) {
    success=success && updaterThreads.getNumWriteFailures() == 0;
  }
  if (isRead) {
    success=success && readerThreads.getNumReadErrors() == 0 && readerThreads.getNumReadFailures() == 0;
  }
  return success ? EXIT_SUCCESS : EXIT_FAILURE;
}
