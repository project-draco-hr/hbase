{
  if (cmd.hasOption(OPT_ZK_QUORUM)) {
    conf.set(HConstants.ZOOKEEPER_QUORUM,cmd.getOptionValue(OPT_ZK_QUORUM));
  }
  if (cmd.hasOption(OPT_ZK_PARENT_NODE)) {
    conf.set(HConstants.ZOOKEEPER_ZNODE_PARENT,cmd.getOptionValue(OPT_ZK_PARENT_NODE));
  }
  if (isInitOnly) {
    LOG.info("Initializing only; no reads or writes");
    initTestTable();
    return 0;
  }
  if (!isSkipInit) {
    initTestTable();
  }
  LoadTestDataGenerator dataGen=null;
  if (cmd.hasOption(OPT_GENERATOR)) {
    String[] clazzAndArgs=cmd.getOptionValue(OPT_GENERATOR).split(COLON);
    dataGen=getLoadGeneratorInstance(clazzAndArgs[0]);
    if (dataGen instanceof LoadTestDataGeneratorWithACL) {
      LOG.info("ACL is on");
      userOwner=User.createUserForTesting(conf,"owner",new String[0]);
    }
    String[] args=clazzAndArgs.length == 1 ? new String[0] : Arrays.copyOfRange(clazzAndArgs,1,clazzAndArgs.length);
    dataGen.initialize(args);
  }
 else {
    dataGen=new MultiThreadedAction.DefaultDataGenerator(minColDataSize,maxColDataSize,minColsPerKey,maxColsPerKey,COLUMN_FAMILY);
  }
  if (userOwner != null) {
    conf.set("hadoop.security.authorization","false");
    conf.set("hadoop.security.authentication","simple");
    LOG.info("Granting permission for the user " + userOwner.getShortName());
    HTable table=new HTable(conf,tableName);
    AccessControlProtos.Permission.Action[] actions={AccessControlProtos.Permission.Action.ADMIN,AccessControlProtos.Permission.Action.CREATE,AccessControlProtos.Permission.Action.READ,AccessControlProtos.Permission.Action.WRITE};
    try {
      AccessControlClient.grant(conf,table.getName(),userOwner.getShortName(),COLUMN_FAMILY,null,actions);
    }
 catch (    Throwable e) {
      LOG.fatal("Error in granting permission for the user " + userOwner.getShortName(),e);
      return EXIT_FAILURE;
    }
  }
  if (isWrite) {
    if (userOwner != null) {
      writerThreads=new MultiThreadedWriterWithACL(dataGen,conf,tableName,userOwner);
    }
 else {
      writerThreads=new MultiThreadedWriter(dataGen,conf,tableName);
    }
    writerThreads.setMultiPut(isMultiPut);
  }
  if (isUpdate) {
    if (userOwner != null) {
      updaterThreads=new MultiThreadedUpdaterWithACL(dataGen,conf,tableName,updatePercent,userOwner);
    }
 else {
      updaterThreads=new MultiThreadedUpdater(dataGen,conf,tableName,updatePercent);
    }
    updaterThreads.setBatchUpdate(isBatchUpdate);
    updaterThreads.setIgnoreNonceConflicts(ignoreConflicts);
  }
  if (isRead) {
    if (userOwner != null) {
      readerThreads=new MultiThreadedReaderWithACL(dataGen,conf,tableName,verifyPercent);
    }
 else {
      readerThreads=new MultiThreadedReader(dataGen,conf,tableName,verifyPercent);
    }
    readerThreads.setMaxErrors(maxReadErrors);
    readerThreads.setKeyWindow(keyWindow);
  }
  if (isUpdate && isWrite) {
    LOG.info("Concurrent write/update workload: making updaters aware of the " + "write point");
    updaterThreads.linkToWriter(writerThreads);
  }
  if (isRead && (isUpdate || isWrite)) {
    LOG.info("Concurrent write/read workload: making readers aware of the " + "write point");
    readerThreads.linkToWriter(isUpdate ? updaterThreads : writerThreads);
  }
  if (isWrite) {
    System.out.println("Starting to write data...");
    writerThreads.start(startKey,endKey,numWriterThreads);
  }
  if (isUpdate) {
    LOG.info("Starting to mutate data...");
    System.out.println("Starting to mutate data...");
    updaterThreads.start(startKey,endKey,numUpdaterThreads);
  }
  if (isRead) {
    System.out.println("Starting to read data...");
    readerThreads.start(startKey,endKey,numReaderThreads);
  }
  if (isWrite) {
    writerThreads.waitForFinish();
  }
  if (isUpdate) {
    updaterThreads.waitForFinish();
  }
  if (isRead) {
    readerThreads.waitForFinish();
  }
  boolean success=true;
  if (isWrite) {
    success=success && writerThreads.getNumWriteFailures() == 0;
  }
  if (isUpdate) {
    success=success && updaterThreads.getNumWriteFailures() == 0;
  }
  if (isRead) {
    success=success && readerThreads.getNumReadErrors() == 0 && readerThreads.getNumReadFailures() == 0;
  }
  return success ? EXIT_SUCCESS : EXIT_FAILURE;
}
