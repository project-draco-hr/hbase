{
  final String tableName="testConcurrentInstantSchemaChangeAndSplit";
  conf=TEST_UTIL.getConfiguration();
  LOG.info("Start testConcurrentInstantSchemaChangeAndSplit()");
  final String newFamily="newFamily";
  HTable ht=createTableAndValidate(tableName);
  final MasterSchemaChangeTracker msct=TEST_UTIL.getHBaseCluster().getMaster().getSchemaChangeTracker();
  TEST_UTIL.createMultiRegions(conf,ht,HConstants.CATALOG_FAMILY,4);
  int rowCount=TEST_UTIL.loadTable(ht,HConstants.CATALOG_FAMILY);
  Runnable splitter=new Runnable(){
    public void run(){
      try {
        LOG.info("Splitting table now ");
        admin.split(Bytes.toBytes(tableName));
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
;
  Runnable schemaChanger=new Runnable(){
    public void run(){
      HColumnDescriptor hcd=new HColumnDescriptor(newFamily);
      try {
        admin.addColumn(Bytes.toBytes(tableName),hcd);
      }
 catch (      IOException ioe) {
        ioe.printStackTrace();
      }
    }
  }
;
  schemaChanger.run();
  Thread.sleep(50);
  splitter.run();
  waitForSchemaChangeProcess(tableName,40000);
  Put put1=new Put(row);
  put1.add(Bytes.toBytes(newFamily),qualifier,value);
  LOG.info("******** Put into new column family ");
  ht.put(put1);
  ht.flushCommits();
  LOG.info("******** Get from new column family ");
  Get get1=new Get(row);
  get1.addColumn(Bytes.toBytes(newFamily),qualifier);
  Result r=ht.get(get1);
  byte[] tvalue=r.getValue(Bytes.toBytes(newFamily),qualifier);
  LOG.info(" Value put = " + value + " value from table = "+ tvalue);
  int result=Bytes.compareTo(value,tvalue);
  assertEquals(result,0);
  LOG.info("End testConcurrentInstantSchemaChangeAndSplit() ");
}
