{
  this.pool=pool;
  this.callback=callback;
  this.nonceGroup=nonceGroup;
  this.tableName=tableName;
  this.actionsInProgress.set(actions.size());
  if (results != null) {
    assert needResults;
    if (results.length != actions.size())     throw new AssertionError("results.length");
    this.results=results;
    for (int i=0; i != this.results.length; ++i) {
      results[i]=null;
    }
  }
 else {
    this.results=needResults ? new Object[actions.size()] : null;
  }
  List<Integer> replicaGetIndices=null;
  boolean hasAnyReplicaGets=false;
  if (needResults) {
    boolean hasAnyNonReplicaReqs=false;
    int posInList=0;
    for (    Action<Row> action : actions) {
      boolean isReplicaGet=isReplicaGet(action.getAction());
      if (isReplicaGet) {
        hasAnyReplicaGets=true;
        if (hasAnyNonReplicaReqs) {
          if (replicaGetIndices == null) {
            replicaGetIndices=new ArrayList<Integer>(actions.size() - 1);
          }
          replicaGetIndices.add(posInList);
        }
      }
 else       if (!hasAnyNonReplicaReqs) {
        hasAnyNonReplicaReqs=true;
        if (posInList > 0) {
          replicaGetIndices=new ArrayList<Integer>(actions.size() - 1);
          for (int i=0; i < posInList; ++i) {
            replicaGetIndices.add(i);
          }
        }
      }
      ++posInList;
    }
  }
  this.hasAnyReplicaGets=hasAnyReplicaGets;
  if (replicaGetIndices != null) {
    this.replicaGetIndices=new int[replicaGetIndices.size()];
    int i=0;
    for (    Integer el : replicaGetIndices) {
      this.replicaGetIndices[i++]=el;
    }
  }
 else {
    this.replicaGetIndices=null;
  }
  this.callsInProgress=!hasAnyReplicaGets ? null : Collections.newSetFromMap(new ConcurrentHashMap<MultiServerCallable<Row>,Boolean>());
  this.errorsByServer=createServerErrorTracker();
  this.errors=(globalErrors != null) ? globalErrors : new BatchErrors();
}
