{
  long maxSize=0L;
  long aggregateSize=0L;
  boolean splitable=true;
  if (this.storefiles.size() <= 0) {
    return new HStoreSize(0,0,splitable);
  }
  this.lock.readLock().lock();
  try {
    Long mapIndex=Long.valueOf(0L);
    for (    Map.Entry<Long,HStoreFile> e : storefiles.entrySet()) {
      HStoreFile curHSF=e.getValue();
      long size=curHSF.length();
      aggregateSize+=size;
      if (maxSize == 0L || size > maxSize) {
        maxSize=size;
        mapIndex=e.getKey();
      }
      if (splitable) {
        splitable=!curHSF.isReference();
      }
    }
    MapFile.Reader r=this.readers.get(mapIndex);
    r.reset();
    HStoreKey firstKey=new HStoreKey();
    HStoreKey lastKey=new HStoreKey();
    Writable value=new ImmutableBytesWritable();
    r.next((WritableComparable)firstKey,value);
    r.finalKey((WritableComparable)lastKey);
    HStoreKey midkey=(HStoreKey)r.midKey();
    if (midkey != null) {
      midKey.set(((HStoreKey)midkey).getRow());
      if (midkey.getRow().equals(firstKey.getRow()) && midkey.getRow().equals(lastKey.getRow())) {
        return new HStoreSize(aggregateSize,maxSize,false);
      }
    }
  }
 catch (  IOException e) {
    LOG.warn("Failed getting store size for " + this.storeName,e);
  }
 finally {
    this.lock.readLock().unlock();
  }
  return new HStoreSize(aggregateSize,maxSize,splitable);
}
