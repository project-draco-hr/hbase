{
  long maxId=maxSeenSeqID;
synchronized (compactLock) {
    Path curCompactStore=HStoreFile.getHStoreDir(this.compactionDir,regionName,familyName);
    if (LOG.isDebugEnabled()) {
      LOG.debug("started compaction of " + storefiles.size() + " files in "+ curCompactStore.toString());
    }
    if (this.fs.exists(curCompactStore)) {
      LOG.warn("Cleaning up a previous incomplete compaction at " + curCompactStore.toString());
      if (!this.fs.delete(curCompactStore)) {
        LOG.warn("Deleted returned false on " + curCompactStore.toString());
      }
    }
    try {
      Vector<HStoreFile> toCompactFiles=getFilesToCompact();
      HStoreFile compactedOutputFile=new HStoreFile(conf,this.compactionDir,regionName,familyName,-1);
      if (toCompactFiles.size() < 1 || (toCompactFiles.size() == 1 && !toCompactFiles.get(0).isReference())) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("nothing to compact for " + this.storeName);
        }
        if (deleteSequenceInfo && toCompactFiles.size() == 1) {
          toCompactFiles.get(0).writeInfo(fs,-1);
        }
        return;
      }
      if (!fs.mkdirs(curCompactStore)) {
        LOG.warn("Mkdir on " + curCompactStore.toString() + " failed");
      }
      if (maxId == -1) {
        for (        HStoreFile hsf : toCompactFiles) {
          long seqid=hsf.loadInfo(fs);
          if (seqid > 0) {
            if (seqid > maxId) {
              maxId=seqid;
            }
          }
        }
      }
      MapFile.Writer compactedOut=compactedOutputFile.getWriter(this.fs,this.compression,this.bloomFilter);
      try {
        compact(compactedOut,toCompactFiles);
      }
  finally {
        compactedOut.close();
      }
      if ((!deleteSequenceInfo) && maxId >= 0) {
        compactedOutputFile.writeInfo(fs,maxId);
      }
 else {
        compactedOutputFile.writeInfo(fs,-1);
      }
      Path filesToReplace=new Path(curCompactStore,COMPACTION_TO_REPLACE);
      DataOutputStream out=new DataOutputStream(fs.create(filesToReplace));
      try {
        out.writeInt(toCompactFiles.size());
        for (        HStoreFile hsf : toCompactFiles) {
          hsf.write(out);
        }
      }
  finally {
        out.close();
      }
      Path doneFile=new Path(curCompactStore,COMPACTION_DONE);
      (new DataOutputStream(fs.create(doneFile))).close();
      processReadyCompaction();
    }
  finally {
      if (this.fs.exists(curCompactStore.getParent())) {
        if (!this.fs.delete(curCompactStore.getParent())) {
          LOG.warn("Delete returned false deleting " + curCompactStore.getParent().toString());
        }
      }
    }
  }
}
