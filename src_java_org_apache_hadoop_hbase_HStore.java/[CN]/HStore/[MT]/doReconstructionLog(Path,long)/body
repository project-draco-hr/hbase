{
  if (reconstructionLog == null || !fs.exists(reconstructionLog)) {
    return;
  }
  long maxSeqIdInLog=-1;
  TreeMap<HStoreKey,byte[]> reconstructedCache=new TreeMap<HStoreKey,byte[]>();
  SequenceFile.Reader login=new SequenceFile.Reader(this.fs,reconstructionLog,this.conf);
  try {
    HLogKey key=new HLogKey();
    HLogEdit val=new HLogEdit();
    long skippedEdits=0;
    while (login.next(key,val)) {
      maxSeqIdInLog=Math.max(maxSeqIdInLog,key.getLogSeqNum());
      if (key.getLogSeqNum() <= maxSeqID) {
        skippedEdits++;
        continue;
      }
      if (skippedEdits > 0 && LOG.isDebugEnabled()) {
        LOG.debug("Skipped " + skippedEdits + " edits because sequence id <= "+ maxSeqID);
      }
      Text column=val.getColumn();
      if (column.equals(HLog.METACOLUMN) || !key.getRegionName().equals(regionName) || !HStoreKey.extractFamily(column).equals(this.familyName)) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Passing on edit " + key.getRegionName() + ", "+ column.toString()+ ": "+ new String(val.getVal(),UTF8_ENCODING)+ ", my region: "+ regionName+ ", my column: "+ this.familyName);
        }
        continue;
      }
      HStoreKey k=new HStoreKey(key.getRow(),column,val.getTimestamp());
      if (LOG.isDebugEnabled()) {
        LOG.debug("Applying edit <" + k.toString() + "="+ val.toString()+ ">");
      }
      reconstructedCache.put(k,val.getVal());
    }
  }
  finally {
    login.close();
  }
  if (reconstructedCache.size() > 0) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("flushing reconstructionCache");
    }
    internalFlushCache(reconstructedCache,maxSeqIdInLog + 1);
  }
}
