{
  Path curCompactStore=HStoreFile.getHStoreDir(compactdir,regionName,familyName);
  this.lock.obtainWriteLock();
  try {
    Path doneFile=new Path(curCompactStore,COMPACTION_DONE);
    if (!fs.exists(doneFile)) {
      LOG.warn("Redoing a failed compaction");
      return;
    }
    Vector<HStoreFile> toCompactFiles=new Vector<HStoreFile>();
    Path filesToReplace=new Path(curCompactStore,COMPACTION_TO_REPLACE);
    DataInputStream in=new DataInputStream(fs.open(filesToReplace));
    try {
      int numfiles=in.readInt();
      for (int i=0; i < numfiles; i++) {
        HStoreFile hsf=new HStoreFile(conf);
        hsf.readFields(in);
        toCompactFiles.add(hsf);
      }
    }
  finally {
      in.close();
    }
    Vector<Long> keys=new Vector<Long>(toCompactFiles.size());
    for (    Map.Entry<Long,HStoreFile> e : storefiles.entrySet()) {
      if (toCompactFiles.contains(e.getValue())) {
        keys.add(e.getKey());
      }
    }
    for (    Long key : keys) {
      MapFile.Reader reader=this.readers.remove(key);
      if (reader != null) {
        reader.close();
      }
      HStoreFile hsf=this.storefiles.remove(key);
      hsf.delete();
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("deleted " + toCompactFiles.size() + " old file(s)");
    }
    HStoreFile compactedFile=new HStoreFile(conf,compactdir,regionName,familyName,-1);
    HStoreFile finalCompactedFile=HStoreFile.obtainNewHStoreFile(conf,dir,regionName,familyName,fs);
    if (LOG.isDebugEnabled()) {
      LOG.debug("moving " + compactedFile.toString() + " in "+ compactdir.toString()+ " to "+ finalCompactedFile.toString()+ " in "+ dir.toString());
    }
    compactedFile.rename(this.fs,finalCompactedFile);
    Long orderVal=Long.valueOf(finalCompactedFile.loadInfo(fs));
    this.readers.put(orderVal,finalCompactedFile.getReader(this.fs,this.bloomFilter));
    this.storefiles.put(orderVal,finalCompactedFile);
  }
  finally {
    this.lock.releaseWriteLock();
  }
}
