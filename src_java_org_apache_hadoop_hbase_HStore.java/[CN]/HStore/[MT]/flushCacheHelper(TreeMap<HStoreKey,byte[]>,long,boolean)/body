{
synchronized (flushLock) {
    HStoreFile flushedFile=HStoreFile.obtainNewHStoreFile(conf,dir,regionName,familyName,fs);
    String name=flushedFile.toString();
    MapFile.Writer out=flushedFile.getWriter(this.fs,this.compression,this.bloomFilter);
    try {
      if (this.conf.getBoolean("hbase.hstore.compact.on.flush",false) && this.storefiles.size() > 0) {
        compact(out,inputCache.entrySet().iterator(),this.readers.get(this.storefiles.firstKey()));
      }
 else {
        for (        Map.Entry<HStoreKey,byte[]> es : inputCache.entrySet()) {
          HStoreKey curkey=es.getKey();
          if (this.familyName.equals(HStoreKey.extractFamily(curkey.getColumn()))) {
            out.append(curkey,new ImmutableBytesWritable(es.getValue()));
          }
        }
      }
    }
  finally {
      out.close();
    }
    flushedFile.writeInfo(fs,logCacheFlushId);
    if (bloomFilter != null) {
      flushBloomFilter();
    }
    if (addToAvailableMaps) {
      this.lock.obtainWriteLock();
      try {
        Long flushid=Long.valueOf(logCacheFlushId);
        this.readers.put(flushid,flushedFile.getReader(this.fs,this.bloomFilter));
        this.storefiles.put(flushid,flushedFile);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Added " + name + " with sequence id "+ logCacheFlushId+ " and size "+ StringUtils.humanReadableInt(flushedFile.length()));
        }
      }
  finally {
        this.lock.releaseWriteLock();
      }
    }
    return;
  }
}
