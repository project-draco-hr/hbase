{
synchronized (flushLock) {
    HStoreFile flushedFile=HStoreFile.obtainNewHStoreFile(conf,dir,regionName,familyName,fs);
    Path mapfile=flushedFile.getMapFilePath();
    if (LOG.isDebugEnabled()) {
      LOG.debug("Flushing to " + mapfile.toString());
    }
    MapFile.Writer out=getMapFileWriter(mapfile.toString());
    try {
      for (      Map.Entry<HStoreKey,byte[]> es : inputCache.entrySet()) {
        HStoreKey curkey=es.getKey();
        if (this.familyName.equals(HStoreKey.extractFamily(curkey.getColumn()))) {
          out.append(curkey,new ImmutableBytesWritable(es.getValue()));
        }
      }
    }
  finally {
      out.close();
    }
    flushedFile.writeInfo(fs,logCacheFlushId);
    if (bloomFilter != null) {
      flushBloomFilter();
    }
    if (addToAvailableMaps) {
      this.lock.obtainWriteLock();
      try {
        Long flushid=Long.valueOf(logCacheFlushId);
        maps.put(flushid,getMapFileReader(mapfile.toString()));
        mapFiles.put(flushid,flushedFile);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Added " + mapfile.toString() + " with flush id "+ logCacheFlushId+ " and size "+ StringUtils.humanReadableInt(mapfile.getFileSystem(this.conf).getContentLength(mapfile)));
        }
      }
  finally {
        this.lock.releaseWriteLock();
      }
    }
    return getAllMapFiles();
  }
}
