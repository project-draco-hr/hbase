{
  final int NUM_MASTERS=1;
  final int NUM_RS=3;
  Configuration conf=HBaseConfiguration.create();
  conf.setBoolean("hbase.assignment.usezk",true);
  HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility(conf);
  TEST_UTIL.startMiniCluster(NUM_MASTERS,NUM_RS);
  MiniHBaseCluster cluster=TEST_UTIL.getHBaseCluster();
  log("Cluster started");
  ZooKeeperWatcher zkw=HBaseTestingUtility.getZooKeeperWatcher(TEST_UTIL);
  List<MasterThread> masterThreads=cluster.getMasterThreads();
  assertEquals(1,masterThreads.size());
  assertTrue(cluster.waitForActiveAndReadyMaster());
  HMaster master=masterThreads.get(0).getMaster();
  assertTrue(master.isActiveMaster());
  assertTrue(master.isInitialized());
  master.balanceSwitch(false);
  byte[] FAMILY=Bytes.toBytes("family");
  byte[][] SPLIT_KEYS=new byte[][]{new byte[0],Bytes.toBytes("aaa"),Bytes.toBytes("bbb"),Bytes.toBytes("ccc"),Bytes.toBytes("ddd"),Bytes.toBytes("eee"),Bytes.toBytes("fff"),Bytes.toBytes("ggg"),Bytes.toBytes("hhh"),Bytes.toBytes("iii"),Bytes.toBytes("jjj")};
  byte[] enabledTable=Bytes.toBytes("enabledTable");
  HTableDescriptor htdEnabled=new HTableDescriptor(TableName.valueOf(enabledTable));
  htdEnabled.addFamily(new HColumnDescriptor(FAMILY));
  FileSystem filesystem=FileSystem.get(conf);
  Path rootdir=FSUtils.getRootDir(conf);
  FSTableDescriptors fstd=new FSTableDescriptors(filesystem,rootdir);
  fstd.createTableDescriptor(htdEnabled);
  HRegionInfo hriEnabled=new HRegionInfo(htdEnabled.getTableName(),null,null);
  createRegion(hriEnabled,rootdir,conf,htdEnabled);
  List<HRegionInfo> enabledRegions=TEST_UTIL.createMultiRegionsInMeta(TEST_UTIL.getConfiguration(),htdEnabled,SPLIT_KEYS);
  TableName disabledTable=TableName.valueOf("disabledTable");
  HTableDescriptor htdDisabled=new HTableDescriptor(disabledTable);
  htdDisabled.addFamily(new HColumnDescriptor(FAMILY));
  fstd.createTableDescriptor(htdDisabled);
  HRegionInfo hriDisabled=new HRegionInfo(htdDisabled.getTableName(),null,null);
  createRegion(hriDisabled,rootdir,conf,htdDisabled);
  List<HRegionInfo> disabledRegions=TEST_UTIL.createMultiRegionsInMeta(TEST_UTIL.getConfiguration(),htdDisabled,SPLIT_KEYS);
  TableName tableWithMergingRegions=TableName.valueOf("tableWithMergingRegions");
  TEST_UTIL.createTable(tableWithMergingRegions,FAMILY,new byte[][]{Bytes.toBytes("m")});
  log("Regions in hbase:meta and namespace have been created");
  assertEquals(4,cluster.countServedRegions());
  AssignmentManager am=master.getAssignmentManager();
  RegionStates regionStates=am.getRegionStates();
  List<HRegionInfo> mergingRegions=regionStates.getRegionsOfTable(tableWithMergingRegions);
  assertEquals(2,mergingRegions.size());
  HRegionInfo a=mergingRegions.get(0);
  HRegionInfo b=mergingRegions.get(1);
  HRegionInfo newRegion=RegionMergeTransaction.getMergedRegionInfo(a,b);
  ServerName mergingServer=regionStates.getRegionServerOfRegion(a);
  ServerName serverB=regionStates.getRegionServerOfRegion(b);
  if (!serverB.equals(mergingServer)) {
    RegionPlan plan=new RegionPlan(b,serverB,mergingServer);
    am.balance(plan);
    assertTrue(am.waitForAssignment(b));
  }
  HRegionServer hrs=cluster.getRegionServer(0);
  ServerName serverName=hrs.getServerName();
  HRegionInfo closingRegion=enabledRegions.remove(0);
  List<HRegionInfo> enabledAndAssignedRegions=new ArrayList<HRegionInfo>();
  enabledAndAssignedRegions.add(enabledRegions.remove(0));
  enabledAndAssignedRegions.add(enabledRegions.remove(0));
  enabledAndAssignedRegions.add(closingRegion);
  List<HRegionInfo> disabledAndAssignedRegions=new ArrayList<HRegionInfo>();
  disabledAndAssignedRegions.add(disabledRegions.remove(0));
  disabledAndAssignedRegions.add(disabledRegions.remove(0));
  for (  HRegionInfo hri : enabledAndAssignedRegions) {
    master.assignmentManager.regionPlans.put(hri.getEncodedName(),new RegionPlan(hri,null,serverName));
    master.assignRegion(hri);
  }
  for (  HRegionInfo hri : disabledAndAssignedRegions) {
    master.assignmentManager.regionPlans.put(hri.getEncodedName(),new RegionPlan(hri,null,serverName));
    master.assignRegion(hri);
  }
  log("Waiting for assignment to finish");
  ZKAssign.blockUntilNoRIT(zkw);
  log("Assignment completed");
  log("Aborting master");
  cluster.abortMaster(0);
  cluster.waitOnMaster(0);
  log("Master has aborted");
  ZKAssign.createNodeOffline(zkw,HRegionInfo.FIRST_META_REGIONINFO,hrs.getServerName());
  ProtobufUtil.openRegion(hrs.getRSRpcServices(),hrs.getServerName(),HRegionInfo.FIRST_META_REGIONINFO);
  while (true) {
    ServerName sn=MetaRegionTracker.getMetaRegionLocation(zkw);
    if (sn != null && sn.equals(hrs.getServerName())) {
      break;
    }
    Thread.sleep(100);
  }
  List<HRegionInfo> regionsThatShouldBeOnline=new ArrayList<HRegionInfo>();
  List<HRegionInfo> regionsThatShouldBeOffline=new ArrayList<HRegionInfo>();
  log("Beginning to mock scenarios");
  TableStateManager zktable=new ZKTableStateManager(zkw);
  zktable.setTableState(disabledTable,ZooKeeperProtos.Table.State.DISABLED);
  HRegionInfo region=enabledRegions.remove(0);
  regionsThatShouldBeOnline.add(region);
  ZKAssign.createNodeOffline(zkw,region,serverName);
  regionsThatShouldBeOnline.add(closingRegion);
  ZKAssign.createNodeClosing(zkw,closingRegion,serverName);
  region=enabledRegions.remove(0);
  regionsThatShouldBeOnline.add(region);
  int version=ZKAssign.createNodeClosing(zkw,region,serverName);
  ZKAssign.transitionNodeClosed(zkw,region,serverName,version);
  region=disabledRegions.remove(0);
  regionsThatShouldBeOffline.add(region);
  version=ZKAssign.createNodeClosing(zkw,region,serverName);
  ZKAssign.transitionNodeClosed(zkw,region,serverName,version);
  region=enabledRegions.remove(0);
  regionsThatShouldBeOnline.add(region);
  ZKAssign.createNodeOffline(zkw,region,serverName);
  ProtobufUtil.openRegion(hrs.getRSRpcServices(),hrs.getServerName(),region);
  while (true) {
    byte[] bytes=ZKAssign.getData(zkw,region.getEncodedName());
    RegionTransition rt=RegionTransition.parseFrom(bytes);
    if (rt != null && rt.getEventType().equals(EventType.RS_ZK_REGION_OPENED)) {
      break;
    }
    Thread.sleep(100);
  }
  region=disabledRegions.remove(0);
  regionsThatShouldBeOffline.add(region);
  ZKAssign.createNodeOffline(zkw,region,serverName);
  ProtobufUtil.openRegion(hrs.getRSRpcServices(),hrs.getServerName(),region);
  while (true) {
    byte[] bytes=ZKAssign.getData(zkw,region.getEncodedName());
    RegionTransition rt=RegionTransition.parseFrom(bytes);
    if (rt != null && rt.getEventType().equals(EventType.RS_ZK_REGION_OPENED)) {
      break;
    }
    Thread.sleep(100);
  }
  RegionMergeTransaction.createNodeMerging(zkw,newRegion,mergingServer,a,b);
  log("Done mocking data up in ZK");
  log("Starting up a new master");
  master=cluster.startMaster().getMaster();
  log("Waiting for master to be ready");
  cluster.waitForActiveAndReadyMaster();
  log("Master is ready");
  regionStates=master.getAssignmentManager().getRegionStates();
  assertTrue(regionStates.isRegionInState(a,State.MERGING));
  assertTrue(regionStates.isRegionInState(b,State.MERGING));
  assertTrue(regionStates.isRegionInState(newRegion,State.MERGING_NEW));
  ZKAssign.deleteNodeFailSilent(zkw,newRegion);
  log("Waiting for no more RIT");
  ZKAssign.blockUntilNoRIT(zkw);
  log("No more RIT in ZK, now doing final test verification");
  Set<HRegionInfo> onlineRegions=new TreeSet<HRegionInfo>();
  for (  JVMClusterUtil.RegionServerThread rst : cluster.getRegionServerThreads()) {
    onlineRegions.addAll(ProtobufUtil.getOnlineRegions(rst.getRegionServer().getRSRpcServices()));
  }
  for (  HRegionInfo hri : regionsThatShouldBeOnline) {
    assertTrue(onlineRegions.contains(hri));
  }
  for (  HRegionInfo hri : regionsThatShouldBeOffline) {
    if (onlineRegions.contains(hri)) {
      LOG.debug(hri);
    }
    assertFalse(onlineRegions.contains(hri));
  }
  log("Done with verification, all passed, shutting down cluster");
  TEST_UTIL.shutdownMiniCluster();
}
