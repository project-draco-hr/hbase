{
  final int NUM_MASTERS=1;
  final int NUM_RS=2;
  HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  Configuration conf=TEST_UTIL.getConfiguration();
  conf.setBoolean("hbase.assignment.usezk",true);
  conf.setInt(ServerManager.WAIT_ON_REGIONSERVERS_MINTOSTART,1);
  conf.setInt(ServerManager.WAIT_ON_REGIONSERVERS_MAXTOSTART,2);
  TEST_UTIL.startMiniCluster(NUM_MASTERS,NUM_RS);
  MiniHBaseCluster cluster=TEST_UTIL.getHBaseCluster();
  log("Cluster started");
  ZooKeeperWatcher zkw=new ZooKeeperWatcher(TEST_UTIL.getConfiguration(),"unittest",new Abortable(){
    @Override public void abort(    String why,    Throwable e){
      LOG.error("Fatal ZK Error: " + why,e);
      org.junit.Assert.assertFalse("Fatal ZK error",true);
    }
    @Override public boolean isAborted(){
      return false;
    }
  }
);
  List<MasterThread> masterThreads=cluster.getMasterThreads();
  assertEquals(1,masterThreads.size());
  assertTrue(cluster.waitForActiveAndReadyMaster());
  HMaster master=masterThreads.get(0).getMaster();
  assertTrue(master.isActiveMaster());
  assertTrue(master.isInitialized());
  master.balanceSwitch(false);
  byte[] FAMILY=Bytes.toBytes("family");
  byte[][] SPLIT_KEYS=TEST_UTIL.getRegionSplitStartKeys(Bytes.toBytes("aaa"),Bytes.toBytes("zzz"),30);
  byte[] enabledTable=Bytes.toBytes("enabledTable");
  HTableDescriptor htdEnabled=new HTableDescriptor(TableName.valueOf(enabledTable));
  htdEnabled.addFamily(new HColumnDescriptor(FAMILY));
  FileSystem filesystem=FileSystem.get(conf);
  Path rootdir=FSUtils.getRootDir(conf);
  FSTableDescriptors fstd=new FSTableDescriptors(filesystem,rootdir);
  fstd.createTableDescriptor(htdEnabled);
  HRegionInfo hriEnabled=new HRegionInfo(htdEnabled.getTableName(),null,null);
  createRegion(hriEnabled,rootdir,conf,htdEnabled);
  List<HRegionInfo> enabledRegions=TEST_UTIL.createMultiRegionsInMeta(TEST_UTIL.getConfiguration(),htdEnabled,SPLIT_KEYS);
  TableName disabledTable=TableName.valueOf("disabledTable");
  HTableDescriptor htdDisabled=new HTableDescriptor(disabledTable);
  htdDisabled.addFamily(new HColumnDescriptor(FAMILY));
  fstd.createTableDescriptor(htdDisabled);
  HRegionInfo hriDisabled=new HRegionInfo(htdDisabled.getTableName(),null,null);
  createRegion(hriDisabled,rootdir,conf,htdDisabled);
  List<HRegionInfo> disabledRegions=TEST_UTIL.createMultiRegionsInMeta(TEST_UTIL.getConfiguration(),htdDisabled,SPLIT_KEYS);
  log("Regions in hbase:meta and Namespace have been created");
  assertEquals(2,cluster.countServedRegions());
  List<RegionServerThread> regionservers=cluster.getRegionServerThreads();
  HRegionServer hrs=regionservers.get(0).getRegionServer();
  RegionServerThread hrsDeadThread=regionservers.get(1);
  HRegionServer hrsDead=hrsDeadThread.getRegionServer();
  ServerName deadServerName=hrsDead.getServerName();
  List<HRegionInfo> enabledAndAssignedRegions=new ArrayList<HRegionInfo>();
  enabledAndAssignedRegions.addAll(enabledRegions.subList(0,6));
  enabledRegions.removeAll(enabledAndAssignedRegions);
  List<HRegionInfo> disabledAndAssignedRegions=new ArrayList<HRegionInfo>();
  disabledAndAssignedRegions.addAll(disabledRegions.subList(0,6));
  disabledRegions.removeAll(disabledAndAssignedRegions);
  for (  HRegionInfo hri : enabledAndAssignedRegions) {
    master.assignmentManager.regionPlans.put(hri.getEncodedName(),new RegionPlan(hri,null,hrs.getServerName()));
    master.assignRegion(hri);
  }
  for (  HRegionInfo hri : disabledAndAssignedRegions) {
    master.assignmentManager.regionPlans.put(hri.getEncodedName(),new RegionPlan(hri,null,hrs.getServerName()));
    master.assignRegion(hri);
  }
  log("Waiting for assignment to finish");
  ZKAssign.blockUntilNoRIT(zkw);
  master.assignmentManager.waitUntilNoRegionsInTransition(60000);
  log("Assignment completed");
  assertTrue(" Table must be enabled.",master.getAssignmentManager().getTableStateManager().isTableState(TableName.valueOf("enabledTable"),ZooKeeperProtos.Table.State.ENABLED));
  List<HRegionInfo> enabledAndOnDeadRegions=new ArrayList<HRegionInfo>();
  enabledAndOnDeadRegions.addAll(enabledRegions.subList(0,6));
  enabledRegions.removeAll(enabledAndOnDeadRegions);
  List<HRegionInfo> disabledAndOnDeadRegions=new ArrayList<HRegionInfo>();
  disabledAndOnDeadRegions.addAll(disabledRegions.subList(0,6));
  disabledRegions.removeAll(disabledAndOnDeadRegions);
  for (  HRegionInfo hri : enabledAndOnDeadRegions) {
    master.assignmentManager.regionPlans.put(hri.getEncodedName(),new RegionPlan(hri,null,deadServerName));
    master.assignRegion(hri);
  }
  for (  HRegionInfo hri : disabledAndOnDeadRegions) {
    master.assignmentManager.regionPlans.put(hri.getEncodedName(),new RegionPlan(hri,null,deadServerName));
    master.assignRegion(hri);
  }
  log("Waiting for assignment to finish");
  ZKAssign.blockUntilNoRIT(zkw);
  master.assignmentManager.waitUntilNoRegionsInTransition(60000);
  log("Assignment completed");
  verifyRegionLocation(hrs,enabledAndAssignedRegions);
  verifyRegionLocation(hrs,disabledAndAssignedRegions);
  verifyRegionLocation(hrsDead,enabledAndOnDeadRegions);
  verifyRegionLocation(hrsDead,disabledAndOnDeadRegions);
  assertTrue(" Didn't get enough regions of enabledTalbe on live rs.",enabledAndAssignedRegions.size() >= 2);
  assertTrue(" Didn't get enough regions of disalbedTable on live rs.",disabledAndAssignedRegions.size() >= 2);
  assertTrue(" Didn't get enough regions of enabledTalbe on dead rs.",enabledAndOnDeadRegions.size() >= 2);
  assertTrue(" Didn't get enough regions of disalbedTable on dead rs.",disabledAndOnDeadRegions.size() >= 2);
  log("Aborting master");
  cluster.abortMaster(0);
  cluster.waitOnMaster(0);
  log("Master has aborted");
  ZKAssign.createNodeOffline(zkw,HRegionInfo.FIRST_META_REGIONINFO,hrs.getServerName());
  ProtobufUtil.openRegion(hrs.getRSRpcServices(),hrs.getServerName(),HRegionInfo.FIRST_META_REGIONINFO);
  while (true) {
    ServerName sn=MetaRegionTracker.getMetaRegionLocation(zkw);
    if (sn != null && sn.equals(hrs.getServerName())) {
      break;
    }
    Thread.sleep(100);
  }
  List<HRegionInfo> regionsThatShouldBeOnline=new ArrayList<HRegionInfo>();
  List<HRegionInfo> regionsThatShouldBeOffline=new ArrayList<HRegionInfo>();
  log("Beginning to mock scenarios");
  TableStateManager zktable=new ZKTableStateManager(zkw);
  zktable.setTableState(disabledTable,ZooKeeperProtos.Table.State.DISABLED);
  assertTrue(" The enabled table should be identified on master fail over.",zktable.isTableState(TableName.valueOf("enabledTable"),ZooKeeperProtos.Table.State.ENABLED));
  HRegionInfo region=enabledAndOnDeadRegions.remove(0);
  regionsThatShouldBeOnline.add(region);
  ZKAssign.createNodeClosing(zkw,region,deadServerName);
  LOG.debug("\n\nRegion of enabled table was CLOSING on dead RS\n" + region + "\n\n");
  region=disabledAndOnDeadRegions.remove(0);
  regionsThatShouldBeOffline.add(region);
  ZKAssign.createNodeClosing(zkw,region,deadServerName);
  LOG.debug("\n\nRegion of disabled table was CLOSING on dead RS\n" + region + "\n\n");
  region=enabledAndOnDeadRegions.remove(0);
  regionsThatShouldBeOnline.add(region);
  int version=ZKAssign.createNodeClosing(zkw,region,deadServerName);
  ZKAssign.transitionNodeClosed(zkw,region,deadServerName,version);
  LOG.debug("\n\nRegion of enabled table was CLOSED on dead RS\n" + region + "\n\n");
  region=disabledAndOnDeadRegions.remove(0);
  regionsThatShouldBeOffline.add(region);
  version=ZKAssign.createNodeClosing(zkw,region,deadServerName);
  ZKAssign.transitionNodeClosed(zkw,region,deadServerName,version);
  LOG.debug("\n\nRegion of disabled table was CLOSED on dead RS\n" + region + "\n\n");
  region=enabledRegions.remove(0);
  regionsThatShouldBeOnline.add(region);
  ZKAssign.createNodeOffline(zkw,region,deadServerName);
  ZKAssign.transitionNodeOpening(zkw,region,deadServerName);
  LOG.debug("\n\nRegion of enabled table was OPENING on dead RS\n" + region + "\n\n");
  region=disabledRegions.remove(0);
  regionsThatShouldBeOffline.add(region);
  ZKAssign.createNodeOffline(zkw,region,deadServerName);
  ZKAssign.transitionNodeOpening(zkw,region,deadServerName);
  LOG.debug("\n\nRegion of disabled table was OPENING on dead RS\n" + region + "\n\n");
  region=enabledRegions.remove(0);
  regionsThatShouldBeOnline.add(region);
  ZKAssign.createNodeOffline(zkw,region,deadServerName);
  ProtobufUtil.openRegion(hrsDead.getRSRpcServices(),hrsDead.getServerName(),region);
  while (true) {
    byte[] bytes=ZKAssign.getData(zkw,region.getEncodedName());
    RegionTransition rt=RegionTransition.parseFrom(bytes);
    if (rt != null && rt.getEventType().equals(EventType.RS_ZK_REGION_OPENED)) {
      break;
    }
    Thread.sleep(100);
  }
  LOG.debug("\n\nRegion of enabled table was OPENED on dead RS\n" + region + "\n\n");
  region=disabledRegions.remove(0);
  regionsThatShouldBeOffline.add(region);
  ZKAssign.createNodeOffline(zkw,region,deadServerName);
  ProtobufUtil.openRegion(hrsDead.getRSRpcServices(),hrsDead.getServerName(),region);
  while (true) {
    byte[] bytes=ZKAssign.getData(zkw,region.getEncodedName());
    RegionTransition rt=RegionTransition.parseFrom(bytes);
    if (rt != null && rt.getEventType().equals(EventType.RS_ZK_REGION_OPENED)) {
      break;
    }
    Thread.sleep(100);
  }
  LOG.debug("\n\nRegion of disabled table was OPENED on dead RS\n" + region + "\n\n");
  region=enabledRegions.remove(0);
  regionsThatShouldBeOnline.add(region);
  ZKAssign.createNodeOffline(zkw,region,deadServerName);
  ProtobufUtil.openRegion(hrsDead.getRSRpcServices(),hrsDead.getServerName(),region);
  while (true) {
    byte[] bytes=ZKAssign.getData(zkw,region.getEncodedName());
    RegionTransition rt=RegionTransition.parseFrom(bytes);
    if (rt != null && rt.getEventType().equals(EventType.RS_ZK_REGION_OPENED)) {
      ZKAssign.deleteOpenedNode(zkw,region.getEncodedName(),rt.getServerName());
      LOG.debug("DELETED " + rt);
      break;
    }
    Thread.sleep(100);
  }
  LOG.debug("\n\nRegion of enabled table was open at steady-state on dead RS" + "\n" + region + "\n\n");
  region=disabledRegions.remove(0);
  regionsThatShouldBeOffline.add(region);
  ZKAssign.createNodeOffline(zkw,region,deadServerName);
  ProtobufUtil.openRegion(hrsDead.getRSRpcServices(),hrsDead.getServerName(),region);
  while (true) {
    byte[] bytes=ZKAssign.getData(zkw,region.getEncodedName());
    RegionTransition rt=RegionTransition.parseFrom(bytes);
    if (rt != null && rt.getEventType().equals(EventType.RS_ZK_REGION_OPENED)) {
      ZKAssign.deleteOpenedNode(zkw,region.getEncodedName(),rt.getServerName());
      break;
    }
    Thread.sleep(100);
  }
  LOG.debug("\n\nRegion of disabled table was open at steady-state on dead RS" + "\n" + region + "\n\n");
  log("Done mocking data up in ZK");
  log("Killing RS " + deadServerName);
  hrsDead.abort("Killing for unit test");
  log("RS " + deadServerName + " killed");
  while (hrsDeadThread.isAlive()) {
    Threads.sleep(10);
  }
  log("Starting up a new master");
  master=cluster.startMaster().getMaster();
  log("Waiting for master to be ready");
  assertTrue(cluster.waitForActiveAndReadyMaster());
  log("Master is ready");
  while (master.getServerManager().areDeadServersInProgress()) {
    Thread.sleep(10);
  }
  log("Waiting for no more RIT");
  ZKAssign.blockUntilNoRIT(zkw);
  log("No more RIT in ZK");
  long now=System.currentTimeMillis();
  long maxTime=120000;
  boolean done=master.assignmentManager.waitUntilNoRegionsInTransition(maxTime);
  if (!done) {
    RegionStates regionStates=master.getAssignmentManager().getRegionStates();
    LOG.info("rit=" + regionStates.getRegionsInTransition());
  }
  long elapsed=System.currentTimeMillis() - now;
  assertTrue("Elapsed=" + elapsed + ", maxTime="+ maxTime+ ", done="+ done,elapsed < maxTime);
  log("No more RIT in RIT map, doing final test verification");
  Set<HRegionInfo> onlineRegions=new TreeSet<HRegionInfo>();
  now=System.currentTimeMillis();
  maxTime=30000;
  for (  JVMClusterUtil.RegionServerThread rst : cluster.getRegionServerThreads()) {
    try {
      HRegionServer rs=rst.getRegionServer();
      while (!rs.getRegionsInTransitionInRS().isEmpty()) {
        elapsed=System.currentTimeMillis() - now;
        assertTrue("Test timed out in getting online regions",elapsed < maxTime);
        if (rs.isAborted() || rs.isStopped()) {
          break;
        }
        Thread.sleep(100);
      }
      onlineRegions.addAll(ProtobufUtil.getOnlineRegions(rs.getRSRpcServices()));
    }
 catch (    RegionServerStoppedException e) {
      LOG.info("Got RegionServerStoppedException",e);
    }
  }
  for (  HRegionInfo hri : regionsThatShouldBeOnline) {
    assertTrue("region=" + hri.getRegionNameAsString() + ", "+ onlineRegions.toString(),onlineRegions.contains(hri));
  }
  for (  HRegionInfo hri : regionsThatShouldBeOffline) {
    assertFalse(onlineRegions.contains(hri));
  }
  log("Done with verification, all passed, shutting down cluster");
  TEST_UTIL.shutdownMiniCluster();
}
