{
  blockBuffer.mark();
  currKeyLen=blockBuffer.getInt();
  currValueLen=blockBuffer.getInt();
  ByteBufferUtils.skip(blockBuffer,currKeyLen + currValueLen);
  if (reader.hfileContext.shouldIncludeTags()) {
    currTagsLen=blockBuffer.getShort();
    ByteBufferUtils.skip(blockBuffer,currTagsLen);
  }
  readMvccVersion();
  if (currKeyLen < 0 || currValueLen < 0 || currTagsLen < 0 || currKeyLen > blockBuffer.limit() || currValueLen > blockBuffer.limit() || currTagsLen > blockBuffer.limit()) {
    throw new IllegalStateException("Invalid currKeyLen " + currKeyLen + " or currValueLen "+ currValueLen+ " or currTagLen "+ currTagsLen+ ". Block offset: "+ block.getOffset()+ ", block length: "+ blockBuffer.limit()+ ", position: "+ blockBuffer.position()+ " (without header).");
  }
  blockBuffer.reset();
}
