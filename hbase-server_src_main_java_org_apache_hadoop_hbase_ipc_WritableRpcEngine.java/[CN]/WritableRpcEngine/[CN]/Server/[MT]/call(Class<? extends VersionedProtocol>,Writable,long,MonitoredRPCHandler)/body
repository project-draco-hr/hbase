{
  try {
    Invocation call=(Invocation)param;
    if (call.getMethodName() == null) {
      throw new IOException("Could not find requested method, the usual " + "cause is a version mismatch between client and server.");
    }
    if (verbose)     log("Call: " + call);
    status.setRPC(call.getMethodName(),call.getParameters(),receivedTime);
    status.setRPCPacket(param);
    status.resume("Servicing call");
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    if (!method.getDeclaringClass().equals(VersionedProtocol.class)) {
      long clientVersion=call.getProtocolVersion();
      ProtocolSignature serverInfo=((VersionedProtocol)instance).getProtocolSignature(protocol.getCanonicalName(),call.getProtocolVersion(),call.getClientMethodsHash());
      long serverVersion=serverInfo.getVersion();
      if (serverVersion != clientVersion) {
        LOG.warn("Version mismatch: client version=" + clientVersion + ", server version="+ serverVersion);
        throw new RPC.VersionMismatch(protocol.getName(),clientVersion,serverVersion);
      }
    }
    Object impl=null;
    if (protocol.isAssignableFrom(this.implementation)) {
      impl=this.instance;
    }
 else {
      throw new HBaseRPC.UnknownProtocolException(protocol);
    }
    long startTime=System.currentTimeMillis();
    Object[] params=call.getParameters();
    Object value=method.invoke(impl,params);
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (TRACELOG.isDebugEnabled()) {
      TRACELOG.debug("Call #" + CurCall.get().id + "; Served: "+ protocol.getSimpleName()+ "#"+ call.getMethodName()+ " queueTime="+ qTime+ " processingTime="+ processingTime+ " contents="+ Objects.describeQuantity(params));
    }
    rpcMetrics.rpcQueueTime.inc(qTime);
    rpcMetrics.rpcProcessingTime.inc(processingTime);
    rpcMetrics.inc(call.getMethodName(),processingTime);
    if (verbose)     log("Return: " + value);
    HbaseObjectWritable retVal=new HbaseObjectWritable(method.getReturnType(),value);
    long responseSize=retVal.getWritableSize();
    boolean tooSlow=(processingTime > warnResponseTime && warnResponseTime > -1);
    boolean tooLarge=(responseSize > warnResponseSize && warnResponseSize > -1);
    if (tooSlow || tooLarge) {
      logResponse(call,(tooLarge ? "TooLarge" : "TooSlow"),status.getClient(),startTime,processingTime,qTime,responseSize);
      if (tooSlow) {
        rpcMetrics.rpcSlowResponseTime.inc(processingTime);
      }
    }
    if (processingTime > 1000) {
      rpcMetrics.inc(call.getMethodName() + ABOVE_ONE_SEC_METRIC,processingTime);
    }
    return retVal;
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
    if (target instanceof ServiceException) {
      throw ProtobufUtil.getRemoteException((ServiceException)target);
    }
    IOException ioe=new IOException(target.toString());
    ioe.setStackTrace(target.getStackTrace());
    throw ioe;
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}
