{
  StoreFile.Writer writer;
  String fileName;
  long flushed=0;
  if (set.size() == 0) {
    return null;
  }
  Scan scan=new Scan();
  scan.setMaxVersions(maxVersions);
  InternalScanner scanner=new StoreScanner(this,scan,Collections.singletonList(new CollectionBackedScanner(set,this.comparator)),true);
  try {
synchronized (flushLock) {
      status.setStatus("Flushing " + this + ": creating writer");
      writer=createWriterInTmp(set.size());
      writer.setTimeRangeTracker(snapshotTimeRangeTracker);
      fileName=writer.getPath().getName();
      try {
        List<KeyValue> kvs=new ArrayList<KeyValue>();
        boolean hasMore;
        do {
          hasMore=scanner.next(kvs);
          if (!kvs.isEmpty()) {
            for (            KeyValue kv : kvs) {
              writer.append(kv);
              flushed+=this.memstore.heapSizeChange(kv,true);
            }
            kvs.clear();
          }
        }
 while (hasMore);
      }
  finally {
        status.setStatus("Flushing " + this + ": appending metadata");
        writer.appendMetadata(logCacheFlushId,false);
        status.setStatus("Flushing " + this + ": closing flushed file");
        writer.close();
      }
    }
  }
  finally {
    scanner.close();
  }
  Path dstPath=new Path(homedir,fileName);
  validateStoreFile(writer.getPath());
  String msg="Renaming flushed file at " + writer.getPath() + " to "+ dstPath;
  LOG.info(msg);
  status.setStatus("Flushing " + this + ": "+ msg);
  if (!fs.rename(writer.getPath(),dstPath)) {
    LOG.warn("Unable to rename " + writer.getPath() + " to "+ dstPath);
  }
  status.setStatus("Flushing " + this + ": reopening flushed file");
  StoreFile sf=new StoreFile(this.fs,dstPath,this.conf,this.cacheConf,this.family.getBloomFilterType());
  StoreFile.Reader r=sf.createReader();
  this.storeSize+=r.length();
  this.totalUncompressedBytes+=r.getTotalUncompressedBytes();
  if (LOG.isInfoEnabled()) {
    LOG.info("Added " + sf + ", entries="+ r.getEntries()+ ", sequenceid="+ logCacheFlushId+ ", memsize="+ StringUtils.humanReadableInt(flushed)+ ", filesize="+ StringUtils.humanReadableInt(r.length()));
  }
  return sf;
}
