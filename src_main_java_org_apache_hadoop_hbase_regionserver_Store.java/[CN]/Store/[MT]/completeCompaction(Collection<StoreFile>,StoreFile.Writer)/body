{
  StoreFile result=null;
  if (compactedFile != null) {
    Path p=null;
    try {
      p=StoreFile.rename(this.fs,compactedFile.getPath(),StoreFile.getRandomFilename(fs,this.homedir));
    }
 catch (    IOException e) {
      LOG.error("Failed move of compacted file " + compactedFile.getPath(),e);
      return null;
    }
    result=new StoreFile(this.fs,p,this.conf,this.cacheConf,this.family.getBloomFilterType());
    result.createReader();
  }
  this.lock.writeLock().lock();
  try {
    try {
      ArrayList<StoreFile> newStoreFiles=Lists.newArrayList(storefiles);
      newStoreFiles.removeAll(compactedFiles);
      filesCompacting.removeAll(compactedFiles);
      if (result != null) {
        newStoreFiles.add(result);
      }
      this.storefiles=sortAndClone(newStoreFiles);
      notifyChangedReadersObservers();
      for (      StoreFile hsf : compactedFiles) {
        hsf.deleteReader();
      }
    }
 catch (    IOException e) {
      e=RemoteExceptionHandler.checkIOException(e);
      LOG.error("Failed replacing compacted files in " + this.storeNameStr + ". Compacted file is "+ (result == null ? "none" : result.toString())+ ".  Files replaced "+ compactedFiles.toString()+ " some of which may have been already removed",e);
    }
    this.storeSize=0L;
    this.totalUncompressedBytes=0L;
    for (    StoreFile hsf : this.storefiles) {
      StoreFile.Reader r=hsf.getReader();
      if (r == null) {
        LOG.warn("StoreFile " + hsf + " has a null Reader");
        continue;
      }
      this.storeSize+=r.length();
      this.totalUncompressedBytes+=r.getTotalUncompressedBytes();
    }
  }
  finally {
    this.lock.writeLock().unlock();
  }
  return result;
}
