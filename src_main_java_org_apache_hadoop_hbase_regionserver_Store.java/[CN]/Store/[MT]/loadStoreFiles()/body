{
  ArrayList<StoreFile> results=new ArrayList<StoreFile>();
  FileStatus files[]=this.fs.listStatus(this.homedir);
  for (int i=0; files != null && i < files.length; i++) {
    if (files[i].isDir()) {
      continue;
    }
    Path p=files[i].getPath();
    if (this.fs.getFileStatus(p).getLen() <= 0) {
      LOG.warn("Skipping " + p + " because its empty. HBASE-646 DATA LOSS?");
      continue;
    }
    StoreFile curfile=null;
    try {
      curfile=new StoreFile(fs,p,blockcache,this.conf,this.family.getBloomFilterType(),this.inMemory);
      curfile.createReader();
    }
 catch (    IOException ioe) {
      LOG.warn("Failed open of " + p + "; presumption is that file was "+ "corrupted at flush and lost edits picked up by commit log replay. "+ "Verify!",ioe);
      continue;
    }
    long length=curfile.getReader().length();
    this.storeSize+=length;
    if (LOG.isDebugEnabled()) {
      LOG.debug("loaded " + curfile.toStringDetailed());
    }
    results.add(curfile);
  }
  maxSeqId=StoreFile.getMaxSequenceIdInList(results);
  Collections.sort(results,StoreFile.Comparators.FLUSH_TIME);
  return results;
}
