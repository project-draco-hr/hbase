{
  CompactSelection compactSelection=new CompactSelection(conf,candidates);
  boolean forcemajor=this.forceMajor && filesCompacting.isEmpty();
  if (!forcemajor) {
    int pos=0;
    while (pos < compactSelection.getFilesToCompact().size() && compactSelection.getFilesToCompact().get(pos).getReader().length() > maxCompactSize && !compactSelection.getFilesToCompact().get(pos).isReference())     ++pos;
    compactSelection.clearSubList(0,pos);
  }
  if (compactSelection.getFilesToCompact().isEmpty()) {
    LOG.debug(this.getHRegionInfo().getEncodedName() + " - " + this.storeNameStr+ ": no store files to compact");
    compactSelection.emptyFileList();
    return compactSelection;
  }
  boolean majorcompaction=(forcemajor || isMajorCompaction(compactSelection.getFilesToCompact())) && compactSelection.getFilesToCompact().size() < this.maxFilesToCompact;
  if (!majorcompaction && !hasReferences(compactSelection.getFilesToCompact())) {
    int start=0;
    double r=compactSelection.getCompactSelectionRatio();
    if (compactSelection.getFilesToCompact().size() < this.minFilesToCompact) {
      compactSelection.emptyFileList();
      return compactSelection;
    }
    compactSelection.getFilesToCompact().removeAll(Collections2.filter(compactSelection.getFilesToCompact(),new Predicate<StoreFile>(){
      public boolean apply(      StoreFile input){
        return input.excludeFromMinorCompaction();
      }
    }
));
    int countOfFiles=compactSelection.getFilesToCompact().size();
    long[] fileSizes=new long[countOfFiles];
    long[] sumSize=new long[countOfFiles];
    for (int i=countOfFiles - 1; i >= 0; --i) {
      StoreFile file=compactSelection.getFilesToCompact().get(i);
      fileSizes[i]=file.getReader().length();
      int tooFar=i + this.maxFilesToCompact - 1;
      sumSize[i]=fileSizes[i] + ((i + 1 < countOfFiles) ? sumSize[i + 1] : 0) - ((tooFar < countOfFiles) ? fileSizes[tooFar] : 0);
    }
    while (countOfFiles - start >= this.minFilesToCompact && fileSizes[start] > Math.max(minCompactSize,(long)(sumSize[start + 1] * r))) {
      ++start;
    }
    int end=Math.min(countOfFiles,start + this.maxFilesToCompact);
    long totalSize=fileSizes[start] + ((start + 1 < countOfFiles) ? sumSize[start + 1] : 0);
    compactSelection=compactSelection.getSubList(start,end);
    if (compactSelection.getFilesToCompact().size() < this.minFilesToCompact) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Skipped compaction of " + this.storeNameStr + ".  Only "+ (end - start)+ " file(s) of size "+ StringUtils.humanReadableInt(totalSize)+ " have met compaction criteria.");
      }
      compactSelection.emptyFileList();
      return compactSelection;
    }
  }
 else {
    if (compactSelection.getFilesToCompact().size() > this.maxFilesToCompact) {
      int pastMax=compactSelection.getFilesToCompact().size() - this.maxFilesToCompact;
      compactSelection.clearSubList(0,pastMax);
    }
  }
  return compactSelection;
}
