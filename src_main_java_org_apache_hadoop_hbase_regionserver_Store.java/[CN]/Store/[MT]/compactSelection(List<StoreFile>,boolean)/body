{
  List<StoreFile> filesToCompact=new ArrayList<StoreFile>(candidates);
  if (this.maxCompactSize > 0) {
    final long msize=this.maxCompactSize;
    filesToCompact.removeAll(Collections2.filter(filesToCompact,new Predicate<StoreFile>(){
      public boolean apply(      StoreFile sf){
        return sf.getReader().length() > msize && !sf.isReference();
      }
    }
));
  }
  boolean majorcompaction=forcemajor || (isMajorCompaction(filesToCompact) && filesToCompact.size() > this.maxFilesToCompact);
  if (filesToCompact.isEmpty()) {
    LOG.debug(this.storeNameStr + ": no store files to compact");
    return filesToCompact;
  }
  if (!majorcompaction && !hasReferences(filesToCompact)) {
    int start=0;
    double r=this.compactRatio;
    Collections.sort(filesToCompact,StoreFile.Comparators.FILE_SIZE);
    int countOfFiles=filesToCompact.size();
    long[] fileSizes=new long[countOfFiles];
    long[] sumSize=new long[countOfFiles];
    for (int i=countOfFiles - 1; i >= 0; --i) {
      StoreFile file=filesToCompact.get(i);
      fileSizes[i]=file.getReader().length();
      int tooFar=i + this.maxFilesToCompact - 1;
      sumSize[i]=fileSizes[i] + ((i + 1 < countOfFiles) ? sumSize[i + 1] : 0) - ((tooFar < countOfFiles) ? fileSizes[tooFar] : 0);
    }
    while (countOfFiles - start >= this.minFilesToCompact && fileSizes[start] > Math.max(minCompactSize,(long)(sumSize[start + 1] * r))) {
      ++start;
    }
    int end=Math.min(countOfFiles,start + this.maxFilesToCompact);
    long totalSize=fileSizes[start] + ((start + 1 < countOfFiles) ? sumSize[start + 1] : 0);
    filesToCompact=filesToCompact.subList(start,end);
    if (filesToCompact.size() < this.minFilesToCompact) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Skipped compaction of " + this.storeNameStr + ".  Only "+ (end - start)+ " file(s) of size "+ StringUtils.humanReadableInt(totalSize)+ " have met compaction criteria.");
      }
      return Collections.emptyList();
    }
  }
 else {
    if (filesToCompact.size() > this.maxFilesToCompact) {
      int pastMax=filesToCompact.size() - this.maxFilesToCompact;
      filesToCompact.subList(0,pastMax).clear();
    }
  }
  return filesToCompact;
}
