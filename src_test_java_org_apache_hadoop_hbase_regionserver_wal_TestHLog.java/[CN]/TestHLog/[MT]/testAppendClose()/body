{
  byte[] tableName=Bytes.toBytes(getName());
  HRegionInfo regioninfo=new HRegionInfo(tableName,HConstants.EMPTY_START_ROW,HConstants.EMPTY_END_ROW,false);
  Path subdir=new Path(dir,"hlogdir");
  Path archdir=new Path(dir,"hlogdir_archive");
  HLog wal=new HLog(fs,subdir,archdir,conf);
  final int total=20;
  HTableDescriptor htd=new HTableDescriptor();
  htd.addFamily(new HColumnDescriptor(tableName));
  for (int i=0; i < total; i++) {
    WALEdit kvs=new WALEdit();
    kvs.add(new KeyValue(Bytes.toBytes(i),tableName,tableName));
    wal.append(regioninfo,tableName,kvs,System.currentTimeMillis(),htd);
  }
  wal.sync();
  int namenodePort=cluster.getNameNodePort();
  final Path walPath=wal.computeFilename();
  try {
    cluster.getNameNode().setSafeMode(SafeModeAction.SAFEMODE_ENTER);
    cluster.shutdown();
    try {
      wal.close();
    }
 catch (    IOException e) {
      LOG.info(e);
    }
    fs.close();
    LOG.info("STOPPED first instance of the cluster");
  }
  finally {
    while (cluster.isClusterUp()) {
      LOG.error("Waiting for cluster to go down");
      Thread.sleep(1000);
    }
    Thread.sleep(2000);
    cluster=new MiniDFSCluster(namenodePort,conf,5,false,true,true,null,null,null,null);
    cluster.waitActive();
    fs=cluster.getFileSystem();
    LOG.info("START second instance.");
  }
  Method setLeasePeriod=cluster.getClass().getDeclaredMethod("setLeasePeriod",new Class[]{Long.TYPE,Long.TYPE});
  setLeasePeriod.setAccessible(true);
  setLeasePeriod.invoke(cluster,new Object[]{new Long(1000),new Long(1000)});
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
    LOG.info(e);
  }
  final FileSystem recoveredFs=fs;
  final Configuration rlConf=conf;
class RecoverLogThread extends Thread {
    public Exception exception=null;
    public void run(){
      try {
        FSUtils.recoverFileLease(recoveredFs,walPath,rlConf);
      }
 catch (      IOException e) {
        exception=e;
      }
    }
  }
  RecoverLogThread t=new RecoverLogThread();
  t.start();
  t.join(60 * 1000);
  if (t.isAlive()) {
    t.interrupt();
    throw new Exception("Timed out waiting for HLog.recoverLog()");
  }
  if (t.exception != null)   throw t.exception;
  SequenceFile.Reader reader=new SequenceFile.Reader(this.fs,walPath,this.conf);
  int count=0;
  HLogKey key=HLog.newKey(conf);
  WALEdit val=new WALEdit();
  while (reader.next(key,val)) {
    count++;
    assertTrue("Should be one KeyValue per WALEdit",val.getKeyValues().size() == 1);
  }
  assertEquals(total,count);
  reader.close();
}
