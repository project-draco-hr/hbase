{
  if (entries.length == 0) {
    return;
  }
  try {
    long totalReplicated=0;
    Map<byte[],List<Row>> rows=new TreeMap<byte[],List<Row>>(Bytes.BYTES_COMPARATOR);
    for (    HLog.Entry entry : entries) {
      WALEdit edit=entry.getEdit();
      byte[] table=entry.getKey().getTablename();
      Put put=null;
      Delete del=null;
      KeyValue lastKV=null;
      List<KeyValue> kvs=edit.getKeyValues();
      for (      KeyValue kv : kvs) {
        if (lastKV == null || lastKV.getType() != kv.getType() || !lastKV.matchingRow(kv)) {
          if (kv.isDelete()) {
            del=new Delete(kv.getRow());
            del.setClusterId(entry.getKey().getClusterId());
            addToMultiMap(rows,table,del);
          }
 else {
            put=new Put(kv.getRow());
            put.setClusterId(entry.getKey().getClusterId());
            addToMultiMap(rows,table,put);
          }
        }
        if (kv.isDelete()) {
          del.addDeleteMarker(kv);
        }
 else {
          put.add(kv);
        }
        lastKV=kv;
      }
      totalReplicated++;
    }
    for (    Entry<byte[],List<Row>> entry : rows.entrySet()) {
      batch(entry.getKey(),entry.getValue());
    }
    this.metrics.setAgeOfLastAppliedOp(entries[entries.length - 1].getKey().getWriteTime());
    this.metrics.applyBatch(entries.length);
    LOG.info("Total replicated: " + totalReplicated);
  }
 catch (  IOException ex) {
    LOG.error("Unable to accept edit because:",ex);
    throw ex;
  }
}
