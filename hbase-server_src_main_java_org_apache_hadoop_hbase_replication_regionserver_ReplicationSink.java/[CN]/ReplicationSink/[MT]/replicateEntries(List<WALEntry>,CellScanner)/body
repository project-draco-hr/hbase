{
  if (entries.isEmpty())   return;
  if (cells == null)   throw new NullPointerException("TODO: Add handling of null CellScanner");
  try {
    long totalReplicated=0;
    Map<TableName,Map<List<UUID>,List<Row>>> rowMap=new TreeMap<TableName,Map<List<UUID>,List<Row>>>();
    for (    WALEntry entry : entries) {
      TableName table=TableName.valueOf(entry.getKey().getTableName().toByteArray());
      Cell previousCell=null;
      Mutation m=null;
      int count=entry.getAssociatedCellCount();
      for (int i=0; i < count; i++) {
        if (!cells.advance()) {
          throw new ArrayIndexOutOfBoundsException("Expected=" + count + ", index="+ i);
        }
        Cell cell=cells.current();
        if (isNewRowOrType(previousCell,cell)) {
          m=CellUtil.isDelete(cell) ? new Delete(cell.getRowArray(),cell.getRowOffset(),cell.getRowLength()) : new Put(cell.getRowArray(),cell.getRowOffset(),cell.getRowLength());
          List<UUID> clusterIds=new ArrayList<UUID>();
          for (          HBaseProtos.UUID clusterId : entry.getKey().getClusterIdsList()) {
            clusterIds.add(toUUID(clusterId));
          }
          m.setClusterIds(clusterIds);
          addToHashMultiMap(rowMap,table,clusterIds,m);
        }
        if (CellUtil.isDelete(cell)) {
          ((Delete)m).addDeleteMarker(cell);
        }
 else {
          ((Put)m).add(cell);
        }
        previousCell=cell;
      }
      totalReplicated++;
    }
    for (    Entry<TableName,Map<List<UUID>,List<Row>>> entry : rowMap.entrySet()) {
      batch(entry.getKey(),entry.getValue().values());
    }
    int size=entries.size();
    this.metrics.setAgeOfLastAppliedOp(entries.get(size - 1).getKey().getWriteTime());
    this.metrics.applyBatch(size);
    this.totalReplicatedEdits.addAndGet(totalReplicated);
  }
 catch (  IOException ex) {
    LOG.error("Unable to accept edit because:",ex);
    throw ex;
  }
}
