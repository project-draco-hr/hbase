{
  FileDetails fd=getFileDetails(request.getFiles(),request.isAllFiles());
  this.progress=new CompactionProgress(fd.maxKeyCount);
  long smallestReadPoint=getSmallestReadPoint();
  List<StoreFileScanner> scanners=createFileScanners(request.getFiles(),smallestReadPoint);
  StoreFile.Writer writer=null;
  List<Path> newFiles=new ArrayList<Path>();
  boolean cleanSeqId=false;
  try {
    InternalScanner scanner=null;
    try {
      ScanType scanType=request.isAllFiles() ? ScanType.COMPACT_DROP_DELETES : ScanType.COMPACT_RETAIN_DELETES;
      scanner=preCreateCoprocScanner(request,scanType,fd.earliestPutTs,scanners);
      if (scanner == null) {
        scanner=createScanner(store,scanners,scanType,smallestReadPoint,fd.earliestPutTs);
      }
      scanner=postCreateCoprocScanner(request,scanType,scanner);
      if (scanner == null) {
        return newFiles;
      }
      if (fd.minSeqIdToKeep > 0) {
        smallestReadPoint=Math.min(fd.minSeqIdToKeep,smallestReadPoint);
        cleanSeqId=true;
      }
      writer=store.createWriterInTmp(fd.maxKeyCount,this.compactionCompression,true,fd.maxMVCCReadpoint >= smallestReadPoint,fd.maxTagsLength > 0);
      boolean finished=performCompaction(scanner,writer,smallestReadPoint,cleanSeqId);
      if (!finished) {
        writer.close();
        store.getFileSystem().delete(writer.getPath(),false);
        writer=null;
        throw new InterruptedIOException("Aborting compaction of store " + store + " in region "+ store.getRegionInfo().getRegionNameAsString()+ " because it was interrupted.");
      }
    }
  finally {
      if (scanner != null) {
        scanner.close();
      }
    }
  }
  finally {
    if (writer != null) {
      writer.appendMetadata(fd.maxSeqId,request.isAllFiles());
      writer.close();
      newFiles.add(writer.getPath());
    }
  }
  return newFiles;
}
