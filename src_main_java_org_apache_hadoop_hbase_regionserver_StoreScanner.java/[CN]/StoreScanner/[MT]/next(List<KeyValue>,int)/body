{
  checkReseek();
  if (this.heap == null) {
    close();
    return false;
  }
  KeyValue peeked=this.heap.peek();
  if (peeked == null) {
    close();
    return false;
  }
  if ((matcher.row == null) || !peeked.matchingRow(matcher.row)) {
    matcher.setRow(peeked.getRow());
  }
  KeyValue kv;
  List<KeyValue> results=new ArrayList<KeyValue>();
  LOOP:   while ((kv=this.heap.peek()) != null) {
    ScanQueryMatcher.MatchCode qcode=matcher.match(kv);
switch (qcode) {
case INCLUDE:
      KeyValue next=this.heap.next();
    results.add(next);
  if (limit > 0 && (results.size() == limit)) {
    break LOOP;
  }
continue;
case DONE:
outResult.addAll(results);
return true;
case DONE_SCAN:
close();
outResult.addAll(results);
return false;
case SEEK_NEXT_ROW:
if (!matcher.moreRowsMayExistAfter(kv)) {
outResult.addAll(results);
return false;
}
heap.next();
break;
case SEEK_NEXT_COL:
heap.next();
break;
case SKIP:
this.heap.next();
break;
default :
throw new RuntimeException("UNEXPECTED");
}
}
if (!results.isEmpty()) {
outResult.addAll(results);
return true;
}
close();
return false;
}
