{
  int numTotalKeys=99;
  assertTrue(numTotalKeys % 2 == 1);
  int numSearchedKeys=(numTotalKeys - 1) / 2;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(baos);
  dos.writeInt(numSearchedKeys);
  int curAllEntriesSize=0;
  int numEntriesAdded=0;
  int secondaryIndexEntries[]=new int[numTotalKeys];
  for (int i=0; i < numTotalKeys; ++i) {
    byte[] k=TestHFileWriterV2.randomOrderedKey(rand,i * 2);
    keys.add(k);
    String msgPrefix="Key #" + i + " ("+ Bytes.toStringBinary(k)+ "): ";
    StringBuilder padding=new StringBuilder();
    while (msgPrefix.length() + padding.length() < 70)     padding.append(' ');
    msgPrefix+=padding;
    if (i % 2 == 1) {
      dos.writeInt(curAllEntriesSize);
      secondaryIndexEntries[i]=curAllEntriesSize;
      LOG.info(msgPrefix + "secondary index entry #" + ((i - 1) / 2)+ ", offset "+ curAllEntriesSize);
      curAllEntriesSize+=k.length + HFileBlockIndex.SECONDARY_INDEX_ENTRY_OVERHEAD;
      ++numEntriesAdded;
    }
 else {
      secondaryIndexEntries[i]=-1;
      LOG.info(msgPrefix + "not in the searched array");
    }
  }
  for (int i=0; i < keys.size() - 1; ++i)   assertTrue(Bytes.BYTES_RAWCOMPARATOR.compare(keys.get(i),keys.get(i + 1)) < 0);
  dos.writeInt(curAllEntriesSize);
  assertEquals(numSearchedKeys,numEntriesAdded);
  int secondaryIndexOffset=dos.size();
  assertEquals(Bytes.SIZEOF_INT * (numSearchedKeys + 2),secondaryIndexOffset);
  for (int i=1; i <= numTotalKeys - 1; i+=2) {
    assertEquals(dos.size(),secondaryIndexOffset + secondaryIndexEntries[i]);
    long dummyFileOffset=getDummyFileOffset(i);
    int dummyOnDiskSize=getDummyOnDiskSize(i);
    LOG.debug("Storing file offset=" + dummyFileOffset + " and onDiskSize="+ dummyOnDiskSize+ " at offset "+ dos.size());
    dos.writeLong(dummyFileOffset);
    dos.writeInt(dummyOnDiskSize);
    LOG.debug("Stored key " + ((i - 1) / 2) + " at offset "+ dos.size());
    dos.write(keys.get(i));
  }
  dos.writeInt(curAllEntriesSize);
  ByteBuffer nonRootIndex=ByteBuffer.wrap(baos.toByteArray());
  for (int i=0; i < numTotalKeys; ++i) {
    byte[] searchKey=keys.get(i);
    byte[] arrayHoldingKey=new byte[searchKey.length + searchKey.length / 2];
    System.arraycopy(searchKey,0,arrayHoldingKey,searchKey.length / 2,searchKey.length);
    int searchResult=BlockIndexReader.binarySearchNonRootIndex(arrayHoldingKey,searchKey.length / 2,searchKey.length,nonRootIndex,KeyValue.RAW_COMPARATOR);
    String lookupFailureMsg="Failed to look up key #" + i + " ("+ Bytes.toStringBinary(searchKey)+ ")";
    int expectedResult;
    int referenceItem;
    if (i % 2 == 1) {
      expectedResult=(i - 1) / 2;
      referenceItem=i;
    }
 else {
      expectedResult=i / 2 - 1;
      referenceItem=i - 1;
    }
    assertEquals(lookupFailureMsg,expectedResult,searchResult);
    boolean locateBlockResult=(BlockIndexReader.locateNonRootIndexEntry(nonRootIndex,arrayHoldingKey,searchKey.length / 2,searchKey.length,KeyValue.RAW_COMPARATOR) != -1);
    if (i == 0) {
      assertFalse(locateBlockResult);
    }
 else {
      assertTrue(locateBlockResult);
      String errorMsg="i=" + i + ", position="+ nonRootIndex.position();
      assertEquals(errorMsg,getDummyFileOffset(referenceItem),nonRootIndex.getLong());
      assertEquals(errorMsg,getDummyOnDiskSize(referenceItem),nonRootIndex.getInt());
    }
  }
}
