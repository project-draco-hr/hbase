{
  this.lock.readLock().lock();
  try {
    if (this.storefiles.isEmpty()) {
      return null;
    }
    if (!force && (storeSize < this.desiredMaxFileSize)) {
      return null;
    }
    if (this.region.getRegionInfo().isMetaRegion()) {
      if (force) {
        LOG.warn("Cannot split meta regions in HBase 0.20");
      }
      return null;
    }
    boolean splitable=true;
    long maxSize=0L;
    Long mapIndex=Long.valueOf(0L);
    for (    Map.Entry<Long,StoreFile> e : storefiles.entrySet()) {
      StoreFile sf=e.getValue();
      if (splitable) {
        splitable=!sf.isReference();
        if (!splitable) {
          if (LOG.isDebugEnabled()) {
            LOG.debug(sf + " is not splittable");
          }
          return null;
        }
      }
      Reader r=sf.getReader();
      if (r == null) {
        LOG.warn("Storefile " + sf + " Reader is null");
        continue;
      }
      long size=r.length();
      if (size > maxSize) {
        maxSize=size;
        mapIndex=e.getKey();
      }
    }
    StoreFile sf=this.storefiles.get(mapIndex);
    HFile.Reader r=sf.getReader();
    if (r == null) {
      LOG.warn("Storefile " + sf + " Reader is null");
      return null;
    }
    byte[] midkey=r.midkey();
    if (midkey != null) {
      KeyValue mk=KeyValue.createKeyValueFromKey(midkey,0,midkey.length);
      byte[] fk=r.getFirstKey();
      KeyValue firstKey=KeyValue.createKeyValueFromKey(fk,0,fk.length);
      byte[] lk=r.getLastKey();
      KeyValue lastKey=KeyValue.createKeyValueFromKey(lk,0,lk.length);
      if (this.comparator.compareRows(mk,firstKey) == 0 && this.comparator.compareRows(mk,lastKey) == 0) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("cannot split because midkey is the same as first or " + "last row");
        }
        return null;
      }
      return new StoreSize(maxSize,mk.getRow());
    }
  }
 catch (  IOException e) {
    LOG.warn("Failed getting store size for " + this.storeNameStr,e);
  }
 finally {
    this.lock.readLock().unlock();
  }
  return null;
}
