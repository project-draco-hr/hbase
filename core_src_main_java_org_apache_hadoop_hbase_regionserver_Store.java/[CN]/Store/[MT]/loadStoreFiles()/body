{
  Map<Long,StoreFile> results=new HashMap<Long,StoreFile>();
  FileStatus files[]=this.fs.listStatus(this.homedir);
  for (int i=0; files != null && i < files.length; i++) {
    if (files[i].isDir()) {
      continue;
    }
    Path p=files[i].getPath();
    if (this.fs.getFileStatus(p).getLen() <= 0) {
      LOG.warn("Skipping " + p + " because its empty. HBASE-646 DATA LOSS?");
      continue;
    }
    StoreFile curfile=null;
    try {
      curfile=new StoreFile(fs,p,blockcache,this.conf,this.inMemory);
    }
 catch (    IOException ioe) {
      LOG.warn("Failed open of " + p + "; presumption is that file was "+ "corrupted at flush and lost edits picked up by commit log replay. "+ "Verify!",ioe);
      continue;
    }
    long storeSeqId=curfile.getMaxSequenceId();
    if (storeSeqId > this.maxSeqId) {
      this.maxSeqId=storeSeqId;
    }
    long length=curfile.getReader().length();
    this.storeSize+=length;
    if (LOG.isDebugEnabled()) {
      LOG.debug("loaded " + FSUtils.getPath(p) + ", isReference="+ curfile.isReference()+ ", sequence id="+ storeSeqId+ ", length="+ length+ ", majorCompaction="+ curfile.isMajorCompaction());
    }
    results.put(Long.valueOf(storeSeqId),curfile);
  }
  return results;
}
