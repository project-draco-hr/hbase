{
  if (reconstructionLog == null || !this.fs.exists(reconstructionLog)) {
    return -1;
  }
  FileStatus[] stats=this.fs.listStatus(reconstructionLog);
  if (stats == null || stats.length == 0) {
    LOG.warn("Passed reconstruction log " + reconstructionLog + " is zero-length");
    return -1;
  }
  long maxSeqIdInLog=-1;
  long firstSeqIdInLog=-1;
  HLog.Reader logReader=HLog.getReader(this.fs,reconstructionLog,conf);
  try {
    long skippedEdits=0;
    long editsCount=0;
    int reportInterval=this.conf.getInt("hbase.hstore.report.interval.edits",2000);
    HLog.Entry entry;
    while ((entry=logReader.next()) != null) {
      HLogKey key=entry.getKey();
      WALEdit val=entry.getEdit();
      if (firstSeqIdInLog == -1) {
        firstSeqIdInLog=key.getLogSeqNum();
      }
      maxSeqIdInLog=Math.max(maxSeqIdInLog,key.getLogSeqNum());
      if (key.getLogSeqNum() <= maxSeqID) {
        skippedEdits++;
        continue;
      }
      for (      KeyValue kv : val.getKeyValues()) {
        if (kv.matchingFamily(HLog.METAFAMILY) || !Bytes.equals(key.getRegionName(),region.regionInfo.getRegionName()) || !kv.matchingFamily(family.getName())) {
          continue;
        }
        if (kv.isDelete()) {
          this.memstore.delete(kv);
        }
 else {
          this.memstore.add(kv);
        }
        editsCount++;
      }
      if (reporter != null && (editsCount % reportInterval) == 0) {
        reporter.progress();
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Applied " + editsCount + ", skipped "+ skippedEdits+ "; store maxSeqID="+ maxSeqID+ ", firstSeqIdInLog="+ firstSeqIdInLog+ ", maxSeqIdInLog="+ maxSeqIdInLog);
    }
  }
  finally {
    logReader.close();
  }
  if (maxSeqIdInLog > -1) {
    this.snapshot();
    boolean needCompaction=this.flushCache(maxSeqIdInLog);
    if (needCompaction) {
      this.compact(false);
    }
  }
  return maxSeqIdInLog;
}
