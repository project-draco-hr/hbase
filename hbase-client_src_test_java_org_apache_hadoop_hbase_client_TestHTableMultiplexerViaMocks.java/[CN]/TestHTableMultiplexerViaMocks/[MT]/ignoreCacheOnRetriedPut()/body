{
  FlushWorker mockFlushWorker=mock(FlushWorker.class);
  ScheduledExecutorService mockExecutor=mock(ScheduledExecutorService.class);
  final AtomicInteger retryInQueue=new AtomicInteger(0);
  final AtomicLong totalFailedPuts=new AtomicLong(0L);
  final int maxRetryInQueue=20;
  final long delay=100L;
  final PutStatus ps=new PutStatus(mockRegionInfo,put,NUM_RETRIES);
  when(mockFlushWorker.resubmitFailedPut(any(PutStatus.class),any(HRegionLocation.class))).thenCallRealMethod();
  when(mockMultiplexer._put(tableName,put,NUM_RETRIES - 1,true)).thenReturn(true);
  when(mockFlushWorker.getExecutor()).thenReturn(mockExecutor);
  when(mockFlushWorker.getNextDelay(anyInt())).thenReturn(delay);
  when(mockFlushWorker.getMultiplexer()).thenReturn(mockMultiplexer);
  when(mockFlushWorker.getRetryInQueue()).thenReturn(retryInQueue);
  when(mockFlushWorker.getMaxRetryInQueue()).thenReturn(maxRetryInQueue);
  when(mockFlushWorker.getTotalFailedPutCount()).thenReturn(totalFailedPuts);
  when(mockExecutor.schedule(any(Runnable.class),eq(delay),eq(TimeUnit.MILLISECONDS))).thenAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      assertEquals(1L,retryInQueue.get());
      Object[] args=invocation.getArguments();
      assertEquals(3,args.length);
      assertTrue("Argument should be an instance of Runnable",args[0] instanceof Runnable);
      Runnable runnable=(Runnable)args[0];
      runnable.run();
      return null;
    }
  }
);
  assertTrue("Put should have been rescheduled",mockFlushWorker.resubmitFailedPut(ps,mockRegionLocation));
  verify(mockMultiplexer)._put(tableName,put,NUM_RETRIES - 1,true);
  assertEquals(0L,totalFailedPuts.get());
  assertEquals(0L,retryInQueue.get());
}
