{
  Configuration conf=HBaseConfiguration.create();
  final int MAX_DELAYED_RPC=10;
  conf.setInt("hbase.ipc.warn.delayedrpc.number",MAX_DELAYED_RPC);
  ListAppender listAppender=new ListAppender();
  Logger log=Logger.getLogger(RpcServer.class);
  log.addAppender(listAppender);
  log.setLevel(Level.WARN);
  InetSocketAddress isa=new InetSocketAddress("localhost",0);
  TestDelayedImplementation instance=new TestDelayedImplementation(true);
  BlockingService service=TestDelayedRpcProtos.TestDelayedService.newReflectiveBlockingService(instance);
  rpcServer=new RpcServer(null,"testTooManyDelayedRpcs",Lists.newArrayList(new RpcServer.BlockingServiceAndInterface(service,null)),isa,conf,new FifoRpcScheduler(conf,1));
  rpcServer.start();
  RpcClient rpcClient=RpcClientFactory.createClient(conf,HConstants.DEFAULT_CLUSTER_ID.toString());
  try {
    InetSocketAddress address=rpcServer.getListenerAddress();
    if (address == null) {
      throw new IOException("Listener channel is closed");
    }
    BlockingRpcChannel channel=rpcClient.createBlockingRpcChannel(ServerName.valueOf(address.getHostName(),address.getPort(),System.currentTimeMillis()),User.getCurrent(),RPC_CLIENT_TIMEOUT);
    TestDelayedRpcProtos.TestDelayedService.BlockingInterface stub=TestDelayedRpcProtos.TestDelayedService.newBlockingStub(channel);
    Thread threads[]=new Thread[MAX_DELAYED_RPC + 1];
    for (int i=0; i < MAX_DELAYED_RPC; i++) {
      threads[i]=new TestThread(stub,true,null);
      threads[i].start();
    }
    assertTrue(listAppender.getMessages().isEmpty());
    threads[MAX_DELAYED_RPC]=new TestThread(stub,true,null);
    threads[MAX_DELAYED_RPC].start();
    for (int i=0; i < MAX_DELAYED_RPC; i++) {
      threads[i].join();
    }
    assertFalse(listAppender.getMessages().isEmpty());
    assertTrue(listAppender.getMessages().get(0).startsWith("Too many delayed calls"));
    log.removeAppender(listAppender);
  }
  finally {
    rpcClient.close();
  }
}
