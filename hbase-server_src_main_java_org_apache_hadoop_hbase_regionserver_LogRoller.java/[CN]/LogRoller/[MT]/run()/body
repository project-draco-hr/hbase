{
  while (!server.isStopped()) {
    long now=System.currentTimeMillis();
    boolean periodic=false;
    if (!rollLog.get()) {
      periodic=(now - this.lastrolltime) > this.rollperiod;
      if (!periodic) {
synchronized (rollLog) {
          try {
            rollLog.wait(this.threadWakeFrequency);
          }
 catch (          InterruptedException e) {
          }
        }
        continue;
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("Hlog roll period " + this.rollperiod + "ms elapsed");
      }
    }
 else     if (LOG.isDebugEnabled()) {
      LOG.debug("HLog roll requested");
    }
    rollLock.lock();
    try {
      this.lastrolltime=now;
      byte[][] regionsToFlush=getWAL().rollWriter(rollLog.get());
      if (regionsToFlush != null) {
        for (        byte[] r : regionsToFlush)         scheduleFlush(r);
      }
    }
 catch (    FailedLogCloseException e) {
      server.abort("Failed log close in log roller",e);
    }
catch (    java.net.ConnectException e) {
      server.abort("Failed log close in log roller",e);
    }
catch (    IOException ex) {
      server.abort("IOE in log roller",RemoteExceptionHandler.checkIOException(ex));
    }
catch (    Exception ex) {
      LOG.error("Log rolling failed",ex);
      server.abort("Log rolling failed",ex);
    }
 finally {
      try {
        rollLog.set(false);
      }
  finally {
        rollLock.unlock();
      }
    }
  }
  LOG.info("LogRoller exiting.");
}
