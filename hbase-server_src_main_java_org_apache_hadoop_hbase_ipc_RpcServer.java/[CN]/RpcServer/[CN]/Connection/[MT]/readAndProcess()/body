{
  while (true) {
    int count;
    if (this.dataLengthBuffer.remaining() > 0) {
      count=channelRead(channel,this.dataLengthBuffer);
      if (count < 0 || this.dataLengthBuffer.remaining() > 0) {
        return count;
      }
    }
    if (!connectionPreambleRead) {
      this.dataLengthBuffer.flip();
      if (!HConstants.RPC_HEADER.equals(dataLengthBuffer)) {
        return doBadPreambleHandling("Expected HEADER=" + Bytes.toStringBinary(HConstants.RPC_HEADER.array()) + " but received HEADER="+ Bytes.toStringBinary(dataLengthBuffer.array())+ " from "+ toString());
      }
      ByteBuffer versionAndAuthBytes=ByteBuffer.allocate(2);
      count=channelRead(channel,versionAndAuthBytes);
      if (count < 0 || versionAndAuthBytes.remaining() > 0) {
        return count;
      }
      int version=versionAndAuthBytes.get(0);
      byte authbyte=versionAndAuthBytes.get(1);
      this.authMethod=AuthMethod.valueOf(authbyte);
      if (version != CURRENT_VERSION) {
        String msg=getFatalConnectionString(version,authbyte);
        return doBadPreambleHandling(msg,new WrongVersionException(msg));
      }
      if (authMethod == null) {
        String msg=getFatalConnectionString(version,authbyte);
        return doBadPreambleHandling(msg,new BadAuthException(msg));
      }
      if (isSecurityEnabled && authMethod == AuthMethod.SIMPLE) {
        AccessControlException ae=new AccessControlException("Authentication is required");
        setupResponse(authFailedResponse,authFailedCall,ae,ae.getMessage());
        responder.doRespond(authFailedCall);
        throw ae;
      }
      if (!isSecurityEnabled && authMethod != AuthMethod.SIMPLE) {
        doRawSaslReply(SaslStatus.SUCCESS,new IntWritable(SaslUtil.SWITCH_TO_SIMPLE_AUTH),null,null);
        authMethod=AuthMethod.SIMPLE;
        skipInitialSaslHandshake=true;
      }
      if (authMethod != AuthMethod.SIMPLE) {
        useSasl=true;
      }
      connectionPreambleRead=true;
      dataLengthBuffer.clear();
      continue;
    }
    if (data == null) {
      dataLengthBuffer.flip();
      int dataLength=dataLengthBuffer.getInt();
      if (dataLength == RpcClient.PING_CALL_ID) {
        if (!useWrap) {
          dataLengthBuffer.clear();
          return 0;
        }
      }
      if (dataLength < 0) {
        throw new IllegalArgumentException("Unexpected data length " + dataLength + "!! from "+ getHostAddress());
      }
      data=ByteBuffer.allocate(dataLength);
      incRpcCount();
    }
    count=channelRead(channel,data);
    if (count < 0) {
      return count;
    }
 else     if (data.remaining() == 0) {
      dataLengthBuffer.clear();
      data.flip();
      if (skipInitialSaslHandshake) {
        data=null;
        skipInitialSaslHandshake=false;
        continue;
      }
      boolean headerRead=connectionHeaderRead;
      if (useSasl) {
        saslReadAndProcess(data.array());
      }
 else {
        processOneRpc(data.array());
      }
      this.data=null;
      if (!headerRead) {
        continue;
      }
    }
 else {
      if (LOG.isTraceEnabled())       LOG.trace("Continue to read rest of data " + data.remaining());
      continue;
    }
    return count;
  }
}
