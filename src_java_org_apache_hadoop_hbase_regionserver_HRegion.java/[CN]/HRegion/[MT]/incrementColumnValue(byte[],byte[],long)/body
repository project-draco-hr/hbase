{
  checkRow(row);
  checkColumn(column);
  Integer lid=obtainRowLock(row);
  splitsAndClosesLock.readLock().lock();
  try {
    HStoreKey hsk=new HStoreKey(row,column);
    long ts=System.currentTimeMillis();
    byte[] value=null;
    long newval;
    Store store=getStore(column);
    List<Cell> c;
    store.lock.readLock().lock();
    try {
      c=store.memcache.get(hsk,1);
    }
  finally {
      store.lock.readLock().unlock();
    }
    if (c.size() == 1) {
      LOG.debug("Overwriting the memcache value for " + Bytes.toString(row) + "/"+ Bytes.toString(column));
      ts=c.get(0).getTimestamp();
      value=c.get(0).getValue();
    }
 else     if (c.size() > 1) {
      throw new DoNotRetryIOException("more than 1 value returned in incrementColumnValue from memcache");
    }
    if (value == null) {
      Cell[] cell=store.get(hsk,1);
      if (cell != null && cell.length == 1) {
        LOG.debug("Using HFile previous value for " + Bytes.toString(row) + "/"+ Bytes.toString(column));
        value=cell[0].getValue();
      }
 else       if (cell != null && c.size() > 1) {
        throw new DoNotRetryIOException("more than 1 value returned in incrementColumnValue from Store");
      }
    }
    if (value == null) {
      LOG.debug("Creating new counter value for " + Bytes.toString(row) + "/"+ Bytes.toString(column));
      newval=amount;
    }
 else {
      newval=incrementBytes(value,amount);
    }
    BatchUpdate b=new BatchUpdate(row,ts);
    b.put(column,Bytes.toBytes(newval));
    batchUpdate(b,lid,true);
    return newval;
  }
  finally {
    splitsAndClosesLock.readLock().unlock();
    releaseRowLock(lid);
  }
}
