{
  long now=System.currentTimeMillis();
  byte[] byteNow=Bytes.toBytes(now);
  boolean flush=false;
  this.updatesLock.readLock().lock();
  try {
    long size=0;
    Store store=getStore(family);
    Iterator<KeyValue> kvIterator=kvs.iterator();
    while (kvIterator.hasNext()) {
      KeyValue kv=kvIterator.next();
      if (kv.isLatestTimestamp() && kv.isDeleteType()) {
        List<KeyValue> result=new ArrayList<KeyValue>(1);
        Get g=new Get(kv.getRow());
        NavigableSet<byte[]> qualifiers=new TreeSet<byte[]>(Bytes.BYTES_COMPARATOR);
        byte[] q=kv.getQualifier();
        if (q == null)         q=HConstants.EMPTY_BYTE_ARRAY;
        qualifiers.add(q);
        get(store,g,qualifiers,result);
        if (result.isEmpty()) {
          kvIterator.remove();
          continue;
        }
        if (result.size() > 1) {
          throw new RuntimeException("Unexpected size: " + result.size());
        }
        KeyValue getkv=result.get(0);
        Bytes.putBytes(kv.getBuffer(),kv.getTimestampOffset(),getkv.getBuffer(),getkv.getTimestampOffset(),Bytes.SIZEOF_LONG);
      }
 else {
        kv.updateLatestStamp(byteNow);
      }
      size=this.memstoreSize.addAndGet(store.delete(kv));
    }
    if (writeToWAL) {
      this.log.append(regionInfo.getRegionName(),regionInfo.getTableDesc().getName(),kvs,(regionInfo.isMetaRegion() || regionInfo.isRootRegion()),now);
    }
    flush=isFlushSize(size);
  }
  finally {
    this.updatesLock.readLock().unlock();
  }
  if (flush) {
    requestFlush();
  }
}
