{
  boolean success=true;
  checkReadOnly();
  validateValuesLength(b);
  checkResources();
  splitsAndClosesLock.readLock().lock();
  try {
    byte[] row=b.getRow();
    long now=System.currentTimeMillis();
    Integer lid=getLock(lockid,row);
    try {
      NavigableSet<byte[]> keySet=new TreeSet<byte[]>(Bytes.BYTES_COMPARATOR);
      keySet.addAll(expectedValues.keySet());
      Map<byte[],Cell> actualValues=getFull(row,keySet,HConstants.LATEST_TIMESTAMP,1,lid);
      for (      byte[] key : keySet) {
        if (!Bytes.equals(actualValues.get(key).getValue(),expectedValues.get(key))) {
          success=false;
          break;
        }
      }
      if (success) {
        long commitTime=(b.getTimestamp() == LATEST_TIMESTAMP) ? now : b.getTimestamp();
        Set<byte[]> latestTimestampDeletes=null;
        List<KeyValue> edits=new ArrayList<KeyValue>();
        for (        BatchOperation op : b) {
          byte[] column=op.getColumn();
          KeyValue kv=null;
          if (op.isPut()) {
            kv=new KeyValue(row,column,commitTime,op.getValue());
          }
 else {
            if (b.getTimestamp() == LATEST_TIMESTAMP) {
              if (latestTimestampDeletes == null) {
                latestTimestampDeletes=new TreeSet<byte[]>(Bytes.BYTES_RAWCOMPARATOR);
              }
              latestTimestampDeletes.add(op.getColumn());
            }
 else {
              kv=new KeyValue(row,column,commitTime,KeyValue.Type.Delete,HConstants.EMPTY_BYTE_ARRAY);
            }
          }
          edits.add(kv);
        }
        if (!edits.isEmpty()) {
          update(edits,writeToWAL,now);
        }
        if (latestTimestampDeletes != null && !latestTimestampDeletes.isEmpty()) {
          for (          byte[] column : latestTimestampDeletes) {
            deleteMultiple(row,column,LATEST_TIMESTAMP,1,now);
          }
        }
      }
    }
  finally {
      if (lockid == null)       releaseRowLock(lid);
    }
  }
  finally {
    splitsAndClosesLock.readLock().unlock();
  }
  return success;
}
