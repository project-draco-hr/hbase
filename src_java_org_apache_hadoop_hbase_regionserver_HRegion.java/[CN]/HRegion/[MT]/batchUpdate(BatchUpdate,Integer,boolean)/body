{
  checkReadOnly();
  validateValuesLength(b);
  checkResources();
  splitsAndClosesLock.readLock().lock();
  try {
    byte[] row=b.getRow();
    Integer lid=getLock(lockid,row);
    long now=System.currentTimeMillis();
    long commitTime=b.getTimestamp() == LATEST_TIMESTAMP ? now : b.getTimestamp();
    Set<byte[]> latestTimestampDeletes=null;
    List<KeyValue> edits=new ArrayList<KeyValue>();
    try {
      for (      BatchOperation op : b) {
        byte[] column=op.getColumn();
        checkColumn(column);
        KeyValue kv=null;
        if (op.isPut()) {
          kv=new KeyValue(row,column,commitTime,op.getValue());
        }
 else {
          if (b.getTimestamp() == LATEST_TIMESTAMP) {
            if (latestTimestampDeletes == null) {
              latestTimestampDeletes=new TreeSet<byte[]>(Bytes.BYTES_RAWCOMPARATOR);
            }
            latestTimestampDeletes.add(op.getColumn());
            continue;
          }
          kv=new KeyValue(row,column,commitTime,KeyValue.Type.Delete,HConstants.EMPTY_BYTE_ARRAY);
        }
        edits.add(kv);
      }
      if (!edits.isEmpty()) {
        update(edits,writeToWAL);
      }
      if (latestTimestampDeletes != null && !latestTimestampDeletes.isEmpty()) {
        for (        byte[] column : latestTimestampDeletes) {
          deleteMultiple(row,column,LATEST_TIMESTAMP,1);
        }
      }
    }
  finally {
      if (lockid == null)       releaseRowLock(lid);
    }
  }
  finally {
    splitsAndClosesLock.readLock().unlock();
  }
}
