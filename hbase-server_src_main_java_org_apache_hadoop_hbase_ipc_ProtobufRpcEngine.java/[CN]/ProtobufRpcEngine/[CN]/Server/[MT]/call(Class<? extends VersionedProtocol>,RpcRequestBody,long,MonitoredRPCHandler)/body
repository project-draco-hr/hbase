{
  try {
    String methodName=rpcRequest.getMethodName();
    Method method=getMethod(protocol,methodName);
    if (method == null) {
      throw new HBaseRPC.UnknownProtocolException("Method " + methodName + " doesn't exist in protocol "+ protocol.getName());
    }
    long clientVersion=rpcRequest.getClientProtocolVersion();
    if (verbose) {
      LOG.info("Call: protocol name=" + protocol.getName() + ", method="+ methodName);
    }
    status.setRPC(rpcRequest.getMethodName(),new Object[]{rpcRequest.getRequest()},receiveTime);
    status.setRPCPacket(rpcRequest);
    status.resume("Servicing call");
    Message protoType=getMethodArgType(method);
    Message param=protoType.newBuilderForType().mergeFrom(rpcRequest.getRequest()).build();
    Message result;
    Object impl=null;
    if (protocol.isAssignableFrom(this.implementation)) {
      impl=this.instance;
    }
 else {
      throw new HBaseRPC.UnknownProtocolException(protocol);
    }
    long startTime=EnvironmentEdgeManager.currentTimeMillis();
    if (method.getParameterTypes().length == 2) {
      result=(Message)method.invoke(impl,null,param);
    }
 else     if (method.getParameterTypes().length == 1) {
      result=(Message)method.invoke(impl,param);
    }
 else {
      throw new ServiceException("Too many parameters for method: [" + method.getName() + "]"+ ", allowed (at most): 2, Actual: "+ method.getParameterTypes().length);
    }
    int processingTime=(int)(EnvironmentEdgeManager.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receiveTime);
    if (TRACELOG.isDebugEnabled()) {
      TRACELOG.debug("Call #" + CurCall.get().id + "; Served: "+ protocol.getSimpleName()+ "#"+ method.getName()+ " queueTime="+ qTime+ " processingTime="+ processingTime+ " contents="+ Objects.describeQuantity(param));
    }
    rpcMetrics.rpcQueueTime.inc(qTime);
    rpcMetrics.rpcProcessingTime.inc(processingTime);
    rpcMetrics.inc(method.getName(),processingTime);
    if (verbose) {
      log("Return: " + result,LOG);
    }
    long responseSize=result.getSerializedSize();
    boolean tooSlow=(processingTime > warnResponseTime && warnResponseTime > -1);
    boolean tooLarge=(responseSize > warnResponseSize && warnResponseSize > -1);
    if (tooSlow || tooLarge) {
      StringBuilder buffer=new StringBuilder(256);
      buffer.append(methodName);
      buffer.append("(");
      buffer.append(param.getClass().getName());
      buffer.append(")");
      buffer.append(", client version=" + clientVersion);
      logResponse(new Object[]{rpcRequest.getRequest()},methodName,buffer.toString(),(tooLarge ? "TooLarge" : "TooSlow"),status.getClient(),startTime,processingTime,qTime,responseSize);
      if (tooSlow) {
        rpcMetrics.rpcSlowResponseTime.inc(processingTime);
      }
    }
    if (processingTime > 1000) {
      rpcMetrics.inc(method.getName() + ABOVE_ONE_SEC_METRIC,processingTime);
    }
    return result;
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
    if (target instanceof ServiceException) {
      throw ProtobufUtil.getRemoteException((ServiceException)target);
    }
    IOException ioe=new IOException(target.toString());
    ioe.setStackTrace(target.getStackTrace());
    throw ioe;
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}
