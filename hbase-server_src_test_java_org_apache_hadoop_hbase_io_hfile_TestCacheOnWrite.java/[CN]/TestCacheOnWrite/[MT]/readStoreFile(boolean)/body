{
  AbstractHFileReader reader;
  if (useTags) {
    reader=(HFileReaderV3)HFile.createReader(fs,storeFilePath,cacheConf,conf);
  }
 else {
    reader=(HFileReaderV2)HFile.createReader(fs,storeFilePath,cacheConf,conf);
  }
  LOG.info("HFile information: " + reader);
  HFileContext meta=new HFileContextBuilder().withCompression(compress).withBytesPerCheckSum(CKBYTES).withChecksumType(ChecksumType.NULL).withBlockSize(DATA_BLOCK_SIZE).withDataBlockEncoding(encoder.getDataBlockEncoding()).withIncludesTags(useTags).build();
  final boolean cacheBlocks=false;
  final boolean pread=false;
  HFileScanner scanner=reader.getScanner(cacheBlocks,pread);
  assertTrue(testDescription,scanner.seekTo());
  long offset=0;
  HFileBlock prevBlock=null;
  EnumMap<BlockType,Integer> blockCountByType=new EnumMap<BlockType,Integer>(BlockType.class);
  DataBlockEncoding encodingInCache=encoderType.getEncoder().getDataBlockEncoding();
  while (offset < reader.getTrailer().getLoadOnOpenDataOffset()) {
    long onDiskSize=-1;
    if (prevBlock != null) {
      onDiskSize=prevBlock.getNextBlockOnDiskSizeWithHeader();
    }
    HFileBlock block=reader.readBlock(offset,onDiskSize,false,true,false,true,null,encodingInCache);
    BlockCacheKey blockCacheKey=new BlockCacheKey(reader.getName(),offset);
    HFileBlock fromCache=(HFileBlock)blockCache.getBlock(blockCacheKey,true,false,true);
    boolean isCached=fromCache != null;
    boolean shouldBeCached=cowType.shouldBeCached(block.getBlockType());
    assertTrue("shouldBeCached: " + shouldBeCached + "\n"+ "isCached: "+ isCached+ "\n"+ "Test description: "+ testDescription+ "\n"+ "block: "+ block+ "\n"+ "encodingInCache: "+ encodingInCache+ "\n"+ "blockCacheKey: "+ blockCacheKey,shouldBeCached == isCached);
    if (isCached) {
      if (cacheConf.shouldCacheCompressed(fromCache.getBlockType().getCategory())) {
        if (compress != Compression.Algorithm.NONE) {
          assertFalse(fromCache.isUnpacked());
        }
        fromCache=fromCache.unpack(meta,reader.getUncachedBlockReader());
      }
 else {
        assertTrue(fromCache.isUnpacked());
      }
      assertEquals(block.getChecksumType(),fromCache.getChecksumType());
      assertEquals(block.getBlockType(),fromCache.getBlockType());
      if (block.getBlockType() == BlockType.ENCODED_DATA) {
        assertEquals(block.getDataBlockEncodingId(),fromCache.getDataBlockEncodingId());
        assertEquals(block.getDataBlockEncoding(),fromCache.getDataBlockEncoding());
      }
      assertEquals(block.getOnDiskSizeWithHeader(),fromCache.getOnDiskSizeWithHeader());
      assertEquals(block.getOnDiskSizeWithoutHeader(),fromCache.getOnDiskSizeWithoutHeader());
      assertEquals(block.getUncompressedSizeWithoutHeader(),fromCache.getUncompressedSizeWithoutHeader());
    }
    prevBlock=block;
    offset+=block.getOnDiskSizeWithHeader();
    BlockType bt=block.getBlockType();
    Integer count=blockCountByType.get(bt);
    blockCountByType.put(bt,(count == null ? 0 : count) + 1);
  }
  LOG.info("Block count by type: " + blockCountByType);
  String countByType=blockCountByType.toString();
  BlockType cachedDataBlockType=encoderType.encode ? BlockType.ENCODED_DATA : BlockType.DATA;
  if (useTags) {
    assertEquals("{" + cachedDataBlockType + "=1550, LEAF_INDEX=173, BLOOM_CHUNK=9, INTERMEDIATE_INDEX=20}",countByType);
  }
 else {
    assertEquals("{" + cachedDataBlockType + "=1379, LEAF_INDEX=154, BLOOM_CHUNK=9, INTERMEDIATE_INDEX=18}",countByType);
  }
  while (scanner.next()) {
    Cell cell=scanner.getKeyValue();
  }
  reader.close();
}
