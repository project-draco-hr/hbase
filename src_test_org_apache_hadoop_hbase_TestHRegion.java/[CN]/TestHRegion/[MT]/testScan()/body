{
  if (!initialized) {
    throw new IllegalStateException();
  }
  Text cols[]=new Text[]{CONTENTS_FIRSTCOL,ANCHOR_SECONDCOL};
  String[] vals1=new String[1000];
  for (int k=0; k < vals1.length; k++) {
    vals1[k]=Integer.toString(k);
  }
  long startTime=System.currentTimeMillis();
  for (int k=0; k < vals1.length / 2; k++) {
    String kLabel=String.format("%1$03d",k);
    long lockid=region.startUpdate(new Text("row_vals1_" + kLabel));
    region.put(lockid,cols[0],vals1[k].getBytes());
    region.put(lockid,cols[1],vals1[k].getBytes());
    region.commit(lockid);
    numInserted+=2;
  }
  System.out.println("Write " + (vals1.length / 2) + " elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  HScannerInterface s=region.getScanner(cols,new Text());
  int numFetched=0;
  try {
    HStoreKey curKey=new HStoreKey();
    TreeMap<Text,byte[]> curVals=new TreeMap<Text,byte[]>();
    int k=0;
    while (s.next(curKey,curVals)) {
      for (Iterator<Text> it=curVals.keySet().iterator(); it.hasNext(); ) {
        Text col=it.next();
        byte val[]=curVals.get(col);
        int curval=Integer.parseInt(new String(val).trim());
        for (int j=0; j < cols.length; j++) {
          if (col.compareTo(cols[j]) == 0) {
            assertEquals("Error at:" + curKey.getRow() + "/"+ curKey.getTimestamp()+ ", Value for "+ col+ " should be: "+ k+ ", but was fetched as: "+ curval,k,curval);
            numFetched++;
          }
        }
      }
      curVals.clear();
      k++;
    }
  }
  finally {
    s.close();
  }
  assertEquals("Inserted " + numInserted + " values, but fetched "+ numFetched,numInserted,numFetched);
  System.out.println("Scanned " + (vals1.length / 2) + " rows from cache. Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  region.flushcache(false);
  System.out.println("Cache flush elapsed time: " + ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  s=region.getScanner(cols,new Text());
  numFetched=0;
  try {
    HStoreKey curKey=new HStoreKey();
    TreeMap<Text,byte[]> curVals=new TreeMap<Text,byte[]>();
    int k=0;
    while (s.next(curKey,curVals)) {
      for (Iterator<Text> it=curVals.keySet().iterator(); it.hasNext(); ) {
        Text col=it.next();
        byte val[]=curVals.get(col);
        int curval=Integer.parseInt(new String(val).trim());
        for (int j=0; j < cols.length; j++) {
          if (col.compareTo(cols[j]) == 0) {
            assertEquals("Error at:" + curKey.getRow() + "/"+ curKey.getTimestamp()+ ", Value for "+ col+ " should be: "+ k+ ", but was fetched as: "+ curval,k,curval);
            numFetched++;
          }
        }
      }
      curVals.clear();
      k++;
    }
  }
  finally {
    s.close();
  }
  assertEquals("Inserted " + numInserted + " values, but fetched "+ numFetched,numInserted,numFetched);
  System.out.println("Scanned " + (vals1.length / 2) + " rows from disk. Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  for (int k=vals1.length / 2; k < vals1.length; k++) {
    String kLabel=String.format("%1$03d",k);
    long lockid=region.startUpdate(new Text("row_vals1_" + kLabel));
    region.put(lockid,cols[0],vals1[k].getBytes());
    region.put(lockid,cols[1],vals1[k].getBytes());
    region.commit(lockid);
    numInserted+=2;
  }
  System.out.println("Write " + (vals1.length / 2) + " rows. Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  s=region.getScanner(cols,new Text());
  numFetched=0;
  try {
    HStoreKey curKey=new HStoreKey();
    TreeMap<Text,byte[]> curVals=new TreeMap<Text,byte[]>();
    int k=0;
    while (s.next(curKey,curVals)) {
      for (Iterator<Text> it=curVals.keySet().iterator(); it.hasNext(); ) {
        Text col=it.next();
        byte val[]=curVals.get(col);
        int curval=Integer.parseInt(new String(val).trim());
        for (int j=0; j < cols.length; j++) {
          if (col.compareTo(cols[j]) == 0) {
            assertEquals("Error at:" + curKey.getRow() + "/"+ curKey.getTimestamp()+ ", Value for "+ col+ " should be: "+ k+ ", but was fetched as: "+ curval,k,curval);
            numFetched++;
          }
        }
      }
      curVals.clear();
      k++;
    }
  }
  finally {
    s.close();
  }
  assertEquals("Inserted " + numInserted + " values, but fetched "+ numFetched,numInserted,numFetched);
  System.out.println("Scanned " + vals1.length + " rows from cache and disk. Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  region.flushcache(false);
  System.out.println("Cache flush elapsed time: " + ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  s=region.getScanner(cols,new Text());
  numFetched=0;
  try {
    HStoreKey curKey=new HStoreKey();
    TreeMap<Text,byte[]> curVals=new TreeMap<Text,byte[]>();
    int k=0;
    while (s.next(curKey,curVals)) {
      for (Iterator<Text> it=curVals.keySet().iterator(); it.hasNext(); ) {
        Text col=it.next();
        byte val[]=curVals.get(col);
        int curval=Integer.parseInt(new String(val).trim());
        for (int j=0; j < cols.length; j++) {
          if (col.compareTo(cols[j]) == 0) {
            assertEquals("Value for " + col + " should be: "+ k+ ", but was fetched as: "+ curval,curval,k);
            numFetched++;
          }
        }
      }
      curVals.clear();
      k++;
    }
  }
  finally {
    s.close();
  }
  assertEquals("Inserted " + numInserted + " values, but fetched "+ numFetched,numInserted,numFetched);
  System.out.println("Scanned " + vals1.length + " rows from disk. Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
  startTime=System.currentTimeMillis();
  s=region.getScanner(cols,new Text("row_vals1_500"));
  numFetched=0;
  try {
    HStoreKey curKey=new HStoreKey();
    TreeMap<Text,byte[]> curVals=new TreeMap<Text,byte[]>();
    int k=500;
    while (s.next(curKey,curVals)) {
      for (Iterator<Text> it=curVals.keySet().iterator(); it.hasNext(); ) {
        Text col=it.next();
        byte val[]=curVals.get(col);
        int curval=Integer.parseInt(new String(val).trim());
        for (int j=0; j < cols.length; j++) {
          if (col.compareTo(cols[j]) == 0) {
            assertEquals("Value for " + col + " should be: "+ k+ ", but was fetched as: "+ curval,curval,k);
            numFetched++;
          }
        }
      }
      curVals.clear();
      k++;
    }
  }
  finally {
    s.close();
  }
  assertEquals("Should have fetched " + (numInserted / 2) + " values, but fetched "+ numFetched,(numInserted / 2),numFetched);
  System.out.println("Scanned " + (numFetched / 2) + " rows from disk with specified start point. Elapsed time: "+ ((System.currentTimeMillis() - startTime) / 1000.0));
}
