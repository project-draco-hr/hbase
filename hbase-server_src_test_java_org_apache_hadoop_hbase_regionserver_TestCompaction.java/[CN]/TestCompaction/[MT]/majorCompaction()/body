{
  createStoreFile(r);
  for (int i=0; i < compactionThreshold; i++) {
    createStoreFile(r);
  }
  addContent(new HRegionIncommon(r),Bytes.toString(COLUMN_FAMILY));
  Result result=r.get(new Get(STARTROW).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  assertEquals(compactionThreshold,result.size());
  for (  Store store : this.r.stores.values()) {
    assertNull(store.getCompactionProgress());
  }
  r.flushcache();
  r.compactStores(true);
  int storeCount=0;
  for (  Store store : this.r.stores.values()) {
    CompactionProgress progress=store.getCompactionProgress();
    if (progress != null) {
      ++storeCount;
      assertTrue(progress.currentCompactedKVs > 0);
      assertTrue(progress.totalCompactingKVs > 0);
    }
    assertTrue(storeCount > 0);
  }
  byte[] secondRowBytes=START_KEY_BYTES.clone();
  secondRowBytes[START_KEY_BYTES.length - 1]++;
  result=r.get(new Get(secondRowBytes).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  LOG.debug("Row " + Bytes.toStringBinary(secondRowBytes) + " after "+ "initial compaction: "+ result);
  assertEquals("Invalid number of versions of row " + Bytes.toStringBinary(secondRowBytes) + ".",compactionThreshold,result.size());
  LOG.debug("Adding deletes to memstore and flushing");
  Delete delete=new Delete(secondRowBytes,System.currentTimeMillis(),null);
  byte[][] famAndQf={COLUMN_FAMILY,null};
  delete.deleteFamily(famAndQf[0]);
  r.delete(delete,null,true);
  result=r.get(new Get(secondRowBytes).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  assertTrue("Second row should have been deleted",result.isEmpty());
  r.flushcache();
  result=r.get(new Get(secondRowBytes).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  assertTrue("Second row should have been deleted",result.isEmpty());
  createSmallerStoreFile(this.r);
  r.flushcache();
  result=r.get(new Get(secondRowBytes).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  assertTrue("Second row should still be deleted",result.isEmpty());
  r.compactStores(true);
  assertEquals(r.getStore(COLUMN_FAMILY_TEXT).getStorefiles().size(),1);
  result=r.get(new Get(secondRowBytes).addFamily(COLUMN_FAMILY_TEXT).setMaxVersions(100),null);
  assertTrue("Second row should still be deleted",result.isEmpty());
  verifyCounts(3,0);
  final int ttl=1000;
  for (  Store hstore : this.r.stores.values()) {
    HStore store=((HStore)hstore);
    HStore.ScanInfo old=store.scanInfo;
    HStore.ScanInfo si=new HStore.ScanInfo(old.getFamily(),old.getMinVersions(),old.getMaxVersions(),ttl,old.getKeepDeletedCells(),0,old.getComparator());
    store.scanInfo=si;
  }
  Thread.sleep(1000);
  r.compactStores(true);
  int count=count();
  assertEquals("Should not see anything after TTL has expired",0,count);
}
