{
  final AsyncCall call=new AsyncCall(channel.eventLoop(),client.callIdCnt.getAndIncrement(),method,request,controller,responsePrototype);
  controller.notifyOnCancel(new RpcCallback<Object>(){
    @Override public void run(    Object parameter){
synchronized (pendingCalls) {
        pendingCalls.remove(call.id);
      }
    }
  }
);
  if (controller.isCanceled()) {
    call.cancel(true);
    return call;
  }
synchronized (pendingCalls) {
    if (closed) {
      Promise<Message> promise=channel.eventLoop().newPromise();
      promise.setFailure(new ConnectException());
      return promise;
    }
    pendingCalls.put(call.id,call);
    if (cleanupTimer == null && call.getRpcTimeout() > 0) {
      cleanupTimer=AsyncRpcClient.WHEEL_TIMER.newTimeout(timeoutTask,call.getRpcTimeout(),TimeUnit.MILLISECONDS);
    }
    if (!connected) {
      return call;
    }
  }
  writeRequest(call);
  return call;
}
