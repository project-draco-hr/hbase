{
  if (this.reader != null) {
    throw new IllegalAccessError("Already open");
  }
  if (isReference()) {
    this.reader=new HalfStoreFileReader(this.fs,this.referencePath,getBlockCache(),this.reference);
  }
 else {
    this.reader=new Reader(this.fs,this.path,getBlockCache(),this.inMemory);
  }
  metadataMap=Collections.unmodifiableMap(this.reader.loadFileInfo());
  byte[] b=metadataMap.get(MAX_SEQ_ID_KEY);
  if (b != null) {
    this.sequenceid=Bytes.toLong(b);
    if (isReference()) {
      if (Reference.isTopFileRegion(this.reference.getFileRegion())) {
        this.sequenceid+=1;
      }
    }
  }
  b=metadataMap.get(MAJOR_COMPACTION_KEY);
  if (b != null) {
    boolean mc=Bytes.toBoolean(b);
    if (this.majorCompaction == null) {
      this.majorCompaction=new AtomicBoolean(mc);
    }
 else {
      this.majorCompaction.set(mc);
    }
  }
  if (this.bloomType != BloomType.NONE) {
    this.reader.loadBloomfilter();
  }
  try {
    byte[] timerangeBytes=metadataMap.get(TIMERANGE_KEY);
    if (timerangeBytes != null) {
      this.reader.timeRangeTracker=new TimeRangeTracker();
      Writables.copyWritable(timerangeBytes,this.reader.timeRangeTracker);
    }
  }
 catch (  IllegalArgumentException e) {
    LOG.error("Error reading timestamp range data from meta -- " + "proceeding without",e);
    this.reader.timeRangeTracker=null;
  }
  return this.reader;
}
