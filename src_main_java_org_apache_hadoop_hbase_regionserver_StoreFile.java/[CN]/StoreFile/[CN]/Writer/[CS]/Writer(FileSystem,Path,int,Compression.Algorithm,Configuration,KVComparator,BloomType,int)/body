{
  writer=new HFile.Writer(fs,path,blocksize,compress,comparator.getRawComparator());
  this.kvComparator=comparator;
  BloomFilter bloom=null;
  BloomType bt=BloomType.NONE;
  if (bloomType != BloomType.NONE && conf != null) {
    float err=conf.getFloat(IO_STOREFILE_BLOOM_ERROR_RATE,(float)0.01);
    if (bloomType == BloomType.ROWCOL) {
      err/=2;
    }
    int maxFold=conf.getInt(IO_STOREFILE_BLOOM_MAX_FOLD,7);
    int tooBig=conf.getInt(IO_STOREFILE_BLOOM_MAX_KEYS,128 * 1000 * 1000);
    if (maxKeys < tooBig) {
      try {
        bloom=new ByteBloomFilter(maxKeys,err,Hash.getHashType(conf),maxFold);
        bloom.allocBloom();
        bt=bloomType;
      }
 catch (      IllegalArgumentException iae) {
        LOG.warn(String.format("Parse error while creating bloom for %s (%d, %f)",path,maxKeys,err),iae);
        bloom=null;
        bt=BloomType.NONE;
      }
    }
 else {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Skipping bloom filter because max keysize too large: " + maxKeys);
      }
    }
  }
  this.bloomFilter=bloom;
  this.bloomType=bt;
}
