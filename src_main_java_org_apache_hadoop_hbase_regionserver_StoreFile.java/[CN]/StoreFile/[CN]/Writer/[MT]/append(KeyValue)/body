{
  if (this.bloomFilterWriter != null) {
    boolean newKey=true;
    if (this.lastKv != null) {
switch (bloomType) {
case ROW:
        newKey=!kvComparator.matchingRows(kv,lastKv);
      break;
case ROWCOL:
    newKey=!kvComparator.matchingRowColumn(kv,lastKv);
  break;
case NONE:
newKey=false;
break;
default :
throw new IOException("Invalid Bloom filter type: " + bloomType);
}
}
if (newKey) {
byte[] bloomKey;
int bloomKeyOffset, bloomKeyLen;
switch (bloomType) {
case ROW:
bloomKey=kv.getBuffer();
bloomKeyOffset=kv.getRowOffset();
bloomKeyLen=kv.getRowLength();
break;
case ROWCOL:
bloomKey=bloomFilterWriter.createBloomKey(kv.getBuffer(),kv.getRowOffset(),kv.getRowLength(),kv.getBuffer(),kv.getQualifierOffset(),kv.getQualifierLength());
bloomKeyOffset=0;
bloomKeyLen=bloomKey.length;
break;
default :
throw new IOException("Invalid Bloom filter type: " + bloomType + " (ROW or ROWCOL expected)");
}
bloomFilterWriter.add(bloomKey,bloomKeyOffset,bloomKeyLen);
if (lastBloomKey != null && bloomFilterWriter.getComparator().compare(bloomKey,bloomKeyOffset,bloomKeyLen,lastBloomKey,lastBloomKeyOffset,lastBloomKeyLen) <= 0) {
throw new IOException("Non-increasing Bloom keys: " + Bytes.toStringBinary(bloomKey,bloomKeyOffset,bloomKeyLen) + " after "+ Bytes.toStringBinary(lastBloomKey,lastBloomKeyOffset,lastBloomKeyLen));
}
lastBloomKey=bloomKey;
lastBloomKeyOffset=bloomKeyOffset;
lastBloomKeyLen=bloomKeyLen;
this.lastKv=kv;
}
}
writer.append(kv);
includeInTimeRangeTracker(kv);
}
