{
  super(timestamp,targetCols);
  locking.obtainReadLock();
  try {
    this.backingMaps=new TreeMap[history.size() + 1];
    int i=0;
    for (Iterator<TreeMap<HStoreKey,BytesWritable>> it=history.iterator(); it.hasNext(); ) {
      backingMaps[i++]=it.next();
    }
    backingMaps[backingMaps.length - 1]=memcache;
    this.keyIterators=new Iterator[backingMaps.length];
    this.keys=new HStoreKey[backingMaps.length];
    this.vals=new BytesWritable[backingMaps.length];
    HStoreKey firstKey=new HStoreKey(firstRow);
    for (i=0; i < backingMaps.length; i++) {
      if (firstRow.getLength() != 0) {
        keyIterators[i]=backingMaps[i].tailMap(firstKey).keySet().iterator();
      }
 else {
        keyIterators[i]=backingMaps[i].keySet().iterator();
      }
      while (getNext(i)) {
        if (!findFirstRow(i,firstRow)) {
          continue;
        }
        if (columnMatch(i)) {
          break;
        }
      }
    }
  }
 catch (  Exception ex) {
    close();
  }
}
