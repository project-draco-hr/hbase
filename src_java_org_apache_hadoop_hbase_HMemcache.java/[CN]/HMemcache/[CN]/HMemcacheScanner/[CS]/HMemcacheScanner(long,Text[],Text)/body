{
  super(timestamp,targetCols);
  lock.obtainReadLock();
  try {
synchronized (history) {
      this.backingMaps=new SortedMap[history.size() + 1];
      backingMaps[0]=memcache;
      for (int i=history.size() - 1; i >= 0; i--) {
        backingMaps[i + 1]=history.get(i);
      }
    }
    this.keyIterators=new Iterator[backingMaps.length];
    this.keys=new HStoreKey[backingMaps.length];
    this.vals=new byte[backingMaps.length][];
    HStoreKey firstKey=new HStoreKey(firstRow);
    for (int i=0; i < backingMaps.length; i++) {
      if (firstRow != null && firstRow.getLength() != 0) {
        keyIterators[i]=backingMaps[i].tailMap(firstKey).keySet().iterator();
      }
 else {
        keyIterators[i]=backingMaps[i].keySet().iterator();
      }
      while (getNext(i)) {
        if (!findFirstRow(i,firstRow)) {
          continue;
        }
        if (columnMatch(i)) {
          break;
        }
      }
    }
  }
 catch (  RuntimeException ex) {
    LOG.error("error initializing HMemcache scanner: ",ex);
    close();
    IOException e=new IOException("error initializing HMemcache scanner");
    e.initCause(ex);
    throw e;
  }
catch (  IOException ex) {
    LOG.error("error initializing HMemcache scanner: ",ex);
    close();
    throw ex;
  }
}
