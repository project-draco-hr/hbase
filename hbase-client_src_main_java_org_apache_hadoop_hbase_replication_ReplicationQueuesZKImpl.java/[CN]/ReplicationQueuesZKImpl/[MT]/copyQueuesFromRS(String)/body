{
  SortedMap<String,SortedSet<String>> queues=new TreeMap<String,SortedSet<String>>();
  try {
    String nodePath=ZKUtil.joinZNode(this.queuesZNode,znode);
    List<String> clusters=ZKUtil.listChildrenNoWatch(this.zookeeper,nodePath);
    if (clusters == null || clusters.size() <= 1) {
      return queues;
    }
    clusters.remove(RS_LOCK_ZNODE);
    for (    String cluster : clusters) {
      ReplicationQueueInfo replicationQueueInfo=new ReplicationQueueInfo(cluster);
      if (!peerExists(replicationQueueInfo.getPeerId())) {
        LOG.warn("Peer " + cluster + " didn't exist, skipping the replay");
        continue;
      }
      String newCluster=cluster + "-" + znode;
      String newClusterZnode=ZKUtil.joinZNode(this.myQueuesZnode,newCluster);
      String clusterPath=ZKUtil.joinZNode(nodePath,cluster);
      List<String> wals=ZKUtil.listChildrenNoWatch(this.zookeeper,clusterPath);
      if (wals == null || wals.size() == 0) {
        continue;
      }
      ZKUtil.createNodeIfNotExistsAndWatch(this.zookeeper,newClusterZnode,HConstants.EMPTY_BYTE_ARRAY);
      SortedSet<String> logQueue=new TreeSet<String>();
      queues.put(newCluster,logQueue);
      for (      String wal : wals) {
        String z=ZKUtil.joinZNode(clusterPath,wal);
        byte[] positionBytes=ZKUtil.getData(this.zookeeper,z);
        long position=0;
        try {
          position=ZKUtil.parseWALPositionFrom(positionBytes);
        }
 catch (        DeserializationException e) {
          LOG.warn("Failed parse of wal position from the following znode: " + z + ", Exception: "+ e);
        }
        LOG.debug("Creating " + wal + " with data "+ position);
        String child=ZKUtil.joinZNode(newClusterZnode,wal);
        ZKUtil.createAndWatch(this.zookeeper,child,positionBytes);
        logQueue.add(wal);
      }
    }
  }
 catch (  KeeperException e) {
    this.abortable.abort("Copy queues from rs",e);
  }
catch (  InterruptedException e) {
    LOG.warn(e);
    Thread.currentThread().interrupt();
  }
  return queues;
}
