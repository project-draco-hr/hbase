{
  final HFileScanner s=super.getScanner(cacheBlocks,pread,isCompaction);
  return new HFileScanner(){
    final HFileScanner delegate=s;
    public boolean atEnd=false;
    public ByteBuffer getKey(){
      if (atEnd)       return null;
      return delegate.getKey();
    }
    public String getKeyString(){
      if (atEnd)       return null;
      return delegate.getKeyString();
    }
    public ByteBuffer getValue(){
      if (atEnd)       return null;
      return delegate.getValue();
    }
    public String getValueString(){
      if (atEnd)       return null;
      return delegate.getValueString();
    }
    public Cell getKeyValue(){
      if (atEnd)       return null;
      return delegate.getKeyValue();
    }
    public boolean next() throws IOException {
      if (atEnd)       return false;
      boolean b=delegate.next();
      if (!b) {
        return b;
      }
      if (!top) {
        ByteBuffer bb=getKey();
        if (getComparator().compareFlatKey(bb.array(),bb.arrayOffset(),bb.limit(),splitkey,0,splitkey.length) >= 0) {
          atEnd=true;
          return false;
        }
      }
      return true;
    }
    @Override public boolean seekBefore(    byte[] key) throws IOException {
      return seekBefore(key,0,key.length);
    }
    @Override public boolean seekBefore(    byte[] key,    int offset,    int length) throws IOException {
      return seekBefore(new KeyValue.KeyOnlyKeyValue(key,offset,length));
    }
    @Override public boolean seekTo() throws IOException {
      if (top) {
        int r=this.delegate.seekTo(new KeyValue.KeyOnlyKeyValue(splitkey,0,splitkey.length));
        if (r == HConstants.INDEX_KEY_MAGIC) {
          return true;
        }
        if (r < 0) {
          return this.delegate.seekTo();
        }
        if (r > 0) {
          return this.delegate.next();
        }
        return true;
      }
      boolean b=delegate.seekTo();
      if (!b) {
        return b;
      }
      ByteBuffer k=this.delegate.getKey();
      return this.delegate.getReader().getComparator().compareFlatKey(k.array(),k.arrayOffset(),k.limit(),splitkey,0,splitkey.length) < 0;
    }
    @Override public int seekTo(    byte[] key) throws IOException {
      return seekTo(key,0,key.length);
    }
    @Override public int seekTo(    byte[] key,    int offset,    int length) throws IOException {
      return seekTo(new KeyValue.KeyOnlyKeyValue(key,offset,length));
    }
    @Override public int reseekTo(    byte[] key) throws IOException {
      return reseekTo(key,0,key.length);
    }
    @Override public int reseekTo(    byte[] key,    int offset,    int length) throws IOException {
      return reseekTo(new KeyValue.KeyOnlyKeyValue(key,offset,length));
    }
    public org.apache.hadoop.hbase.io.hfile.HFile.Reader getReader(){
      return this.delegate.getReader();
    }
    public boolean isSeeked(){
      return this.delegate.isSeeked();
    }
    @Override public int seekTo(    Cell key) throws IOException {
      if (top) {
        if (getComparator().compareOnlyKeyPortion(key,splitCell) < 0) {
          return -1;
        }
      }
 else {
        if (getComparator().compareOnlyKeyPortion(key,splitCell) >= 0) {
          boolean res=delegate.seekBefore(splitCell);
          if (!res) {
            throw new IOException("Seeking for a key in bottom of file, but key exists in top of file, " + "failed on seekBefore(midkey)");
          }
          return 1;
        }
      }
      return delegate.seekTo(key);
    }
    @Override public int reseekTo(    Cell key) throws IOException {
      if (top) {
        if (getComparator().compareOnlyKeyPortion(key,splitCell) < 0) {
          return -1;
        }
      }
 else {
        if (getComparator().compareOnlyKeyPortion(key,splitCell) >= 0) {
          boolean res=delegate.seekBefore(splitCell);
          if (!res) {
            throw new IOException("Seeking for a key in bottom of file, but" + " key exists in top of file, failed on seekBefore(midkey)");
          }
          return 1;
        }
      }
      if (atEnd) {
        return 1;
      }
      return delegate.reseekTo(key);
    }
    @Override public boolean seekBefore(    Cell key) throws IOException {
      if (top) {
        Cell fk=new KeyValue.KeyOnlyKeyValue(getFirstKey(),0,getFirstKey().length);
        if (getComparator().compareOnlyKeyPortion(key,fk) <= 0) {
          return false;
        }
      }
 else {
        if (getComparator().compareOnlyKeyPortion(key,splitCell) >= 0) {
          boolean ret=this.delegate.seekBefore(splitCell);
          if (ret) {
            atEnd=false;
          }
          return ret;
        }
      }
      boolean ret=this.delegate.seekBefore(key);
      if (ret) {
        atEnd=false;
      }
      return ret;
    }
    @Override public Cell getNextIndexedKey(){
      return null;
    }
  }
;
}
