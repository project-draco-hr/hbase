{
  boolean tableExists=true;
  executeCallable(new MasterCallable<Void>(getConnection()){
    @Override public Void call(    int callTimeout) throws ServiceException {
      DeleteTableRequest req=RequestConverter.buildDeleteTableRequest(tableName);
      master.deleteTable(null,req);
      return null;
    }
  }
);
  int failures=0;
  for (int tries=0; tries < (this.numRetries * this.retryLongerMultiplier); tries++) {
    try {
      HRegionLocation firstMetaServer=getFirstMetaServerForTable(tableName);
      Scan scan=MetaReader.getScanForTableName(tableName);
      scan.addColumn(HConstants.CATALOG_FAMILY,HConstants.REGIONINFO_QUALIFIER);
      ScanRequest request=RequestConverter.buildScanRequest(firstMetaServer.getRegionInfo().getRegionName(),scan,1,true);
      Result[] values=null;
      ClientService.BlockingInterface server=connection.getClient(firstMetaServer.getServerName());
      PayloadCarryingRpcController controller=new PayloadCarryingRpcController();
      try {
        controller.setPriority(tableName);
        ScanResponse response=server.scan(controller,request);
        values=ResponseConverter.getResults(controller.cellScanner(),response);
      }
 catch (      ServiceException se) {
        throw ProtobufUtil.getRemoteException(se);
      }
      if (values == null || values.length == 0) {
        tableExists=false;
        GetTableDescriptorsResponse htds;
        MasterKeepAliveConnection master=connection.getKeepAliveMasterService();
        try {
          GetTableDescriptorsRequest req=RequestConverter.buildGetTableDescriptorsRequest(tableName);
          htds=master.getTableDescriptors(null,req);
        }
 catch (        ServiceException se) {
          throw ProtobufUtil.getRemoteException(se);
        }
 finally {
          master.close();
        }
        tableExists=!htds.getTableSchemaList().isEmpty();
        if (!tableExists) {
          break;
        }
      }
    }
 catch (    IOException ex) {
      failures++;
      if (failures == numRetries - 1) {
        if (ex instanceof RemoteException) {
          throw ((RemoteException)ex).unwrapRemoteException();
        }
 else {
          throw ex;
        }
      }
    }
    try {
      Thread.sleep(getPauseTime(tries));
    }
 catch (    InterruptedException e) {
      throw new InterruptedIOException("Interrupted when waiting" + " for table to be deleted");
    }
  }
  if (tableExists) {
    throw new IOException("Retries exhausted, it took too long to wait" + " for the table " + tableName + " to be deleted.");
  }
  this.connection.clearRegionCache(tableName);
  LOG.info("Deleted " + tableName);
}
