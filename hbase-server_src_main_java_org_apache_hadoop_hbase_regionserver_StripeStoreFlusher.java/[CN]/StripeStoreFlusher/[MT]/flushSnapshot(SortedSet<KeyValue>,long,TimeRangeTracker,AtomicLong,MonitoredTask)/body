{
  List<Path> result=null;
  int kvCount=snapshot.size();
  if (kvCount == 0)   return result;
  long smallestReadPoint=store.getSmallestReadPoint();
  InternalScanner scanner=createScanner(snapshot,smallestReadPoint);
  if (scanner == null) {
    return result;
  }
  StripeFlushRequest req=this.policy.selectFlush(this.stripes,kvCount);
  long flushedBytes=0;
  boolean success=false;
  StripeMultiFileWriter mw=null;
  try {
    mw=req.createWriter();
    StripeMultiFileWriter.WriterFactory factory=createWriterFactory(tracker,kvCount);
    StoreScanner storeScanner=(scanner instanceof StoreScanner) ? (StoreScanner)scanner : null;
    mw.init(storeScanner,factory,store.getComparator());
synchronized (flushLock) {
      flushedBytes=performFlush(scanner,mw,smallestReadPoint);
      result=mw.commitWriters(cacheFlushSeqNum,false);
      success=true;
    }
  }
  finally {
    if (!success && (mw != null)) {
      if (result != null) {
        result.clear();
      }
      for (      Path leftoverFile : mw.abortWriters()) {
        try {
          store.getFileSystem().delete(leftoverFile,false);
        }
 catch (        Exception e) {
          LOG.error("Failed to delete a file after failed flush: " + e);
        }
      }
    }
    flushedSize.set(flushedBytes);
    try {
      scanner.close();
    }
 catch (    IOException ex) {
      LOG.warn("Failed to close flush scanner, ignoring",ex);
    }
  }
  return result;
}
