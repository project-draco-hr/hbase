{
  TableName tableName=TableName.valueOf("TestSecureHLog");
  HTableDescriptor htd=new HTableDescriptor(tableName);
  htd.addFamily(new HColumnDescriptor(tableName.getName()));
  HRegionInfo regioninfo=new HRegionInfo(tableName,HConstants.EMPTY_START_ROW,HConstants.EMPTY_END_ROW,false);
  final int total=10;
  final byte[] row=Bytes.toBytes("row");
  final byte[] family=Bytes.toBytes("family");
  final byte[] value=Bytes.toBytes("Test value");
  FileSystem fs=TEST_UTIL.getTestFileSystem();
  Path logDir=TEST_UTIL.getDataTestDir("log");
  final AtomicLong sequenceId=new AtomicLong(1);
  HLog wal=new FSHLog(fs,TEST_UTIL.getDataTestDir(),logDir.toString(),TEST_UTIL.getConfiguration());
  for (int i=0; i < total; i++) {
    WALEdit kvs=new WALEdit();
    kvs.add(new KeyValue(row,family,Bytes.toBytes(i),value));
    wal.append(regioninfo,tableName,kvs,System.currentTimeMillis(),htd,sequenceId);
  }
  final Path walPath=((FSHLog)wal).computeFilename();
  wal.close();
  long length=fs.getFileStatus(walPath).getLen();
  FSDataInputStream in=fs.open(walPath);
  byte[] fileData=new byte[(int)length];
  IOUtils.readFully(in,fileData);
  in.close();
  assertFalse("Cells appear to be plaintext",Bytes.contains(fileData,value));
  HLog.Reader reader=HLogFactory.createReader(TEST_UTIL.getTestFileSystem(),walPath,TEST_UTIL.getConfiguration());
  int count=0;
  HLog.Entry entry=new HLog.Entry();
  while (reader.next(entry) != null) {
    count++;
    List<KeyValue> kvs=entry.getEdit().getKeyValues();
    assertTrue("Should be one KV per WALEdit",kvs.size() == 1);
    for (    KeyValue kv : kvs) {
      byte[] thisRow=kv.getRow();
      assertTrue("Incorrect row",Bytes.equals(thisRow,row));
      byte[] thisFamily=kv.getFamily();
      assertTrue("Incorrect family",Bytes.equals(thisFamily,family));
      byte[] thisValue=kv.getValue();
      assertTrue("Incorrect value",Bytes.equals(thisValue,value));
    }
  }
  assertEquals("Should have read back as many KVs as written",total,count);
  reader.close();
}
