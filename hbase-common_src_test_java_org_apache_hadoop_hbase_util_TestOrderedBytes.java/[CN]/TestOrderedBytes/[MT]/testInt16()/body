{
  Short[] vals={Short.MIN_VALUE,Short.MIN_VALUE / 2,0,Short.MAX_VALUE / 2,Short.MAX_VALUE};
  for (  Order ord : new Order[]{Order.ASCENDING,Order.DESCENDING}) {
    for (int i=0; i < vals.length; i++) {
      byte[] a=new byte[3 + 3];
      PositionedByteRange buf1=new SimplePositionedMutableByteRange(a,1,3 + 1);
      buf1.setPosition(1);
      assertEquals("Surprising return value.",3,OrderedBytes.encodeInt16(buf1,vals[i],ord));
      assertEquals("Broken test: serialization did not consume entire buffer.",buf1.getLength(),buf1.getPosition());
      assertEquals("Surprising serialized length.",3,buf1.getPosition() - 1);
      assertEquals("Buffer underflow.",0,a[0]);
      assertEquals("Buffer underflow.",0,a[1]);
      assertEquals("Buffer overflow.",0,a[a.length - 1]);
      buf1.setPosition(1);
      assertEquals("Surprising return value.",3,OrderedBytes.skip(buf1));
      assertEquals("Did not skip enough bytes.",3,buf1.getPosition() - 1);
      buf1.setPosition(1);
      assertEquals("Deserialization failed.",vals[i].shortValue(),OrderedBytes.decodeInt16(buf1));
      assertEquals("Did not consume enough bytes.",3,buf1.getPosition() - 1);
    }
  }
  for (  Order ord : new Order[]{Order.ASCENDING,Order.DESCENDING}) {
    byte[][] encoded=new byte[vals.length][3];
    PositionedByteRange pbr=new SimplePositionedMutableByteRange();
    for (int i=0; i < vals.length; i++) {
      OrderedBytes.encodeInt16(pbr.set(encoded[i]),vals[i],ord);
    }
    Arrays.sort(encoded,Bytes.BYTES_COMPARATOR);
    Short[] sortedVals=Arrays.copyOf(vals,vals.length);
    if (ord == Order.ASCENDING)     Arrays.sort(sortedVals);
 else     Arrays.sort(sortedVals,Collections.reverseOrder());
    for (int i=0; i < sortedVals.length; i++) {
      int decoded=OrderedBytes.decodeInt16(pbr.set(encoded[i]));
      assertEquals(String.format("Encoded representations do not preserve natural order: <%s>, <%s>, %s",sortedVals[i],decoded,ord),sortedVals[i].shortValue(),decoded);
    }
  }
}
