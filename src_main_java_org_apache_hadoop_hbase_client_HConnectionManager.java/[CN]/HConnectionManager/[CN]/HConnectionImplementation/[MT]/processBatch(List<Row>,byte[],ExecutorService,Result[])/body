{
  if (results.length != list.size()) {
    throw new IllegalArgumentException("argument results must be the same size as argument list");
  }
  if (list.size() == 0) {
    return;
  }
  List<Row> workingList=new ArrayList<Row>(list);
  final boolean singletonList=(list.size() == 1);
  boolean retry=true;
  Throwable singleRowCause=null;
  for (int tries=0; tries < numRetries && retry; ++tries) {
    if (tries >= 1) {
      long sleepTime=getPauseTime(tries);
      LOG.debug("Retry " + tries + ", sleep for "+ sleepTime+ "ms!");
      try {
        Thread.sleep(sleepTime);
      }
 catch (      InterruptedException ignore) {
        LOG.debug("Interupted");
        Thread.currentThread().interrupt();
        break;
      }
    }
    Map<HServerAddress,MultiAction> actionsByServer=new HashMap<HServerAddress,MultiAction>();
    for (int i=0; i < workingList.size(); i++) {
      Row row=workingList.get(i);
      if (row != null) {
        HRegionLocation loc=locateRegion(tableName,row.getRow(),true);
        HServerAddress address=loc.getServerAddress();
        byte[] regionName=loc.getRegionInfo().getRegionName();
        MultiAction actions=actionsByServer.get(address);
        if (actions == null) {
          actions=new MultiAction();
          actionsByServer.put(address,actions);
        }
        Action action=new Action(regionName,row,i);
        actions.add(regionName,action);
      }
    }
    Map<HServerAddress,Future<MultiResponse>> futures=new HashMap<HServerAddress,Future<MultiResponse>>(actionsByServer.size());
    for (    Entry<HServerAddress,MultiAction> e : actionsByServer.entrySet()) {
      futures.put(e.getKey(),pool.submit(createCallable(e.getKey(),e.getValue(),tableName)));
    }
    for (    Entry<HServerAddress,Future<MultiResponse>> responsePerServer : futures.entrySet()) {
      HServerAddress address=responsePerServer.getKey();
      try {
        Future<MultiResponse> future=responsePerServer.getValue();
        MultiResponse resp=future.get();
        if (resp == null) {
          LOG.debug("Failed all for server: " + address + ", removing from cache");
        }
 else {
          for (          Entry<byte[],List<Pair<Integer,Result>>> e : resp.getResults().entrySet()) {
            byte[] regionName=e.getKey();
            List<Pair<Integer,Result>> regionResults=e.getValue();
            for (            Pair<Integer,Result> regionResult : regionResults) {
              if (regionResult == null) {
                LOG.debug("Failures for region: " + Bytes.toStringBinary(regionName) + ", removing from cache");
              }
 else {
                results[regionResult.getFirst()]=regionResult.getSecond();
              }
            }
          }
        }
      }
 catch (      InterruptedException e) {
        LOG.debug("Failed all from " + address,e);
        Thread.currentThread().interrupt();
        break;
      }
catch (      ExecutionException e) {
        LOG.debug("Failed all from " + address,e);
        if (e.getCause() instanceof DoNotRetryIOException) {
          throw (DoNotRetryIOException)e.getCause();
        }
        if (singletonList) {
          singleRowCause=e.getCause();
        }
      }
    }
    retry=false;
    workingList.clear();
    for (int i=0; i < results.length; i++) {
      if (results[i] == null) {
        retry=true;
        Row row=list.get(i);
        workingList.add(row);
        deleteCachedLocation(tableName,row.getRow());
      }
 else {
        workingList.add(null);
      }
    }
  }
  if (Thread.currentThread().isInterrupted()) {
    throw new IOException("Aborting attempt because of a thread interruption");
  }
  if (retry) {
    if (singleRowCause != null) {
      throw new IOException(singleRowCause);
    }
 else {
      throw new RetriesExhaustedException("Still had " + workingList.size() + " actions left after retrying "+ numRetries+ " times.");
    }
  }
}
