{
  Scan scan=new Scan();
  scan.addFamily(INPUT_FAMILY);
  scan.addFamily(OUTPUT_FAMILY);
  ResultScanner scanner=table.getScanner(scan);
  try {
    Iterator<Result> itr=scanner.iterator();
    assertTrue(itr.hasNext());
    while (itr.hasNext()) {
      Result r=itr.next();
      if (LOG.isDebugEnabled()) {
        if (r.size() > 2) {
          throw new IOException("Too many results, expected 2 got " + r.size());
        }
      }
      byte[] firstValue=null;
      byte[] secondValue=null;
      int count=0;
      for (      KeyValue kv : r.list()) {
        if (count == 0) {
          firstValue=kv.getValue();
        }
 else         if (count == 1) {
          secondValue=kv.getValue();
        }
 else         if (count == 2) {
          break;
        }
        count++;
      }
      String first="";
      if (firstValue == null) {
        throw new NullPointerException(Bytes.toString(r.getRow()) + ": first value is null");
      }
      first=new String(firstValue,HConstants.UTF8_ENCODING);
      String second="";
      if (secondValue == null) {
        throw new NullPointerException(Bytes.toString(r.getRow()) + ": second value is null");
      }
      byte[] secondReversed=new byte[secondValue.length];
      for (int i=0, j=secondValue.length - 1; j >= 0; j--, i++) {
        secondReversed[i]=secondValue[j];
      }
      second=new String(secondReversed,HConstants.UTF8_ENCODING);
      if (first.compareTo(second) != 0) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("second key is not the reverse of first. row=" + Bytes.toStringBinary(r.getRow()) + ", first value="+ first+ ", second value="+ second);
        }
        fail();
      }
    }
  }
  finally {
    scanner.close();
  }
}
