{
  Map<byte[],Future<R>> futures=new TreeMap<byte[],Future<R>>(Bytes.BYTES_COMPARATOR);
  for (  final byte[] r : rows) {
    final ExecRPCInvoker invoker=new ExecRPCInvoker(conf,this,protocol,tableName,r);
    Future<R> future=pool.submit(new Callable<R>(){
      public R call() throws Exception {
        T instance=(T)Proxy.newProxyInstance(conf.getClassLoader(),new Class[]{protocol},invoker);
        R result=callable.call(instance);
        byte[] region=invoker.getRegionName();
        if (callback != null) {
          callback.update(region,r,result);
        }
        return result;
      }
    }
);
    futures.put(r,future);
  }
  for (  Map.Entry<byte[],Future<R>> e : futures.entrySet()) {
    try {
      e.getValue().get();
    }
 catch (    ExecutionException ee) {
      LOG.warn("Error executing for row " + Bytes.toStringBinary(e.getKey()),ee);
      throw ee.getCause();
    }
catch (    InterruptedException ie) {
      Thread.currentThread().interrupt();
      throw new IOException("Interrupted executing for row " + Bytes.toStringBinary(e.getKey()),ie);
    }
  }
}
