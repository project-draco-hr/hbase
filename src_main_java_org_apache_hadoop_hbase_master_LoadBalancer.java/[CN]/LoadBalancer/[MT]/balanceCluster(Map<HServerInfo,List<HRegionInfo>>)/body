{
  boolean emptyRegionServerPresent=false;
  long startTime=System.currentTimeMillis();
  TreeMap<HServerInfo,List<HRegionInfo>> serversByLoad=new TreeMap<HServerInfo,List<HRegionInfo>>(new HServerInfo.LoadComparator());
  int numServers=clusterState.size();
  if (numServers == 0) {
    LOG.debug("numServers=0 so skipping load balancing");
    return null;
  }
  int numRegions=0;
  for (  Map.Entry<HServerInfo,List<HRegionInfo>> server : clusterState.entrySet()) {
    int sz=server.getValue().size();
    if (sz == 0)     emptyRegionServerPresent=true;
    server.getKey().getLoad().setNumberOfRegions(sz);
    numRegions+=server.getKey().getLoad().getNumberOfRegions();
    serversByLoad.put(server.getKey(),server.getValue());
  }
  float average=(float)numRegions / numServers;
  int floor=(int)Math.floor(average * (1 - slop));
  int ceiling=(int)Math.ceil(average * (1 + slop));
  if (serversByLoad.lastKey().getLoad().getNumberOfRegions() <= ceiling && serversByLoad.firstKey().getLoad().getNumberOfRegions() >= floor) {
    LOG.info("Skipping load balancing.  servers=" + numServers + " "+ "regions="+ numRegions+ " average="+ average+ " "+ "mostloaded="+ serversByLoad.lastKey().getLoad().getNumberOfRegions()+ " leastloaded="+ serversByLoad.firstKey().getLoad().getNumberOfRegions());
    return null;
  }
  int min=numRegions / numServers;
  int max=numRegions % numServers == 0 ? min : min + 1;
  MinMaxPriorityQueue<RegionPlan> regionsToMove=MinMaxPriorityQueue.orderedBy(rpComparator).create();
  List<RegionPlan> regionsToReturn=new ArrayList<RegionPlan>();
  int serversOverloaded=0;
  boolean fetchFromTail=false;
  Map<HServerInfo,BalanceInfo> serverBalanceInfo=new TreeMap<HServerInfo,BalanceInfo>();
  for (  Map.Entry<HServerInfo,List<HRegionInfo>> server : serversByLoad.descendingMap().entrySet()) {
    HServerInfo serverInfo=server.getKey();
    int regionCount=serverInfo.getLoad().getNumberOfRegions();
    if (regionCount <= max) {
      serverBalanceInfo.put(serverInfo,new BalanceInfo(0,0));
      break;
    }
    serversOverloaded++;
    List<HRegionInfo> regions=server.getValue();
    int numToOffload=Math.min(regionCount - max,regions.size());
    Collections.sort(regions,riComparator);
    int numTaken=0;
    for (int i=0; i <= numToOffload; ) {
      HRegionInfo hri=regions.get(i);
      if (fetchFromTail) {
        hri=regions.get(regions.size() - 1 - i);
      }
      i++;
      if (hri.isMetaRegion())       continue;
      regionsToMove.add(new RegionPlan(hri,serverInfo,null));
      numTaken++;
      if (numTaken >= numToOffload)       break;
      if (emptyRegionServerPresent) {
        fetchFromTail=!fetchFromTail;
      }
    }
    serverBalanceInfo.put(serverInfo,new BalanceInfo(numToOffload,(-1) * numTaken));
  }
  int totalNumMoved=regionsToMove.size();
  int neededRegions=0;
  fetchFromTail=false;
  RegionPlan rp=null;
  Map<HServerInfo,Integer> underloadedServers=new HashMap<HServerInfo,Integer>();
  for (  Map.Entry<HServerInfo,List<HRegionInfo>> server : serversByLoad.entrySet()) {
    int regionCount=server.getKey().getLoad().getNumberOfRegions();
    if (regionCount >= min) {
      break;
    }
    underloadedServers.put(server.getKey(),min - regionCount);
  }
  int serversUnderloaded=underloadedServers.size();
  int incr=1;
  List<HServerInfo> serverInfos=Arrays.asList(underloadedServers.keySet().toArray(new HServerInfo[serversUnderloaded]));
  Collections.shuffle(serverInfos,RANDOM);
  while (regionsToMove.size() > 0) {
    int cnt=0;
    int i=incr > 0 ? 0 : underloadedServers.size() - 1;
    for (; i >= 0 && i < underloadedServers.size(); i+=incr) {
      if (0 == regionsToMove.size())       break;
      HServerInfo si=serverInfos.get(i);
      int numToTake=underloadedServers.get(si);
      if (numToTake == 0)       continue;
      if (!fetchFromTail)       rp=regionsToMove.remove();
 else       rp=regionsToMove.removeLast();
      rp.setDestination(si);
      regionsToReturn.add(rp);
      if (emptyRegionServerPresent) {
        fetchFromTail=!fetchFromTail;
      }
      underloadedServers.put(si,numToTake - 1);
      cnt++;
      BalanceInfo bi=serverBalanceInfo.get(si);
      if (bi == null) {
        bi=new BalanceInfo(0,0);
        serverBalanceInfo.put(si,bi);
      }
      bi.setNumRegionsAdded(bi.getNumRegionsAdded() + 1);
    }
    if (cnt == 0)     break;
    LOG.info("First pass inner loop assigned " + cnt + " regions");
    incr=-incr;
  }
  for (  Integer i : underloadedServers.values()) {
    neededRegions+=i;
  }
  if (neededRegions == 0 && 0 == regionsToMove.size()) {
    long endTime=System.currentTimeMillis();
    LOG.info("Calculated a load balance in " + (endTime - startTime) + "ms. "+ "Moving "+ totalNumMoved+ " regions off of "+ serversOverloaded+ " overloaded servers onto "+ serversUnderloaded+ " less loaded servers");
    return regionsToReturn;
  }
  if (neededRegions != 0) {
    for (    Map.Entry<HServerInfo,List<HRegionInfo>> server : serversByLoad.descendingMap().entrySet()) {
      BalanceInfo balanceInfo=serverBalanceInfo.get(server.getKey());
      int idx=balanceInfo == null ? 0 : balanceInfo.getNextRegionForUnload();
      if (idx >= server.getValue().size())       break;
      HRegionInfo region=server.getValue().get(idx);
      if (region.isMetaRegion())       continue;
      regionsToMove.add(new RegionPlan(region,server.getKey(),null));
      totalNumMoved++;
      if (--neededRegions == 0) {
        break;
      }
    }
  }
  for (  Map.Entry<HServerInfo,List<HRegionInfo>> server : serversByLoad.entrySet()) {
    int regionCount=server.getKey().getLoad().getNumberOfRegions();
    if (regionCount >= min)     break;
    BalanceInfo balanceInfo=serverBalanceInfo.get(server.getKey());
    if (balanceInfo != null) {
      regionCount+=balanceInfo.getNumRegionsAdded();
    }
    if (regionCount >= min) {
      continue;
    }
    int numToTake=min - regionCount;
    int numTaken=0;
    while (numTaken < numToTake && 0 < regionsToMove.size()) {
      if (!fetchFromTail)       rp=regionsToMove.remove();
 else       rp=regionsToMove.removeLast();
      rp.setDestination(server.getKey());
      regionsToReturn.add(rp);
      numTaken++;
      if (emptyRegionServerPresent) {
        fetchFromTail=!fetchFromTail;
      }
    }
  }
  if (0 < regionsToMove.size()) {
    for (    Map.Entry<HServerInfo,List<HRegionInfo>> server : serversByLoad.entrySet()) {
      int regionCount=server.getKey().getLoad().getNumberOfRegions();
      if (regionCount >= max) {
        break;
      }
      if (!fetchFromTail)       rp=regionsToMove.remove();
 else       rp=regionsToMove.removeLast();
      rp.setDestination(server.getKey());
      regionsToReturn.add(rp);
      if (emptyRegionServerPresent) {
        fetchFromTail=!fetchFromTail;
      }
      if (0 == regionsToMove.size()) {
        break;
      }
    }
  }
  long endTime=System.currentTimeMillis();
  if (0 != regionsToMove.size() || neededRegions != 0) {
    LOG.warn("regionsToMove=" + totalNumMoved + ", numServers="+ numServers+ ", serversOverloaded="+ serversOverloaded+ ", serversUnderloaded="+ serversUnderloaded);
    StringBuilder sb=new StringBuilder();
    for (    Map.Entry<HServerInfo,List<HRegionInfo>> e : clusterState.entrySet()) {
      if (sb.length() > 0)       sb.append(", ");
      sb.append(e.getKey().getServerName());
      sb.append(" ");
      sb.append(e.getValue().size());
    }
    LOG.warn("Input " + sb.toString());
  }
  LOG.info("Done. Calculated a load balance in " + (endTime - startTime) + "ms. "+ "Moving "+ totalNumMoved+ " regions off of "+ serversOverloaded+ " overloaded servers onto "+ serversUnderloaded+ " less loaded servers");
  return regionsToReturn;
}
