{
  boolean emptyRegionServerPresent=false;
  long startTime=System.currentTimeMillis();
  int numServers=clusterState.size();
  if (numServers == 0) {
    LOG.debug("numServers=0 so skipping load balancing");
    return null;
  }
  NavigableMap<ServerAndLoad,List<HRegionInfo>> serversByLoad=new TreeMap<ServerAndLoad,List<HRegionInfo>>();
  int numRegions=0;
  for (  Map.Entry<ServerName,List<HRegionInfo>> server : clusterState.entrySet()) {
    List<HRegionInfo> regions=server.getValue();
    int sz=regions.size();
    if (sz == 0)     emptyRegionServerPresent=true;
    numRegions+=sz;
    serversByLoad.put(new ServerAndLoad(server.getKey(),sz),regions);
  }
  float average=(float)numRegions / numServers;
  int floor=(int)Math.floor(average * (1 - slop));
  int ceiling=(int)Math.ceil(average * (1 + slop));
  if (serversByLoad.lastKey().getLoad() <= ceiling && serversByLoad.firstKey().getLoad() >= floor) {
    LOG.info("Skipping load balancing because balanced cluster; " + "servers=" + numServers + " "+ "regions="+ numRegions+ " average="+ average+ " "+ "mostloaded="+ serversByLoad.lastKey().getLoad()+ " leastloaded="+ serversByLoad.firstKey().getLoad());
    return null;
  }
  int min=numRegions / numServers;
  int max=numRegions % numServers == 0 ? min : min + 1;
  MinMaxPriorityQueue<RegionPlan> regionsToMove=MinMaxPriorityQueue.orderedBy(rpComparator).create();
  List<RegionPlan> regionsToReturn=new ArrayList<RegionPlan>();
  int serversOverloaded=0;
  boolean fetchFromTail=false;
  Map<ServerName,BalanceInfo> serverBalanceInfo=new TreeMap<ServerName,BalanceInfo>();
  for (  Map.Entry<ServerAndLoad,List<HRegionInfo>> server : serversByLoad.descendingMap().entrySet()) {
    ServerAndLoad sal=server.getKey();
    int regionCount=sal.getLoad();
    if (regionCount <= max) {
      serverBalanceInfo.put(sal.getServerName(),new BalanceInfo(0,0));
      break;
    }
    serversOverloaded++;
    List<HRegionInfo> regions=server.getValue();
    int numToOffload=Math.min(regionCount - max,regions.size());
    Collections.sort(regions,riComparator);
    int numTaken=0;
    for (int i=0; i <= numToOffload; ) {
      HRegionInfo hri=regions.get(i);
      if (fetchFromTail) {
        hri=regions.get(regions.size() - 1 - i);
      }
      i++;
      if (hri.isMetaRegion())       continue;
      regionsToMove.add(new RegionPlan(hri,sal.getServerName(),null));
      numTaken++;
      if (numTaken >= numToOffload)       break;
      if (emptyRegionServerPresent) {
        fetchFromTail=!fetchFromTail;
      }
    }
    serverBalanceInfo.put(sal.getServerName(),new BalanceInfo(numToOffload,(-1) * numTaken));
  }
  int totalNumMoved=regionsToMove.size();
  int neededRegions=0;
  fetchFromTail=false;
  Map<ServerName,Integer> underloadedServers=new HashMap<ServerName,Integer>();
  for (  Map.Entry<ServerAndLoad,List<HRegionInfo>> server : serversByLoad.entrySet()) {
    int regionCount=server.getKey().getLoad();
    if (regionCount >= min) {
      break;
    }
    underloadedServers.put(server.getKey().getServerName(),min - regionCount);
  }
  int serversUnderloaded=underloadedServers.size();
  int incr=1;
  List<ServerName> sns=Arrays.asList(underloadedServers.keySet().toArray(new ServerName[serversUnderloaded]));
  Collections.shuffle(sns,RANDOM);
  while (regionsToMove.size() > 0) {
    int cnt=0;
    int i=incr > 0 ? 0 : underloadedServers.size() - 1;
    for (; i >= 0 && i < underloadedServers.size(); i+=incr) {
      if (regionsToMove.isEmpty())       break;
      ServerName si=sns.get(i);
      int numToTake=underloadedServers.get(si);
      if (numToTake == 0)       continue;
      addRegionPlan(regionsToMove,fetchFromTail,si,regionsToReturn);
      if (emptyRegionServerPresent) {
        fetchFromTail=!fetchFromTail;
      }
      underloadedServers.put(si,numToTake - 1);
      cnt++;
      BalanceInfo bi=serverBalanceInfo.get(si);
      if (bi == null) {
        bi=new BalanceInfo(0,0);
        serverBalanceInfo.put(si,bi);
      }
      bi.setNumRegionsAdded(bi.getNumRegionsAdded() + 1);
    }
    if (cnt == 0)     break;
    incr=-incr;
  }
  for (  Integer i : underloadedServers.values()) {
    neededRegions+=i;
  }
  if (neededRegions == 0 && regionsToMove.isEmpty()) {
    long endTime=System.currentTimeMillis();
    LOG.info("Calculated a load balance in " + (endTime - startTime) + "ms. "+ "Moving "+ totalNumMoved+ " regions off of "+ serversOverloaded+ " overloaded servers onto "+ serversUnderloaded+ " less loaded servers");
    return regionsToReturn;
  }
  if (neededRegions != 0) {
    for (    Map.Entry<ServerAndLoad,List<HRegionInfo>> server : serversByLoad.descendingMap().entrySet()) {
      BalanceInfo balanceInfo=serverBalanceInfo.get(server.getKey().getServerName());
      int idx=balanceInfo == null ? 0 : balanceInfo.getNextRegionForUnload();
      if (idx >= server.getValue().size())       break;
      HRegionInfo region=server.getValue().get(idx);
      if (region.isMetaRegion())       continue;
      regionsToMove.add(new RegionPlan(region,server.getKey().getServerName(),null));
      totalNumMoved++;
      if (--neededRegions == 0) {
        break;
      }
    }
  }
  for (  Map.Entry<ServerAndLoad,List<HRegionInfo>> server : serversByLoad.entrySet()) {
    int regionCount=server.getKey().getLoad();
    if (regionCount >= min)     break;
    BalanceInfo balanceInfo=serverBalanceInfo.get(server.getKey().getServerName());
    if (balanceInfo != null) {
      regionCount+=balanceInfo.getNumRegionsAdded();
    }
    if (regionCount >= min) {
      continue;
    }
    int numToTake=min - regionCount;
    int numTaken=0;
    while (numTaken < numToTake && 0 < regionsToMove.size()) {
      addRegionPlan(regionsToMove,fetchFromTail,server.getKey().getServerName(),regionsToReturn);
      numTaken++;
      if (emptyRegionServerPresent) {
        fetchFromTail=!fetchFromTail;
      }
    }
  }
  if (0 < regionsToMove.size()) {
    for (    Map.Entry<ServerAndLoad,List<HRegionInfo>> server : serversByLoad.entrySet()) {
      int regionCount=server.getKey().getLoad();
      if (regionCount >= max) {
        break;
      }
      addRegionPlan(regionsToMove,fetchFromTail,server.getKey().getServerName(),regionsToReturn);
      if (emptyRegionServerPresent) {
        fetchFromTail=!fetchFromTail;
      }
      if (regionsToMove.isEmpty()) {
        break;
      }
    }
  }
  long endTime=System.currentTimeMillis();
  if (!regionsToMove.isEmpty() || neededRegions != 0) {
    LOG.warn("regionsToMove=" + totalNumMoved + ", numServers="+ numServers+ ", serversOverloaded="+ serversOverloaded+ ", serversUnderloaded="+ serversUnderloaded);
    StringBuilder sb=new StringBuilder();
    for (    Map.Entry<ServerName,List<HRegionInfo>> e : clusterState.entrySet()) {
      if (sb.length() > 0)       sb.append(", ");
      sb.append(e.getKey().toString());
      sb.append(" ");
      sb.append(e.getValue().size());
    }
    LOG.warn("Input " + sb.toString());
  }
  LOG.info("Done. Calculated a load balance in " + (endTime - startTime) + "ms. "+ "Moving "+ totalNumMoved+ " regions off of "+ serversOverloaded+ " overloaded servers onto "+ serversUnderloaded+ " less loaded servers");
  return regionsToReturn;
}
