{
  CompactSelection compactSelection=new CompactSelection(conf,candidates);
  boolean forcemajor=this.forceMajor && filesCompacting.isEmpty();
  if (!forcemajor) {
    if (conf.getBoolean("hbase.store.delete.expired.storefile",true) && (ttl != Long.MAX_VALUE) && (this.scanInfo.minVersions == 0)) {
      CompactSelection expiredSelection=compactSelection.selectExpiredStoreFilesToCompact(EnvironmentEdgeManager.currentTimeMillis() - this.ttl);
      if (expiredSelection != null) {
        return expiredSelection;
      }
    }
    int pos=0;
    while (pos < compactSelection.getFilesToCompact().size() && compactSelection.getFilesToCompact().get(pos).getReader().length() > maxCompactSize && !compactSelection.getFilesToCompact().get(pos).isReference())     ++pos;
    if (pos != 0)     compactSelection.clearSubList(0,pos);
  }
  if (compactSelection.getFilesToCompact().isEmpty()) {
    LOG.debug(this.getHRegionInfo().getEncodedName() + " - " + this+ ": no store files to compact");
    compactSelection.emptyFileList();
    return compactSelection;
  }
  boolean majorcompaction=(forcemajor && priority == PRIORITY_USER) || (forcemajor || isMajorCompaction(compactSelection.getFilesToCompact())) && (compactSelection.getFilesToCompact().size() < this.maxFilesToCompact);
  LOG.debug(this.getHRegionInfo().getEncodedName() + " - " + this.getColumnFamilyName()+ ": Initiating "+ (majorcompaction ? "major" : "minor")+ "compaction");
  if (!majorcompaction && !hasReferences(compactSelection.getFilesToCompact())) {
    int start=0;
    double r=compactSelection.getCompactSelectionRatio();
    if (compactSelection.getFilesToCompact().size() < this.minFilesToCompact) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Not compacting files because we only have " + compactSelection.getFilesToCompact().size() + " files ready for compaction.  Need "+ this.minFilesToCompact+ " to initiate.");
      }
      compactSelection.emptyFileList();
      return compactSelection;
    }
    compactSelection.getFilesToCompact().removeAll(Collections2.filter(compactSelection.getFilesToCompact(),new Predicate<StoreFile>(){
      public boolean apply(      StoreFile input){
        return input.excludeFromMinorCompaction();
      }
    }
));
    int countOfFiles=compactSelection.getFilesToCompact().size();
    long[] fileSizes=new long[countOfFiles];
    long[] sumSize=new long[countOfFiles];
    for (int i=countOfFiles - 1; i >= 0; --i) {
      StoreFile file=compactSelection.getFilesToCompact().get(i);
      fileSizes[i]=file.getReader().length();
      int tooFar=i + this.maxFilesToCompact - 1;
      sumSize[i]=fileSizes[i] + ((i + 1 < countOfFiles) ? sumSize[i + 1] : 0) - ((tooFar < countOfFiles) ? fileSizes[tooFar] : 0);
    }
    while (countOfFiles - start >= this.minFilesToCompact && fileSizes[start] > Math.max(minCompactSize,(long)(sumSize[start + 1] * r))) {
      ++start;
    }
    int end=Math.min(countOfFiles,start + this.maxFilesToCompact);
    long totalSize=fileSizes[start] + ((start + 1 < countOfFiles) ? sumSize[start + 1] : 0);
    compactSelection=compactSelection.getSubList(start,end);
    if (compactSelection.getFilesToCompact().size() < this.minFilesToCompact) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Skipped compaction of " + this + ".  Only "+ (end - start)+ " file(s) of size "+ StringUtils.humanReadableInt(totalSize)+ " have met compaction criteria.");
      }
      compactSelection.emptyFileList();
      return compactSelection;
    }
  }
 else {
    if (majorcompaction) {
      if (compactSelection.getFilesToCompact().size() > this.maxFilesToCompact) {
        LOG.debug("Warning, compacting more than " + this.maxFilesToCompact + " files, probably because of a user-requested major compaction");
        if (priority != PRIORITY_USER) {
          LOG.error("Compacting more than max files on a non user-requested compaction");
        }
      }
    }
 else     if (compactSelection.getFilesToCompact().size() > this.maxFilesToCompact) {
      int pastMax=compactSelection.getFilesToCompact().size() - this.maxFilesToCompact;
      compactSelection.getFilesToCompact().subList(0,pastMax).clear();
    }
  }
  return compactSelection;
}
