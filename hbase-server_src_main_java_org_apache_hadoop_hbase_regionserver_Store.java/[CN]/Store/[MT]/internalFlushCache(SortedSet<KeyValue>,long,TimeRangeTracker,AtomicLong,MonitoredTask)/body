{
  StoreFile.Writer writer;
  long smallestReadPoint=region.getSmallestReadPoint();
  long flushed=0;
  Path pathName;
  if (set.size() == 0) {
    return null;
  }
  InternalScanner scanner=null;
  KeyValueScanner memstoreScanner=new CollectionBackedScanner(set,this.comparator);
  if (getHRegion().getCoprocessorHost() != null) {
    scanner=getHRegion().getCoprocessorHost().preFlushScannerOpen(this,memstoreScanner);
  }
  if (scanner == null) {
    Scan scan=new Scan();
    scan.setMaxVersions(scanInfo.getMaxVersions());
    scanner=new StoreScanner(this,scanInfo,scan,Collections.singletonList(memstoreScanner),ScanType.MINOR_COMPACT,this.region.getSmallestReadPoint(),HConstants.OLDEST_TIMESTAMP);
  }
  if (getHRegion().getCoprocessorHost() != null) {
    InternalScanner cpScanner=getHRegion().getCoprocessorHost().preFlush(this,scanner);
    if (cpScanner == null) {
      return null;
    }
    scanner=cpScanner;
  }
  try {
    int compactionKVMax=conf.getInt(HConstants.COMPACTION_KV_MAX,10);
synchronized (flushLock) {
      status.setStatus("Flushing " + this + ": creating writer");
      writer=createWriterInTmp(set.size());
      writer.setTimeRangeTracker(snapshotTimeRangeTracker);
      pathName=writer.getPath();
      try {
        List<KeyValue> kvs=new ArrayList<KeyValue>();
        boolean hasMore;
        do {
          hasMore=scanner.next(kvs,compactionKVMax);
          if (!kvs.isEmpty()) {
            for (            KeyValue kv : kvs) {
              if (kv.getMemstoreTS() <= smallestReadPoint) {
                kv=kv.shallowCopy();
                kv.setMemstoreTS(0);
              }
              writer.append(kv);
              flushed+=this.memstore.heapSizeChange(kv,true);
            }
            kvs.clear();
          }
        }
 while (hasMore);
      }
  finally {
        status.setStatus("Flushing " + this + ": appending metadata");
        writer.appendMetadata(logCacheFlushId,false);
        status.setStatus("Flushing " + this + ": closing flushed file");
        writer.close();
      }
    }
  }
  finally {
    flushedSize.set(flushed);
    scanner.close();
  }
  if (LOG.isInfoEnabled()) {
    LOG.info("Flushed " + ", sequenceid=" + logCacheFlushId + ", memsize="+ StringUtils.humanReadableInt(flushed)+ ", into tmp file "+ pathName);
  }
  return pathName;
}
