{
  Path rootRegionDir=null;
  int numThreads=1;
  long numIterations=1000000;
  int numFamilies=1;
  int syncInterval=0;
  boolean noSync=false;
  boolean verify=false;
  boolean verbose=false;
  boolean cleanup=true;
  boolean noclosefs=false;
  long roll=Long.MAX_VALUE;
  boolean compress=false;
  String cipher=null;
  for (int i=0; i < args.length; i++) {
    String cmd=args[i];
    try {
      if (cmd.equals("-threads")) {
        numThreads=Integer.parseInt(args[++i]);
      }
 else       if (cmd.equals("-iterations")) {
        numIterations=Long.parseLong(args[++i]);
      }
 else       if (cmd.equals("-path")) {
        rootRegionDir=new Path(args[++i]);
      }
 else       if (cmd.equals("-families")) {
        numFamilies=Integer.parseInt(args[++i]);
      }
 else       if (cmd.equals("-qualifiers")) {
        numQualifiers=Integer.parseInt(args[++i]);
      }
 else       if (cmd.equals("-keySize")) {
        keySize=Integer.parseInt(args[++i]);
      }
 else       if (cmd.equals("-valueSize")) {
        valueSize=Integer.parseInt(args[++i]);
      }
 else       if (cmd.equals("-syncInterval")) {
        syncInterval=Integer.parseInt(args[++i]);
      }
 else       if (cmd.equals("-nosync")) {
        noSync=true;
      }
 else       if (cmd.equals("-verify")) {
        verify=true;
      }
 else       if (cmd.equals("-verbose")) {
        verbose=true;
      }
 else       if (cmd.equals("-nocleanup")) {
        cleanup=false;
      }
 else       if (cmd.equals("-noclosefs")) {
        noclosefs=true;
      }
 else       if (cmd.equals("-roll")) {
        roll=Long.parseLong(args[++i]);
      }
 else       if (cmd.equals("-compress")) {
        compress=true;
      }
 else       if (cmd.equals("-encryption")) {
        cipher=args[++i];
      }
 else       if (cmd.equals("-h")) {
        printUsageAndExit();
      }
 else       if (cmd.equals("--help")) {
        printUsageAndExit();
      }
 else {
        System.err.println("UNEXPECTED: " + cmd);
        printUsageAndExit();
      }
    }
 catch (    Exception e) {
      printUsageAndExit();
    }
  }
  if (compress) {
    Configuration conf=getConf();
    conf.setBoolean(HConstants.ENABLE_WAL_COMPRESSION,true);
  }
  if (cipher != null) {
    Configuration conf=getConf();
    conf.set(HConstants.CRYPTO_KEYPROVIDER_CONF_KEY,KeyProviderForTesting.class.getName());
    conf.set(HConstants.CRYPTO_MASTERKEY_NAME_CONF_KEY,"hbase");
    conf.setClass("hbase.regionserver.hlog.reader.impl",SecureProtobufLogReader.class,HLog.Reader.class);
    conf.setClass("hbase.regionserver.hlog.writer.impl",SecureProtobufLogWriter.class,HLog.Writer.class);
    conf.setBoolean(HConstants.ENABLE_WAL_ENCRYPTION,true);
    conf.set(HConstants.CRYPTO_WAL_ALGORITHM_CONF_KEY,cipher);
  }
  getConf().setInt(HConstants.REGION_SERVER_HANDLER_COUNT,numThreads);
  FSUtils.setFsDefault(getConf(),FSUtils.getRootDir(getConf()));
  FileSystem fs=FileSystem.get(getConf());
  LOG.info("FileSystem: " + fs);
  try {
    if (rootRegionDir == null) {
      rootRegionDir=TEST_UTIL.getDataTestDirOnTestFS("HLogPerformanceEvaluation");
    }
    rootRegionDir=rootRegionDir.makeQualified(fs);
    cleanRegionRootDir(fs,rootRegionDir);
    HTableDescriptor htd=createHTableDescriptor(numFamilies);
    final long whenToRoll=roll;
    final HLog hlog=new FSHLog(fs,rootRegionDir,"wals",getConf()){
      @Override public void postSync(      final long timeInNanos,      final int handlerSyncs){
        super.postSync(timeInNanos,handlerSyncs);
        syncMeter.mark();
        syncHistogram.update(timeInNanos);
        syncCountHistogram.update(handlerSyncs);
      }
      @Override public long postAppend(      final HLog.Entry entry,      final long elapsedTime){
        long size=super.postAppend(entry,elapsedTime);
        appendMeter.mark(size);
        return size;
      }
    }
;
    hlog.registerWALActionsListener(new WALActionsListener(){
      private int appends=0;
      @Override public void visitLogEntryBeforeWrite(      HTableDescriptor htd,      HLogKey logKey,      WALEdit logEdit){
        this.appends++;
        if (this.appends % whenToRoll == 0) {
          LOG.info("Rolling after " + appends + " edits");
          ((FSHLog)hlog).requestLogRoll();
        }
      }
      @Override public void visitLogEntryBeforeWrite(      HRegionInfo info,      HLogKey logKey,      WALEdit logEdit){
      }
      @Override public void preLogRoll(      Path oldPath,      Path newPath) throws IOException {
      }
      @Override public void preLogArchive(      Path oldPath,      Path newPath) throws IOException {
      }
      @Override public void postLogRoll(      Path oldPath,      Path newPath) throws IOException {
      }
      @Override public void postLogArchive(      Path oldPath,      Path newPath) throws IOException {
      }
      @Override public void logRollRequested(){
      }
      @Override public void logCloseRequested(){
      }
    }
);
    hlog.rollWriter();
    HRegion region=null;
    try {
      region=openRegion(fs,rootRegionDir,htd,hlog);
      ConsoleReporter.enable(this.metrics,30,TimeUnit.SECONDS);
      long putTime=runBenchmark(new HLogPutBenchmark(region,htd,numIterations,noSync,syncInterval),numThreads);
      logBenchmarkResult("Summary: threads=" + numThreads + ", iterations="+ numIterations+ ", syncInterval="+ syncInterval,numIterations * numThreads,putTime);
      if (region != null) {
        closeRegion(region);
        region=null;
      }
      if (verify) {
        Path dir=((FSHLog)hlog).getDir();
        long editCount=0;
        FileStatus[] fsss=fs.listStatus(dir);
        if (fsss.length == 0)         throw new IllegalStateException("No WAL found");
        for (        FileStatus fss : fsss) {
          Path p=fss.getPath();
          if (!fs.exists(p))           throw new IllegalStateException(p.toString());
          editCount+=verify(p,verbose);
        }
        long expected=numIterations * numThreads;
        if (editCount != expected) {
          throw new IllegalStateException("Counted=" + editCount + ", expected="+ expected);
        }
      }
    }
  finally {
      if (region != null)       closeRegion(region);
      if (cleanup)       cleanRegionRootDir(fs,rootRegionDir);
    }
  }
  finally {
    if (!noclosefs)     fs.close();
  }
  return (0);
}
