{
  try {
    try {
      KeyValue seekKey=KeyValue.createFirstOnRow(key.getRow());
      if (seekCount != null)       seekCount.incrementAndGet();
      if (!hfs.seekBefore(seekKey.getBuffer(),seekKey.getKeyOffset(),seekKey.getKeyLength())) {
        close();
        return false;
      }
      KeyValue firstKeyOfPreviousRow=KeyValue.createFirstOnRow(hfs.getKeyValue().getRow());
      if (seekCount != null)       seekCount.incrementAndGet();
      if (!seekAtOrAfter(hfs,firstKeyOfPreviousRow)) {
        close();
        return false;
      }
      cur=hfs.getKeyValue();
      this.stopSkippingKVsIfNextRow=true;
      boolean resultOfSkipKVs;
      try {
        resultOfSkipKVs=skipKVsNewerThanReadpoint();
      }
  finally {
        this.stopSkippingKVsIfNextRow=false;
      }
      if (!resultOfSkipKVs || Bytes.compareTo(cur.getBuffer(),cur.getRowOffset(),cur.getRowLength(),firstKeyOfPreviousRow.getBuffer(),firstKeyOfPreviousRow.getRowOffset(),firstKeyOfPreviousRow.getRowLength()) > 0) {
        return seekToPreviousRow(firstKeyOfPreviousRow);
      }
      return true;
    }
  finally {
      realSeekDone=true;
    }
  }
 catch (  IOException ioe) {
    throw new IOException("Could not seekToPreviousRow " + this + " to key "+ key,ioe);
  }
}
