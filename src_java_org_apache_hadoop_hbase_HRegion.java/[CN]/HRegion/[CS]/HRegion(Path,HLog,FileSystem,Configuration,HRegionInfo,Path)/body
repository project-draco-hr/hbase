{
  this.rootDir=rootDir;
  this.log=log;
  this.fs=fs;
  this.conf=conf;
  this.regionInfo=regionInfo;
  this.memcache=new HMemcache();
  this.threadWakeFrequency=conf.getLong(THREAD_WAKE_FREQUENCY,10 * 1000);
  this.optionalFlushCount=conf.getInt("hbase.hregion.memcache.optionalflushcount",10);
  this.regiondir=HRegion.getRegionDir(rootDir,this.regionInfo.regionName);
  Path oldLogFile=new Path(regiondir,HREGION_OLDLOGFILE_NAME);
  if (initialFiles != null && fs.exists(initialFiles)) {
    fs.rename(initialFiles,this.regiondir);
  }
  long maxSeqId=-1;
  for (  Map.Entry<Text,HColumnDescriptor> e : this.regionInfo.tableDesc.families().entrySet()) {
    Text colFamily=HStoreKey.extractFamily(e.getKey());
    HStore store=new HStore(rootDir,this.regionInfo.regionName,e.getValue(),fs,oldLogFile,conf);
    stores.put(colFamily,store);
    long storeSeqId=store.getMaxSequenceId();
    if (storeSeqId > maxSeqId) {
      maxSeqId=storeSeqId;
    }
  }
  this.maxSequenceId=maxSeqId;
  if (LOG.isDebugEnabled()) {
    LOG.debug("maximum sequence id for region " + regionInfo.getRegionName() + " is "+ this.maxSequenceId);
  }
  Path splits=new Path(regiondir,SPLITDIR);
  if (fs.exists(splits)) {
    fs.delete(splits);
  }
  Path merges=new Path(regiondir,MERGEDIR);
  if (fs.exists(merges)) {
    fs.delete(merges);
  }
  this.memcacheFlushSize=conf.getInt("hbase.hregion.memcache.flush.size",1024 * 1024 * 16);
  this.blockingMemcacheSize=this.memcacheFlushSize * conf.getInt("hbase.hregion.memcache.block.multiplier",2);
  this.desiredMaxFileSize=conf.getLong("hbase.hregion.max.filesize",DEFAULT_MAX_FILE_SIZE);
  this.writestate.compacting=false;
  LOG.info("region " + this.regionInfo.regionName + " available");
}
