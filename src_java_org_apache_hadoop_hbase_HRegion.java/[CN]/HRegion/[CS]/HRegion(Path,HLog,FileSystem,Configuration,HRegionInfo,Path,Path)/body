{
  this.dir=dir;
  this.log=log;
  this.fs=fs;
  this.conf=conf;
  this.regionInfo=regionInfo;
  this.writestate.writesOngoing=true;
  this.writestate.writesEnabled=true;
  this.writestate.closed=false;
  this.regiondir=HStoreFile.getHRegionDir(dir,this.regionInfo.regionName);
  if (initialFiles != null && fs.exists(initialFiles)) {
    fs.rename(initialFiles,regiondir);
  }
  for (Iterator<Text> it=this.regionInfo.tableDesc.families().iterator(); it.hasNext(); ) {
    Text colFamily=it.next();
    stores.put(colFamily,new HStore(dir,this.regionInfo.regionName,colFamily,this.regionInfo.tableDesc.getMaxVersions(),fs,oldLogFile,conf));
  }
  Path splits=new Path(regiondir,SPLITDIR);
  if (fs.exists(splits)) {
    fs.delete(splits);
  }
  Path merges=new Path(regiondir,MERGEDIR);
  if (fs.exists(merges)) {
    fs.delete(merges);
  }
  this.maxUnflushedEntries=conf.getInt("hbase.hregion.maxunflushed",10000);
  this.writestate.writesOngoing=false;
  LOG.info("region " + this.regionInfo.regionName + " available");
}
