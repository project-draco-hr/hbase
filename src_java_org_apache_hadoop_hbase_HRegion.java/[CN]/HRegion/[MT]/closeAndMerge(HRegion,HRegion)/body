{
  if (srcA.getStartKey() == null) {
    if (srcB.getStartKey() == null) {
      throw new IOException("Cannot merge two regions with null start key");
    }
  }
 else   if ((srcB.getStartKey() == null) || (srcA.getStartKey().compareTo(srcB.getStartKey()) > 0)) {
    HRegion tmp=srcA;
    srcA=srcB;
    srcB=tmp;
  }
  if (!srcA.getEndKey().equals(srcB.getStartKey())) {
    throw new IOException("Cannot merge non-adjacent regions");
  }
  FileSystem fs=srcA.getFilesystem();
  Configuration conf=srcA.getConf();
  HTableDescriptor tabledesc=srcA.getTableDesc();
  HLog log=srcA.getLog();
  Path rootDir=srcA.getRootDir();
  Text startKey=srcA.getStartKey();
  Text endKey=srcB.getEndKey();
  Path merges=new Path(srcA.getRegionDir(),MERGEDIR);
  if (!fs.exists(merges)) {
    fs.mkdirs(merges);
  }
  HRegionInfo newRegionInfo=new HRegionInfo(Math.abs(rand.nextLong()),tabledesc,startKey,endKey);
  Path newRegionDir=HStoreFile.getHRegionDir(merges,newRegionInfo.regionName);
  if (fs.exists(newRegionDir)) {
    throw new IOException("Cannot merge; target file collision at " + newRegionDir);
  }
  LOG.info("starting merge of regions: " + srcA.getRegionName() + " and "+ srcB.getRegionName()+ " new region start key is '"+ (startKey == null ? "" : startKey)+ "', end key is '"+ (endKey == null ? "" : endKey)+ "'");
  TreeSet<HStoreFile> alreadyMerged=new TreeSet<HStoreFile>();
  TreeMap<Text,Vector<HStoreFile>> filesToMerge=new TreeMap<Text,Vector<HStoreFile>>();
  for (  HStoreFile src : srcA.flushcache(true)) {
    Vector<HStoreFile> v=filesToMerge.get(src.getColFamily());
    if (v == null) {
      v=new Vector<HStoreFile>();
      filesToMerge.put(src.getColFamily(),v);
    }
    v.add(src);
  }
  for (  HStoreFile src : srcB.flushcache(true)) {
    Vector<HStoreFile> v=filesToMerge.get(src.getColFamily());
    if (v == null) {
      v=new Vector<HStoreFile>();
      filesToMerge.put(src.getColFamily(),v);
    }
    v.add(src);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("merging stores");
  }
  for (  Map.Entry<Text,Vector<HStoreFile>> es : filesToMerge.entrySet()) {
    Text colFamily=es.getKey();
    Vector<HStoreFile> srcFiles=es.getValue();
    HStoreFile dst=new HStoreFile(conf,merges,newRegionInfo.regionName,colFamily,Math.abs(rand.nextLong()));
    dst.mergeStoreFiles(srcFiles,fs,conf);
    alreadyMerged.addAll(srcFiles);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("flushing changes since start of merge for region " + srcA.getRegionName());
  }
  filesToMerge.clear();
  for (  HStoreFile src : srcA.close()) {
    if (!alreadyMerged.contains(src)) {
      Vector<HStoreFile> v=filesToMerge.get(src.getColFamily());
      if (v == null) {
        v=new Vector<HStoreFile>();
        filesToMerge.put(src.getColFamily(),v);
      }
      v.add(src);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("flushing changes since start of merge for region " + srcB.getRegionName());
  }
  for (  HStoreFile src : srcB.close()) {
    if (!alreadyMerged.contains(src)) {
      Vector<HStoreFile> v=filesToMerge.get(src.getColFamily());
      if (v == null) {
        v=new Vector<HStoreFile>();
        filesToMerge.put(src.getColFamily(),v);
      }
      v.add(src);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("merging changes since start of merge");
  }
  for (  Map.Entry<Text,Vector<HStoreFile>> es : filesToMerge.entrySet()) {
    Text colFamily=es.getKey();
    Vector<HStoreFile> srcFiles=es.getValue();
    HStoreFile dst=new HStoreFile(conf,merges,newRegionInfo.regionName,colFamily,Math.abs(rand.nextLong()));
    dst.mergeStoreFiles(srcFiles,fs,conf);
  }
  HRegion dstRegion=new HRegion(rootDir,log,fs,conf,newRegionInfo,newRegionDir);
  fs.delete(merges);
  LOG.info("merge completed. New region is " + dstRegion.getRegionName());
  return dstRegion;
}
