{
  HRegion a=srcA;
  HRegion b=srcB;
  if (srcA.getStartKey() == null) {
    if (srcB.getStartKey() == null) {
      throw new IOException("Cannot merge two regions with null start key");
    }
  }
 else   if ((srcB.getStartKey() == null) || (srcA.getStartKey().compareTo(srcB.getStartKey()) > 0)) {
    a=srcB;
    b=srcA;
  }
  if (!a.getEndKey().equals(b.getStartKey())) {
    throw new IOException("Cannot merge non-adjacent regions");
  }
  FileSystem fs=a.getFilesystem();
  Configuration conf=a.getConf();
  HTableDescriptor tabledesc=a.getTableDesc();
  HLog log=a.getLog();
  Path rootDir=a.getRootDir();
  Text startKey=a.getStartKey();
  Text endKey=b.getEndKey();
  Path merges=new Path(a.getRegionDir(),MERGEDIR);
  if (!fs.exists(merges)) {
    fs.mkdirs(merges);
  }
  HRegionInfo newRegionInfo=new HRegionInfo(Math.abs(rand.nextLong()),tabledesc,startKey,endKey);
  Path newRegionDir=HStoreFile.getHRegionDir(merges,newRegionInfo.regionName);
  if (fs.exists(newRegionDir)) {
    throw new IOException("Cannot merge; target file collision at " + newRegionDir);
  }
  LOG.info("starting merge of regions: " + a.getRegionName() + " and "+ b.getRegionName()+ " new region start key is '"+ (startKey == null ? "" : startKey)+ "', end key is '"+ (endKey == null ? "" : endKey)+ "'");
  TreeSet<HStoreFile> alreadyMerged=new TreeSet<HStoreFile>();
  TreeMap<Text,Vector<HStoreFile>> filesToMerge=new TreeMap<Text,Vector<HStoreFile>>();
  for (  HStoreFile src : a.flushcache(true)) {
    Vector<HStoreFile> v=filesToMerge.get(src.getColFamily());
    if (v == null) {
      v=new Vector<HStoreFile>();
      filesToMerge.put(src.getColFamily(),v);
    }
    v.add(src);
  }
  for (  HStoreFile src : b.flushcache(true)) {
    Vector<HStoreFile> v=filesToMerge.get(src.getColFamily());
    if (v == null) {
      v=new Vector<HStoreFile>();
      filesToMerge.put(src.getColFamily(),v);
    }
    v.add(src);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("merging stores");
  }
  for (  Map.Entry<Text,Vector<HStoreFile>> es : filesToMerge.entrySet()) {
    Text colFamily=es.getKey();
    Vector<HStoreFile> srcFiles=es.getValue();
    HStoreFile dst=new HStoreFile(conf,merges,newRegionInfo.regionName,colFamily,Math.abs(rand.nextLong()));
    dst.mergeStoreFiles(srcFiles,fs,conf);
    alreadyMerged.addAll(srcFiles);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("flushing changes since start of merge for region " + a.getRegionName());
  }
  filesToMerge.clear();
  for (  HStoreFile src : a.close()) {
    if (!alreadyMerged.contains(src)) {
      Vector<HStoreFile> v=filesToMerge.get(src.getColFamily());
      if (v == null) {
        v=new Vector<HStoreFile>();
        filesToMerge.put(src.getColFamily(),v);
      }
      v.add(src);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("flushing changes since start of merge for region " + b.getRegionName());
  }
  for (  HStoreFile src : b.close()) {
    if (!alreadyMerged.contains(src)) {
      Vector<HStoreFile> v=filesToMerge.get(src.getColFamily());
      if (v == null) {
        v=new Vector<HStoreFile>();
        filesToMerge.put(src.getColFamily(),v);
      }
      v.add(src);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("merging changes since start of merge");
  }
  for (  Map.Entry<Text,Vector<HStoreFile>> es : filesToMerge.entrySet()) {
    Text colFamily=es.getKey();
    Vector<HStoreFile> srcFiles=es.getValue();
    HStoreFile dst=new HStoreFile(conf,merges,newRegionInfo.regionName,colFamily,Math.abs(rand.nextLong()));
    dst.mergeStoreFiles(srcFiles,fs,conf);
  }
  HRegion dstRegion=new HRegion(rootDir,log,fs,conf,newRegionInfo,newRegionDir);
  fs.delete(merges);
  LOG.info("merge completed. New region is " + dstRegion.getRegionName());
  return dstRegion;
}
