{
  Vector<HStoreFile> allHStoreFiles=new Vector<HStoreFile>();
  if (LOG.isDebugEnabled()) {
    LOG.debug("flushing cache for region " + this.regionInfo.regionName);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("starting memcache snapshot");
  }
  HMemcache.Snapshot retval=memcache.snapshotMemcacheForLog(log);
  TreeMap<HStoreKey,byte[]> memcacheSnapshot=retval.memcacheSnapshot;
  if (memcacheSnapshot == null) {
    for (    HStore hstore : stores.values()) {
      Vector<HStoreFile> hstoreFiles=hstore.getAllMapFiles();
      allHStoreFiles.addAll(0,hstoreFiles);
    }
    return allHStoreFiles;
  }
  long logCacheFlushId=retval.sequenceId;
  if (LOG.isDebugEnabled()) {
    LOG.debug("flushing memcache to HStores");
  }
  for (Iterator<HStore> it=stores.values().iterator(); it.hasNext(); ) {
    HStore hstore=it.next();
    Vector<HStoreFile> hstoreFiles=hstore.flushCache(memcacheSnapshot,logCacheFlushId);
    allHStoreFiles.addAll(0,hstoreFiles);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("writing flush cache complete to log");
  }
  log.completeCacheFlush(this.regionInfo.regionName,regionInfo.tableDesc.getName(),logCacheFlushId);
  if (LOG.isDebugEnabled()) {
    LOG.debug("deleting memcache snapshot");
  }
  memcache.deleteSnapshot();
  if (LOG.isDebugEnabled()) {
    LOG.debug("cache flush complete for region " + this.regionInfo.regionName);
  }
  this.commitsSinceFlush=0;
  return allHStoreFiles;
}
