{
  long startTime=-1;
  if (LOG.isDebugEnabled()) {
    startTime=System.currentTimeMillis();
    LOG.debug("Started memcache flush for region " + this.regionInfo.regionName + ". Size "+ StringUtils.humanReadableInt(this.memcache.getSize()));
  }
  HMemcache.Snapshot retval=memcache.snapshotMemcacheForLog(log);
  if (retval == null || retval.memcacheSnapshot == null) {
    LOG.debug("Finished memcache flush; empty snapshot");
    return;
  }
  try {
    long logCacheFlushId=retval.sequenceId;
    if (LOG.isDebugEnabled()) {
      LOG.debug("Snapshotted memcache for region " + this.regionInfo.regionName + " with sequence id "+ retval.sequenceId+ " and entries "+ retval.memcacheSnapshot.size());
    }
    for (    HStore hstore : stores.values()) {
      hstore.flushCache(retval.memcacheSnapshot,retval.sequenceId);
    }
    log.completeCacheFlush(this.regionInfo.regionName,regionInfo.tableDesc.getName(),logCacheFlushId);
  }
 catch (  IOException e) {
    LOG.fatal("Interrupted while flushing. Edits lost. FIX! HADOOP-1903",e);
    log.abort();
    throw e;
  }
 finally {
    memcache.deleteSnapshot();
  }
synchronized (this) {
    notifyAll();
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Finished memcache flush for region " + this.regionInfo.regionName + " in "+ (System.currentTimeMillis() - startTime)+ "ms");
  }
}
