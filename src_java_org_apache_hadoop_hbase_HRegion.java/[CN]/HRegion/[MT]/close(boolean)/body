{
  if (isClosed()) {
    LOG.info("region " + this.regionInfo.regionName + " already closed");
    return null;
  }
  lock.obtainWriteLock();
  try {
synchronized (writestate) {
      while (writestate.compacting || writestate.flushing) {
        try {
          writestate.wait();
        }
 catch (        InterruptedException iex) {
        }
      }
      writestate.writesEnabled=false;
    }
    waitOnRowLocks();
    if (!abort) {
      internalFlushcache();
    }
    Vector<HStoreFile> result=new Vector<HStoreFile>();
    for (    HStore store : stores.values()) {
      result.addAll(store.close());
    }
    this.closed.set(true);
    LOG.info("closed " + this.regionInfo.regionName);
    return result;
  }
  finally {
    lock.releaseWriteLock();
  }
}
