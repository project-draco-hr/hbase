{
  byte upperLimitByte;
  byte lowerLimitByte;
  if (isText) {
    upperLimitByte='~';
    lowerLimitByte=' ';
  }
 else {
    upperLimitByte=Byte.MAX_VALUE;
    lowerLimitByte=Byte.MIN_VALUE;
  }
  if (start.length == 0 && end.length == 0) {
    return new byte[]{(byte)((lowerLimitByte + upperLimitByte) / 2)};
  }
  if (start.length == 0 && end.length != 0) {
    return new byte[]{end[0]};
  }
  if (start.length != 0 && end.length == 0) {
    byte[] result=new byte[start.length];
    result[0]=start[0];
    for (int k=1; k < start.length; k++) {
      result[k]=upperLimitByte;
    }
    return result;
  }
  List resultBytesList=new ArrayList();
  int maxLength=start.length > end.length ? start.length : end.length;
  for (int i=0; i < maxLength; i++) {
    if (start[i] == end[i]) {
      resultBytesList.add(start[i]);
      if (i + 1 == start.length) {
        resultBytesList.add((byte)((lowerLimitByte + end[i + 1]) / 2));
        break;
      }
    }
 else {
      if ((int)end[i] - (int)start[i] == 1) {
        byte startNextByte=(i + 1 < start.length) ? start[i + 1] : lowerLimitByte;
        byte endNextByte=(i + 1 < end.length) ? end[i + 1] : lowerLimitByte;
        int byteRange=(upperLimitByte - startNextByte) + (endNextByte - lowerLimitByte) + 1;
        int halfRange=byteRange / 2;
        if ((int)startNextByte + halfRange > (int)upperLimitByte) {
          resultBytesList.add(end[i]);
          resultBytesList.add((byte)(startNextByte + halfRange - upperLimitByte + lowerLimitByte));
        }
 else {
          resultBytesList.add(start[i]);
          resultBytesList.add((byte)(startNextByte + halfRange));
        }
      }
 else {
        resultBytesList.add((byte)((start[i] + end[i]) / 2));
      }
      break;
    }
  }
  byte result[]=new byte[resultBytesList.size()];
  for (int k=0; k < resultBytesList.size(); k++) {
    result[k]=(byte)resultBytesList.get(k);
  }
  return result;
}
