{
  if (this.bulkAssign)   return;
synchronized (regionsInTransition) {
    long now=System.currentTimeMillis();
    for (    RegionState regionState : regionsInTransition.values()) {
      if (regionState.getStamp() + timeout <= now) {
        HRegionInfo regionInfo=regionState.getRegion();
        LOG.info("Regions in transition timed out:  " + regionState);
switch (regionState.getState()) {
case OFFLINE:
case CLOSED:
          LOG.info("Region has been OFFLINE or CLOSED for too long, " + "reassigning " + regionInfo.getRegionNameAsString());
        assign(regionState.getRegion());
      break;
case PENDING_OPEN:
case OPENING:
    LOG.info("Region has been PENDING_OPEN  or OPENING for too " + "long, reassigning region=" + regionInfo.getRegionNameAsString());
  AssignmentManager.this.setOffline(regionState.getRegion());
regionState.update(RegionState.State.OFFLINE);
assign(regionState.getRegion());
break;
case OPEN:
LOG.warn("Long-running region in OPEN state?  This should " + "not happen; region=" + regionInfo.getRegionNameAsString());
break;
case PENDING_CLOSE:
case CLOSING:
LOG.info("Region has been PENDING_CLOSE or CLOSING for too " + "long, running unassign again on region=" + regionInfo.getRegionNameAsString());
unassign(regionInfo);
break;
}
}
}
}
}
