{
  LOG.debug("Starting unassignment of region " + region.getRegionNameAsString() + " (offlining)");
synchronized (this.regions) {
    if (!regions.containsKey(region)) {
      LOG.debug("Attempted to unassign region " + region.getRegionNameAsString() + " but it is not "+ "currently assigned anywhere");
      return;
    }
  }
  String encodedName=region.getEncodedName();
  RegionState state;
  int versionOfClosingNode=-1;
synchronized (regionsInTransition) {
    state=regionsInTransition.get(encodedName);
    if (state == null) {
      try {
        versionOfClosingNode=ZKAssign.createNodeClosing(master.getZooKeeper(),region,master.getServerName());
        if (versionOfClosingNode == -1) {
          LOG.debug("Attempting to unassign region " + region.getRegionNameAsString() + " but ZK closing node "+ "can't be created.");
          return;
        }
      }
 catch (      KeeperException ee) {
        Exception e=ee;
        if (e instanceof NodeExistsException) {
          NodeExistsException nee=(NodeExistsException)e;
          String path=nee.getPath();
          try {
            if (isSplitOrSplitting(path)) {
              LOG.debug(path + " is SPLIT or SPLITTING; " + "skipping unassign because region no longer exists -- its split");
              return;
            }
          }
 catch (          KeeperException.NoNodeException ke) {
            LOG.warn("Failed getData on SPLITTING/SPLIT at " + path + "; presuming split and that the region to unassign, "+ encodedName+ ", no longer exists -- confirm",ke);
            return;
          }
catch (          KeeperException ke) {
            LOG.error("Unexpected zk state",ke);
          }
catch (          DeserializationException de) {
            LOG.error("Failed parse",de);
          }
        }
        master.abort("Unexpected ZK exception creating node CLOSING",e);
        return;
      }
      state=new RegionState(region,RegionState.State.PENDING_CLOSE);
      regionsInTransition.put(encodedName,state);
    }
 else     if (force && (state.isPendingClose() || state.isClosing())) {
      LOG.debug("Attempting to unassign region " + region.getRegionNameAsString() + " which is already "+ state.getState()+ " but forcing to send a CLOSE RPC again ");
      state.update(state.getState());
    }
 else {
      LOG.debug("Attempting to unassign region " + region.getRegionNameAsString() + " but it is "+ "already in transition ("+ state.getState()+ ", force="+ force+ ")");
      return;
    }
  }
  ServerName server=null;
synchronized (this.regions) {
    server=regions.get(region);
  }
  if (server == null) {
synchronized (regionsInTransition) {
      state=regionsInTransition.get(encodedName);
      if (state != null) {
        State presentState=state.getState();
        if (presentState == State.PENDING_CLOSE || presentState == State.CLOSING) {
          this.regionsInTransition.remove(encodedName);
        }
      }
    }
    deleteClosingOrClosedNode(region);
    return;
  }
  try {
    if (serverManager.sendRegionClose(server,state.getRegion(),versionOfClosingNode,dest)) {
      LOG.debug("Sent CLOSE to " + server + " for region "+ region.getRegionNameAsString());
      return;
    }
    LOG.warn("Server " + server + " region CLOSE RPC returned false for "+ region.getRegionNameAsString());
  }
 catch (  Throwable t) {
    if (t instanceof RemoteException) {
      t=((RemoteException)t).unwrapRemoteException();
    }
    if (t instanceof NotServingRegionException) {
      if (checkIfRegionBelongsToDisabling(region)) {
        LOG.info("While trying to recover the table " + region.getTableNameAsString() + " to DISABLED state the region "+ region+ " was offlined but the table was in DISABLING state");
synchronized (this.regionsInTransition) {
          this.regionsInTransition.remove(region.getEncodedName());
        }
synchronized (this.regions) {
          this.regions.remove(region);
          Set<HRegionInfo> serverRegions=this.servers.get(server);
          if (!serverRegions.remove(region)) {
            LOG.warn("No " + region + " on "+ server);
          }
        }
        deleteClosingOrClosedNode(region);
      }
    }
 else     if (t instanceof RegionAlreadyInTransitionException) {
      LOG.debug("update " + state + " the timestamp.");
      state.update(state.getState());
    }
    LOG.info("Server " + server + " returned "+ t+ " for "+ region.getRegionNameAsString(),t);
  }
}
