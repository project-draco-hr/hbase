{
  final String encodedName=state.getRegion().getEncodedName();
  final List<ServerName> servers=this.serverManager.getOnlineServersList();
  final List<ServerName> drainingServers=this.serverManager.getDrainingServersList();
  if (serverToExclude != null)   servers.remove(serverToExclude);
  if (!drainingServers.isEmpty()) {
    for (    final ServerName server : drainingServers) {
      LOG.debug("Removing draining server: " + server + " from eligible server pool.");
      servers.remove(server);
    }
  }
  if (servers.isEmpty())   return null;
  RegionPlan randomPlan=new RegionPlan(state.getRegion(),null,balancer.randomAssignment(servers));
  boolean newPlan=false;
  RegionPlan existingPlan=null;
synchronized (this.regionPlans) {
    existingPlan=this.regionPlans.get(encodedName);
    if (existingPlan != null && existingPlan.getDestination() != null) {
      LOG.debug("Found an existing plan for " + state.getRegion().getRegionNameAsString() + " destination server is + "+ existingPlan.getDestination().toString());
    }
    if (forceNewPlan || existingPlan == null || existingPlan.getDestination() == null || drainingServers.contains(existingPlan.getDestination())) {
      newPlan=true;
      this.regionPlans.put(encodedName,randomPlan);
    }
  }
  if (newPlan) {
    debugLog(state.getRegion(),"No previous transition plan was found (or we are ignoring " + "an existing plan) for " + state.getRegion().getRegionNameAsString() + " so generated a random one; "+ randomPlan+ "; "+ serverManager.countOfRegionServers()+ " (online="+ serverManager.getOnlineServers().size()+ ", exclude="+ drainingServers.size()+ ") available servers");
    return randomPlan;
  }
  debugLog(state.getRegion(),"Using pre-existing plan for region " + state.getRegion().getRegionNameAsString() + "; plan="+ existingPlan);
  return existingPlan;
}
