{
  final String encodedName=state.getRegion().getEncodedName();
  final List<ServerName> destServers=serverManager.createDestinationServersList(serverToExclude);
  if (destServers.isEmpty()) {
    LOG.warn("Can't move the region " + encodedName + ", there is no destination server available.");
    return null;
  }
  RegionPlan randomPlan=null;
  boolean newPlan=false;
  RegionPlan existingPlan=null;
synchronized (this.regionPlans) {
    existingPlan=this.regionPlans.get(encodedName);
    if (existingPlan != null && existingPlan.getDestination() != null) {
      LOG.debug("Found an existing plan for " + state.getRegion().getRegionNameAsString() + " destination server is "+ existingPlan.getDestination().toString());
    }
    if (forceNewPlan || existingPlan == null || existingPlan.getDestination() == null || !destServers.contains(existingPlan.getDestination())) {
      newPlan=true;
      randomPlan=new RegionPlan(state.getRegion(),null,balancer.randomAssignment(state.getRegion(),destServers));
      this.regionPlans.put(encodedName,randomPlan);
    }
  }
  if (newPlan) {
    LOG.debug("No previous transition plan was found (or we are ignoring " + "an existing plan) for " + state.getRegion().getRegionNameAsString() + " so generated a random one; "+ randomPlan+ "; "+ serverManager.countOfRegionServers()+ " (online="+ serverManager.getOnlineServers().size()+ ", available="+ destServers.size()+ ") available servers");
    return randomPlan;
  }
  LOG.debug("Using pre-existing plan for region " + state.getRegion().getRegionNameAsString() + "; plan="+ existingPlan);
  return existingPlan;
}
