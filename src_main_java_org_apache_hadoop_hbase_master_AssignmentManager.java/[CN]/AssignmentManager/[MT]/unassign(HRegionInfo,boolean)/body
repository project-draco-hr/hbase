{
  LOG.debug("Starting unassignment of region " + region.getRegionNameAsString() + " (offlining)");
synchronized (this.regions) {
    if (!regions.containsKey(region)) {
      LOG.debug("Attempted to unassign region " + region.getRegionNameAsString() + " but it is not "+ "currently assigned anywhere");
      return;
    }
  }
  String encodedName=region.getEncodedName();
  RegionState state;
synchronized (regionsInTransition) {
    state=regionsInTransition.get(encodedName);
    if (state == null) {
      state=new RegionState(region,RegionState.State.PENDING_CLOSE);
      regionsInTransition.put(encodedName,state);
    }
 else     if (force && state.isPendingClose()) {
      LOG.debug("Attempting to unassign region " + region.getRegionNameAsString() + " which is already pending close "+ "but forcing an additional close");
      state.update(RegionState.State.PENDING_CLOSE);
    }
 else {
      LOG.debug("Attempting to unassign region " + region.getRegionNameAsString() + " but it is "+ "already in transition ("+ state.getState()+ ")");
      return;
    }
  }
  HServerInfo server=null;
synchronized (this.regions) {
    server=regions.get(region);
  }
  try {
    if (serverManager.sendRegionClose(server,state.getRegion())) {
      LOG.debug("Sent CLOSE to " + server + " for region "+ region.getRegionNameAsString());
      return;
    }
    LOG.debug("Server " + server + " region CLOSE RPC returned false for "+ region.getEncodedName());
  }
 catch (  NotServingRegionException nsre) {
    LOG.info("Server " + server + " returned "+ nsre+ " for "+ region.getEncodedName());
    return;
  }
catch (  ConnectException e) {
    LOG.info("Failed connect to " + server + ", message="+ e.getMessage()+ ", region="+ region.getEncodedName());
  }
catch (  java.net.SocketTimeoutException e) {
    LOG.info("Server " + server + " returned "+ e.getMessage()+ " for "+ region.getEncodedName());
  }
catch (  EOFException e) {
    LOG.info("Server " + server + " returned "+ e.getMessage()+ " for "+ region.getEncodedName());
  }
catch (  RemoteException re) {
    IOException ioe=re.unwrapRemoteException();
    if (ioe instanceof NotServingRegionException) {
      LOG.debug("Server " + server + " returned "+ ioe+ " for "+ region.getEncodedName());
    }
 else     if (ioe instanceof EOFException) {
      LOG.debug("Server " + server + " returned "+ ioe+ " for "+ region.getEncodedName());
    }
 else {
      this.master.abort("Remote unexpected exception",ioe);
    }
  }
catch (  Throwable t) {
    this.master.abort("Remote unexpected exception",t);
  }
}
