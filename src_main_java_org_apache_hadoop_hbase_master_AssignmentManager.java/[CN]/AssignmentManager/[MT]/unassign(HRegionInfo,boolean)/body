{
  LOG.debug("Starting unassignment of region " + region.getRegionNameAsString() + " (offlining)");
  if (!regions.containsKey(region)) {
    LOG.debug("Attempted to unassign region " + region.getRegionNameAsString() + " but it is not "+ "currently assigned anywhere");
    return;
  }
  String encodedName=region.getEncodedName();
  RegionState state;
synchronized (regionsInTransition) {
    state=regionsInTransition.get(encodedName);
    if (state == null) {
      state=new RegionState(region,RegionState.State.PENDING_CLOSE);
      regionsInTransition.put(encodedName,state);
    }
 else     if (force && (state.isClosing() || state.isPendingClose())) {
      LOG.debug("Attempting to unassign region " + region.getRegionNameAsString() + " which is already closing but "+ "forcing an additional close");
      state.update(RegionState.State.PENDING_CLOSE);
    }
 else {
      LOG.debug("Attempting to unassign region " + region.getRegionNameAsString() + " but it is "+ "already in transition ("+ state.getState()+ ")");
      return;
    }
  }
  try {
    if (!serverManager.sendRegionClose(regions.get(region),state.getRegion())) {
      throw new NotServingRegionException("Server failed to close region");
    }
  }
 catch (  NotServingRegionException nsre) {
    LOG.debug("Attempted to send CLOSE to " + regions.get(region) + " for region "+ region.getRegionNameAsString()+ " but failed, "+ "setting region as OFFLINE and reassigning");
synchronized (regionsInTransition) {
      forceRegionStateToOffline(region);
      assign(region);
    }
  }
catch (  IOException e) {
    this.master.abort("Remote unexpected exception",e);
  }
catch (  Throwable t) {
    this.master.abort("Remote unexpected exception",t);
  }
}
