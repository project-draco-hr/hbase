{
  int version=in.readByte();
  if (version > INCREMENT_VERSION) {
    throw new IOException("unsupported version");
  }
  this.row=Bytes.readByteArray(in);
  this.tr=new TimeRange();
  tr.readFields(in);
  this.lockId=in.readLong();
  int numFamilies=in.readInt();
  if (numFamilies == 0) {
    throw new IOException("At least one column required");
  }
  this.familyMap=new TreeMap<byte[],NavigableMap<byte[],Long>>(Bytes.BYTES_COMPARATOR);
  for (int i=0; i < numFamilies; i++) {
    byte[] family=Bytes.readByteArray(in);
    boolean hasColumns=in.readBoolean();
    NavigableMap<byte[],Long> set=null;
    if (hasColumns) {
      int numColumns=in.readInt();
      set=new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);
      for (int j=0; j < numColumns; j++) {
        byte[] qualifier=Bytes.readByteArray(in);
        set.put(qualifier,in.readLong());
      }
    }
 else {
      throw new IOException("At least one column required per family");
    }
    this.familyMap.put(family,set);
  }
  if (version > 1) {
    this.writeToWAL=in.readBoolean();
  }
}
