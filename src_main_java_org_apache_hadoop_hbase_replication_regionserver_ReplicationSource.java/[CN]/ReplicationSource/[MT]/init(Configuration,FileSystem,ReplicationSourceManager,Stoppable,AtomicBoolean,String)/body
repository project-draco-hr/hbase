{
  this.stopper=stopper;
  this.conf=conf;
  this.replicationQueueSizeCapacity=this.conf.getLong("replication.source.size.capacity",1024 * 1024 * 64);
  this.replicationQueueNbCapacity=this.conf.getInt("replication.source.nb.capacity",25000);
  this.entriesArray=new HLog.Entry[this.replicationQueueNbCapacity];
  for (int i=0; i < this.replicationQueueNbCapacity; i++) {
    this.entriesArray[i]=new HLog.Entry();
  }
  this.maxRetriesMultiplier=this.conf.getInt("replication.source.maxretriesmultiplier",10);
  this.socketTimeoutMultiplier=maxRetriesMultiplier * maxRetriesMultiplier;
  this.queue=new PriorityBlockingQueue<Path>(conf.getInt("hbase.regionserver.maxlogs",32),new LogsComparator());
  this.conn=HConnectionManager.getConnection(conf);
  this.zkHelper=manager.getRepZkWrapper();
  this.ratio=this.conf.getFloat("replication.source.ratio",0.1f);
  this.currentPeers=new ArrayList<ServerName>();
  this.random=new Random();
  this.replicating=replicating;
  this.manager=manager;
  this.sleepForRetries=this.conf.getLong("replication.source.sleepforretries",1000);
  this.fs=fs;
  this.metrics=new ReplicationSourceMetrics(peerClusterZnode);
  try {
    this.clusterId=UUID.fromString(ClusterId.readClusterIdZNode(zkHelper.getZookeeperWatcher()));
  }
 catch (  KeeperException ke) {
    throw new IOException("Could not read cluster id",ke);
  }
  this.checkIfQueueRecovered(peerClusterZnode);
}
