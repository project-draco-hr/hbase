{
  connectToPeers();
  if (this.stopper.isStopped()) {
    return;
  }
  if (this.queueRecovered) {
    try {
      this.position=this.zkHelper.getHLogRepPosition(this.peerClusterZnode,this.queue.peek().getName());
    }
 catch (    KeeperException e) {
      LOG.error("Couldn't get the position of this recovered queue " + peerClusterZnode,e);
      this.abort();
    }
  }
  int sleepMultiplier=1;
  while (!stopper.isStopped() && this.running) {
    if (!getNextPath()) {
      if (sleepForRetries("No log to process",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    if (!openReader(sleepMultiplier)) {
      sleepMultiplier=1;
      continue;
    }
    if (this.reader == null) {
      if (sleepForRetries("Unable to open a reader",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    boolean gotIOE=false;
    currentNbEntries=0;
    try {
      if (readAllEntriesToReplicateOrNextFile()) {
        continue;
      }
    }
 catch (    IOException ioe) {
      LOG.warn(peerClusterZnode + " Got: ",ioe);
      gotIOE=true;
      if (ioe.getCause() instanceof EOFException) {
        boolean considerDumping=false;
        if (this.queueRecovered) {
          try {
            FileStatus stat=this.fs.getFileStatus(this.currentPath);
            if (stat.getLen() == 0) {
              LOG.warn(peerClusterZnode + " Got EOF and the file was empty");
            }
            considerDumping=true;
          }
 catch (          IOException e) {
            LOG.warn(peerClusterZnode + " Got while getting file size: ",e);
          }
        }
 else         if (currentNbEntries != 0) {
          LOG.warn(peerClusterZnode + " Got EOF while reading, " + "looks like this file is broken? "+ currentPath);
          considerDumping=true;
          currentNbEntries=0;
        }
        if (considerDumping && sleepMultiplier == this.maxRetriesMultiplier && processEndOfFile()) {
          continue;
        }
      }
    }
 finally {
      try {
        if (this.currentPath != null && !gotIOE) {
          this.position=this.reader.getPosition();
        }
        if (this.reader != null) {
          this.reader.close();
        }
      }
 catch (      IOException e) {
        gotIOE=true;
        LOG.warn("Unable to finalize the tailing of a file",e);
      }
    }
    if (!stopper.isStopped() && (gotIOE || currentNbEntries == 0)) {
      if (sleepForRetries("Nothing to replicate",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    sleepMultiplier=1;
    shipEdits();
  }
  LOG.debug("Source exiting " + peerClusterId);
}
