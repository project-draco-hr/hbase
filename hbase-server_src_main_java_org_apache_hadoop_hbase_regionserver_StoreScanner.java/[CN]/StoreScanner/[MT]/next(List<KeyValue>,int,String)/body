{
  if (checkReseek()) {
    return true;
  }
  if (this.heap == null) {
    close();
    return false;
  }
  KeyValue peeked=this.heap.peek();
  if (peeked == null) {
    close();
    return false;
  }
  if ((matcher.row == null) || !peeked.matchingRow(matcher.row)) {
    this.countPerRow=0;
    matcher.setRow(peeked.getRow());
  }
  KeyValue kv;
  KeyValue prevKV=null;
  List<KeyValue> results=new ArrayList<KeyValue>();
  KeyValue.KVComparator comparator=store != null ? store.getComparator() : null;
  LOOP:   while ((kv=this.heap.peek()) != null) {
    if (prevKV != null && comparator != null && comparator.compare(prevKV,kv) > 0) {
      throw new IOException("Key " + prevKV + " followed by a "+ "smaller key "+ kv+ " in cf "+ store);
    }
    prevKV=kv;
    ScanQueryMatcher.MatchCode qcode=matcher.match(kv);
switch (qcode) {
case INCLUDE:
case INCLUDE_AND_SEEK_NEXT_ROW:
case INCLUDE_AND_SEEK_NEXT_COL:
      Filter f=matcher.getFilter();
    if (f != null) {
      kv=f.transform(kv);
    }
  this.countPerRow++;
if (storeLimit > -1 && this.countPerRow > (storeLimit + storeOffset)) {
  if (!matcher.moreRowsMayExistAfter(kv)) {
    outResult.addAll(results);
    return false;
  }
  reseek(matcher.getKeyForNextRow(kv));
  break LOOP;
}
if (this.countPerRow > storeOffset) {
if (metric != null) {
  RegionMetricsStorage.incrNumericMetric(this.metricNamePrefix + metric,kv.getLength());
}
results.add(kv);
}
if (qcode == ScanQueryMatcher.MatchCode.INCLUDE_AND_SEEK_NEXT_ROW) {
if (!matcher.moreRowsMayExistAfter(kv)) {
outResult.addAll(results);
return false;
}
reseek(matcher.getKeyForNextRow(kv));
}
 else if (qcode == ScanQueryMatcher.MatchCode.INCLUDE_AND_SEEK_NEXT_COL) {
reseek(matcher.getKeyForNextColumn(kv));
}
 else {
this.heap.next();
}
if (limit > 0 && (results.size() == limit)) {
break LOOP;
}
continue;
case DONE:
outResult.addAll(results);
return true;
case DONE_SCAN:
close();
outResult.addAll(results);
return false;
case SEEK_NEXT_ROW:
if (!matcher.moreRowsMayExistAfter(kv)) {
outResult.addAll(results);
return false;
}
reseek(matcher.getKeyForNextRow(kv));
break;
case SEEK_NEXT_COL:
reseek(matcher.getKeyForNextColumn(kv));
break;
case SKIP:
this.heap.next();
break;
case SEEK_NEXT_USING_HINT:
KeyValue nextKV=matcher.getNextKeyHint(kv);
if (nextKV != null) {
reseek(nextKV);
}
 else {
heap.next();
}
break;
default :
throw new RuntimeException("UNEXPECTED");
}
}
if (!results.isEmpty()) {
outResult.addAll(results);
return true;
}
close();
return false;
}
