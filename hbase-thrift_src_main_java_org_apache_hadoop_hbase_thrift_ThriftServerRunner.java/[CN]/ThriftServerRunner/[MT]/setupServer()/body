{
  TProtocolFactory protocolFactory;
  if (conf.getBoolean(COMPACT_CONF_KEY,false)) {
    LOG.debug("Using compact protocol");
    protocolFactory=new TCompactProtocol.Factory();
  }
 else {
    LOG.debug("Using binary protocol");
    protocolFactory=new TBinaryProtocol.Factory();
  }
  Hbase.Processor<Hbase.Iface> processor=new Hbase.Processor<Hbase.Iface>(handler);
  ImplType implType=ImplType.getServerImpl(conf);
  TTransportFactory transportFactory;
  if (conf.getBoolean(FRAMED_CONF_KEY,false) || implType.isAlwaysFramed) {
    transportFactory=new TFramedTransport.Factory(conf.getInt(MAX_FRAME_SIZE_CONF_KEY,2) * 1024 * 1024);
    LOG.debug("Using framed transport");
  }
 else {
    transportFactory=new TTransportFactory();
  }
  if (conf.get(BIND_CONF_KEY) != null && !implType.canSpecifyBindIP) {
    LOG.error("Server types " + Joiner.on(", ").join(ImplType.serversThatCannotSpecifyBindIP()) + " don't support IP "+ "address binding at the moment. See "+ "https://issues.apache.org/jira/browse/HBASE-2155 for details.");
    throw new RuntimeException("-" + BIND_CONF_KEY + " not supported with "+ implType);
  }
  if (implType == ImplType.HS_HA || implType == ImplType.NONBLOCKING || implType == ImplType.THREADED_SELECTOR) {
    InetAddress listenAddress=getBindAddress(conf);
    TNonblockingServerTransport serverTransport=new TNonblockingServerSocket(new InetSocketAddress(listenAddress,listenPort));
    if (implType == ImplType.NONBLOCKING) {
      TNonblockingServer.Args serverArgs=new TNonblockingServer.Args(serverTransport);
      serverArgs.processor(processor).transportFactory(transportFactory).protocolFactory(protocolFactory);
      tserver=new TNonblockingServer(serverArgs);
    }
 else     if (implType == ImplType.HS_HA) {
      THsHaServer.Args serverArgs=new THsHaServer.Args(serverTransport);
      CallQueue callQueue=new CallQueue(new LinkedBlockingQueue<Call>(),metrics);
      ExecutorService executorService=createExecutor(callQueue,serverArgs.getWorkerThreads());
      serverArgs.executorService(executorService).processor(processor).transportFactory(transportFactory).protocolFactory(protocolFactory);
      tserver=new THsHaServer(serverArgs);
    }
 else {
      TThreadedSelectorServer.Args serverArgs=new HThreadedSelectorServerArgs(serverTransport,conf);
      CallQueue callQueue=new CallQueue(new LinkedBlockingQueue<Call>(),metrics);
      ExecutorService executorService=createExecutor(callQueue,serverArgs.getWorkerThreads());
      serverArgs.executorService(executorService).processor(processor).transportFactory(transportFactory).protocolFactory(protocolFactory);
      tserver=new TThreadedSelectorServer(serverArgs);
    }
    LOG.info("starting HBase " + implType.simpleClassName() + " server on "+ Integer.toString(listenPort));
  }
 else   if (implType == ImplType.THREAD_POOL) {
    InetAddress listenAddress=getBindAddress(conf);
    TServerTransport serverTransport=new TServerSocket(new InetSocketAddress(listenAddress,listenPort));
    TBoundedThreadPoolServer.Args serverArgs=new TBoundedThreadPoolServer.Args(serverTransport,conf);
    serverArgs.processor(processor).transportFactory(transportFactory).protocolFactory(protocolFactory);
    LOG.info("starting " + ImplType.THREAD_POOL.simpleClassName() + " on "+ listenAddress+ ":"+ Integer.toString(listenPort)+ "; "+ serverArgs);
    TBoundedThreadPoolServer tserver=new TBoundedThreadPoolServer(serverArgs,metrics);
    this.tserver=tserver;
  }
 else {
    throw new AssertionError("Unsupported Thrift server implementation: " + implType.simpleClassName());
  }
  if (tserver.getClass() != implType.serverClass) {
    throw new AssertionError("Expected to create Thrift server class " + implType.serverClass.getName() + " but got "+ tserver.getClass().getName());
  }
  registerFilters(conf);
}
