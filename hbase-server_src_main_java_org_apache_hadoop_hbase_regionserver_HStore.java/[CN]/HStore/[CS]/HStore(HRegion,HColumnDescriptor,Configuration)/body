{
  this.fs=region.getRegionFileSystem();
  fs.createStoreDir(family.getNameAsString());
  this.region=region;
  this.family=family;
  this.conf=new CompoundConfiguration().add(confParam).addStringMap(region.getTableDesc().getConfiguration()).addStringMap(family.getConfiguration()).addBytesMap(family.getValues());
  this.blocksize=family.getBlocksize();
  this.dataBlockEncoder=new HFileDataBlockEncoderImpl(family.getDataBlockEncoding());
  this.comparator=region.getCellCompartor();
  long timeToPurgeDeletes=Math.max(conf.getLong("hbase.hstore.time.to.purge.deletes",0),0);
  LOG.trace("Time to purge deletes set to " + timeToPurgeDeletes + "ms in store "+ this);
  long ttl=determineTTLFromFamily(family);
  scanInfo=new ScanInfo(conf,family,ttl,timeToPurgeDeletes,this.comparator);
  String className=conf.get(MEMSTORE_CLASS_NAME,DefaultMemStore.class.getName());
  this.memstore=ReflectionUtils.instantiateWithCustomCtor(className,new Class[]{Configuration.class,CellComparator.class},new Object[]{conf,this.comparator});
  this.offPeakHours=OffPeakHours.getInstance(conf);
  createCacheConf(family);
  this.verifyBulkLoads=conf.getBoolean("hbase.hstore.bulkload.verify",false);
  this.blockingFileCount=conf.getInt(BLOCKING_STOREFILES_KEY,DEFAULT_BLOCKING_STOREFILE_COUNT);
  this.compactionCheckMultiplier=conf.getInt(COMPACTCHECKER_INTERVAL_MULTIPLIER_KEY,DEFAULT_COMPACTCHECKER_INTERVAL_MULTIPLIER);
  if (this.compactionCheckMultiplier <= 0) {
    LOG.error("Compaction check period multiplier must be positive, setting default: " + DEFAULT_COMPACTCHECKER_INTERVAL_MULTIPLIER);
    this.compactionCheckMultiplier=DEFAULT_COMPACTCHECKER_INTERVAL_MULTIPLIER;
  }
  if (HStore.closeCheckInterval == 0) {
    HStore.closeCheckInterval=conf.getInt("hbase.hstore.close.check.interval",10 * 1000 * 1000);
  }
  this.storeEngine=createStoreEngine(this,this.conf,this.comparator);
  this.storeEngine.getStoreFileManager().loadFiles(loadStoreFiles());
  this.checksumType=getChecksumType(conf);
  this.bytesPerChecksum=getBytesPerChecksum(conf);
  flushRetriesNumber=conf.getInt("hbase.hstore.flush.retries.number",DEFAULT_FLUSH_RETRIES_NUMBER);
  pauseTime=conf.getInt(HConstants.HBASE_SERVER_PAUSE,HConstants.DEFAULT_HBASE_SERVER_PAUSE);
  if (flushRetriesNumber <= 0) {
    throw new IllegalArgumentException("hbase.hstore.flush.retries.number must be > 0, not " + flushRetriesNumber);
  }
  String cipherName=family.getEncryptionType();
  if (cipherName != null) {
    Cipher cipher;
    Key key;
    byte[] keyBytes=family.getEncryptionKey();
    if (keyBytes != null) {
      String masterKeyName=conf.get(HConstants.CRYPTO_MASTERKEY_NAME_CONF_KEY,User.getCurrent().getShortName());
      try {
        key=EncryptionUtil.unwrapKey(conf,masterKeyName,keyBytes);
      }
 catch (      KeyException e) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Unable to unwrap key with current master key '" + masterKeyName + "'");
        }
        String alternateKeyName=conf.get(HConstants.CRYPTO_MASTERKEY_ALTERNATE_NAME_CONF_KEY);
        if (alternateKeyName != null) {
          try {
            key=EncryptionUtil.unwrapKey(conf,alternateKeyName,keyBytes);
          }
 catch (          KeyException ex) {
            throw new IOException(ex);
          }
        }
 else {
          throw new IOException(e);
        }
      }
      cipher=Encryption.getCipher(conf,key.getAlgorithm());
      if (cipher == null) {
        throw new RuntimeException("Cipher '" + key.getAlgorithm() + "' is not available");
      }
      if (!cipher.getName().equalsIgnoreCase(cipherName)) {
        throw new RuntimeException("Encryption for family '" + family.getNameAsString() + "' configured with type '"+ cipherName+ "' but key specifies algorithm '"+ cipher.getName()+ "'");
      }
    }
 else {
      cipher=Encryption.getCipher(conf,cipherName);
      if (cipher == null) {
        throw new RuntimeException("Cipher '" + cipherName + "' is not available");
      }
      key=cipher.getRandomKey();
    }
    cryptoContext=Encryption.newContext(conf);
    cryptoContext.setCipher(cipher);
    cryptoContext.setKey(key);
  }
}
