{
  long ttlToUse=scanInfo.getMinVersions() > 0 ? Long.MAX_VALUE : this.scanInfo.getTtl();
  KeyValue kv=new KeyValue(row,HConstants.LATEST_TIMESTAMP);
  GetClosestRowBeforeTracker state=new GetClosestRowBeforeTracker(this.comparator,kv,ttlToUse,this.getRegionInfo().isMetaRegion());
  this.lock.readLock().lock();
  try {
    this.memstore.getRowKeyAtOrBefore(state);
    Iterator<StoreFile> sfIterator=this.storeEngine.getStoreFileManager().getCandidateFilesForRowKeyBefore(state.getTargetKey());
    while (sfIterator.hasNext()) {
      StoreFile sf=sfIterator.next();
      sfIterator.remove();
      boolean haveNewCandidate=rowAtOrBeforeFromStoreFile(sf,state);
      KeyValue keyv=KeyValueUtil.ensureKeyValue(state.getCandidate());
      if (keyv != null && CellUtil.matchingRow(keyv,row)) {
        return KeyValueUtil.ensureKeyValue(state.getCandidate());
      }
      if (haveNewCandidate) {
        sfIterator=this.storeEngine.getStoreFileManager().updateCandidateFilesForRowKeyBefore(sfIterator,state.getTargetKey(),KeyValueUtil.ensureKeyValue(state.getCandidate()));
      }
    }
    return KeyValueUtil.ensureKeyValue(state.getCandidate());
  }
  finally {
    this.lock.readLock().unlock();
  }
}
