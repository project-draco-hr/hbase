{
  List<StoreFile> filesToCompact;
  boolean isMajor;
  this.lock.readLock().lock();
  try {
synchronized (filesCompacting) {
      filesToCompact=Lists.newArrayList(storefiles);
      if (!filesCompacting.isEmpty()) {
        StoreFile last=filesCompacting.get(filesCompacting.size() - 1);
        int idx=filesToCompact.indexOf(last);
        Preconditions.checkArgument(idx != -1);
        filesToCompact.subList(0,idx + 1).clear();
      }
      int count=filesToCompact.size();
      if (N > count) {
        throw new RuntimeException("Not enough files");
      }
      filesToCompact=filesToCompact.subList(count - N,count);
      isMajor=(filesToCompact.size() == storefiles.size());
      filesCompacting.addAll(filesToCompact);
      Collections.sort(filesCompacting,StoreFile.Comparators.SEQ_ID);
    }
  }
  finally {
    this.lock.readLock().unlock();
  }
  try {
    List<Path> newFiles=this.compactor.compact(filesToCompact,isMajor);
    for (    Path newFile : newFiles) {
      StoreFile sf=completeCompaction(filesToCompact,newFile);
      if (region.getCoprocessorHost() != null) {
        region.getCoprocessorHost().postCompact(this,sf);
      }
    }
  }
  finally {
synchronized (filesCompacting) {
      filesCompacting.removeAll(filesToCompact);
    }
  }
}
