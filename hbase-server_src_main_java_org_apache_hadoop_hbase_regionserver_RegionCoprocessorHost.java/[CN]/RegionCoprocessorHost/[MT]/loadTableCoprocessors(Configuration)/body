{
  List<RegionEnvironment> configured=new ArrayList<RegionEnvironment>();
  for (  Map.Entry<ImmutableBytesWritable,ImmutableBytesWritable> e : region.getTableDesc().getValues().entrySet()) {
    String key=Bytes.toString(e.getKey().get()).trim();
    String spec=Bytes.toString(e.getValue().get()).trim();
    if (HConstants.CP_HTD_ATTR_KEY_PATTERN.matcher(key).matches()) {
      try {
        Matcher matcher=HConstants.CP_HTD_ATTR_VALUE_PATTERN.matcher(spec);
        if (matcher.matches()) {
          Path path=matcher.group(1).trim().isEmpty() ? null : new Path(matcher.group(1).trim());
          String className=matcher.group(2).trim();
          int priority=matcher.group(3).trim().isEmpty() ? Coprocessor.PRIORITY_USER : Integer.valueOf(matcher.group(3));
          String cfgSpec=null;
          try {
            cfgSpec=matcher.group(4);
          }
 catch (          IndexOutOfBoundsException ex) {
          }
          if (cfgSpec != null) {
            cfgSpec=cfgSpec.substring(cfgSpec.indexOf('|') + 1);
            Configuration newConf=new Configuration(false);
            HBaseConfiguration.merge(newConf,conf);
            Matcher m=HConstants.CP_HTD_ATTR_VALUE_PARAM_PATTERN.matcher(cfgSpec);
            while (m.find()) {
              newConf.set(m.group(1),m.group(2));
            }
            configured.add(load(path,className,priority,newConf));
          }
 else {
            configured.add(load(path,className,priority,conf));
          }
          LOG.info("Load coprocessor " + className + " from HTD of "+ Bytes.toString(region.getTableDesc().getName())+ " successfully.");
        }
 else {
          throw new RuntimeException("specification does not match pattern");
        }
      }
 catch (      Exception ex) {
        LOG.warn("attribute '" + key + "' has invalid coprocessor specification '"+ spec+ "'");
        LOG.warn(StringUtils.stringifyException(ex));
      }
    }
  }
  coprocessors.addAll(configured);
}
