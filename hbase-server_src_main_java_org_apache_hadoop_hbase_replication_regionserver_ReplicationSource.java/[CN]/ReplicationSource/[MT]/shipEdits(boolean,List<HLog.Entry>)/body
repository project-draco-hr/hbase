{
  int sleepMultiplier=1;
  if (entries.isEmpty()) {
    LOG.warn("Was given 0 edits to ship");
    return;
  }
  while (this.isActive()) {
    if (!isPeerEnabled()) {
      if (sleepForRetries("Replication is disabled",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    SinkPeer sinkPeer=null;
    try {
      if (this.throttler.isEnabled()) {
        long sleepTicks=this.throttler.getNextSleepInterval(currentSize);
        if (sleepTicks > 0) {
          try {
            if (LOG.isTraceEnabled()) {
              LOG.trace("To sleep " + sleepTicks + "ms for throttling control");
            }
            Thread.sleep(sleepTicks);
          }
 catch (          InterruptedException e) {
            LOG.debug("Interrupted while sleeping for throttling control");
            Thread.currentThread().interrupt();
            continue;
          }
          this.throttler.resetStartTick();
        }
      }
      sinkPeer=replicationSinkMgr.getReplicationSink();
      BlockingInterface rrs=sinkPeer.getRegionServer();
      if (LOG.isTraceEnabled()) {
        LOG.trace("Replicating " + entries.size() + " entries of total size "+ currentSize);
      }
      ReplicationProtbufUtil.replicateWALEntry(rrs,entries.toArray(new HLog.Entry[entries.size()]));
      if (this.lastLoggedPosition != this.repLogReader.getPosition()) {
        this.manager.logPositionAndCleanOldLogs(this.currentPath,this.peerClusterZnode,this.repLogReader.getPosition(),this.replicationQueueInfo.isQueueRecovered(),currentWALisBeingWrittenTo);
        this.lastLoggedPosition=this.repLogReader.getPosition();
      }
      if (this.throttler.isEnabled()) {
        this.throttler.addPushSize(currentSize);
      }
      this.totalReplicatedEdits+=entries.size();
      this.totalReplicatedOperations+=currentNbOperations;
      this.metrics.shipBatch(this.currentNbOperations,this.currentSize / 1024);
      this.metrics.setAgeOfLastShippedOp(entries.get(entries.size() - 1).getKey().getWriteTime());
      if (LOG.isTraceEnabled()) {
        LOG.trace("Replicated " + this.totalReplicatedEdits + " entries in total, or "+ this.totalReplicatedOperations+ " operations");
      }
      break;
    }
 catch (    IOException ioe) {
      this.metrics.refreshAgeOfLastShippedOp();
      if (ioe instanceof RemoteException) {
        ioe=((RemoteException)ioe).unwrapRemoteException();
        LOG.warn("Can't replicate because of an error on the remote cluster: ",ioe);
        if (ioe instanceof TableNotFoundException) {
          if (sleepForRetries("A table is missing in the peer cluster. " + "Replication cannot proceed without losing data.",sleepMultiplier)) {
            sleepMultiplier++;
          }
          if (isInterrupted()) {
            continue;
          }
        }
      }
 else {
        if (ioe instanceof SocketTimeoutException) {
          sleepForRetries("Encountered a SocketTimeoutException. Since the " + "call to the remote cluster timed out, which is usually " + "caused by a machine failure or a massive slowdown",this.socketTimeoutMultiplier);
          if (isInterrupted()) {
            continue;
          }
        }
 else         if (ioe instanceof ConnectException) {
          LOG.warn("Peer is unavailable, rechecking all sinks: ",ioe);
          replicationSinkMgr.chooseSinks();
        }
 else {
          LOG.warn("Can't replicate because of a local or network error: ",ioe);
        }
      }
      if (sinkPeer != null) {
        replicationSinkMgr.reportBadSink(sinkPeer);
      }
      if (sleepForRetries("Since we are unable to replicate",sleepMultiplier)) {
        sleepMultiplier++;
      }
    }
  }
}
