{
  connectToPeers();
  if (!this.isActive()) {
    metrics.clear();
    return;
  }
  try {
    this.peerClusterId=UUID.fromString(ZKClusterId.readClusterIdZNode(zkHelper.getPeerClusters().get(peerId).getZkw()));
  }
 catch (  KeeperException ke) {
    this.terminate("Could not read peer's cluster id",ke);
  }
  LOG.info("Replicating " + clusterId + " -> "+ peerClusterId);
  if (this.queueRecovered) {
    try {
      this.position=this.zkHelper.getHLogRepPosition(this.peerClusterZnode,this.queue.peek().getName());
    }
 catch (    KeeperException e) {
      this.terminate("Couldn't get the position of this recovered queue " + peerClusterZnode,e);
    }
  }
  int sleepMultiplier=1;
  while (isActive()) {
    if (!isPeerEnabled()) {
      if (sleepForRetries("Replication is disabled",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    if (!getNextPath()) {
      if (sleepForRetries("No log to process",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    if (!openReader(sleepMultiplier)) {
      sleepMultiplier=1;
      continue;
    }
    if (this.reader == null) {
      if (sleepForRetries("Unable to open a reader",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    boolean gotIOE=false;
    currentNbEntries=0;
    try {
      if (readAllEntriesToReplicateOrNextFile()) {
        continue;
      }
    }
 catch (    IOException ioe) {
      LOG.warn(peerClusterZnode + " Got: ",ioe);
      gotIOE=true;
      if (ioe.getCause() instanceof EOFException) {
        boolean considerDumping=false;
        if (this.queueRecovered) {
          try {
            FileStatus stat=this.fs.getFileStatus(this.currentPath);
            if (stat.getLen() == 0) {
              LOG.warn(peerClusterZnode + " Got EOF and the file was empty");
            }
            considerDumping=true;
          }
 catch (          IOException e) {
            LOG.warn(peerClusterZnode + " Got while getting file size: ",e);
          }
        }
 else         if (currentNbEntries != 0) {
          LOG.warn(peerClusterZnode + " Got EOF while reading, " + "looks like this file is broken? "+ currentPath);
          considerDumping=true;
          currentNbEntries=0;
        }
        if (considerDumping && sleepMultiplier == this.maxRetriesMultiplier && processEndOfFile()) {
          continue;
        }
      }
    }
 finally {
      try {
        if (this.currentPath != null && !gotIOE) {
          this.position=this.reader.getPosition();
        }
        if (this.reader != null) {
          this.reader.close();
        }
      }
 catch (      IOException e) {
        gotIOE=true;
        LOG.warn("Unable to finalize the tailing of a file",e);
      }
    }
    if (this.isActive() && (gotIOE || currentNbEntries == 0)) {
      if (this.lastLoggedPosition != this.position) {
        this.manager.logPositionAndCleanOldLogs(this.currentPath,this.peerClusterZnode,this.position,queueRecovered);
        this.lastLoggedPosition=this.position;
      }
      if (sleepForRetries("Nothing to replicate",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    sleepMultiplier=1;
    shipEdits();
  }
  if (this.conn != null) {
    try {
      this.conn.close();
    }
 catch (    IOException e) {
      LOG.debug("Attempt to close connection failed",e);
    }
  }
  LOG.debug("Source exiting " + peerId);
  metrics.clear();
}
