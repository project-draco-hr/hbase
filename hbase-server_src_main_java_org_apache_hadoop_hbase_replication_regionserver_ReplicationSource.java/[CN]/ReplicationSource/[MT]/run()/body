{
  connectToPeers();
  if (!this.isActive()) {
    metrics.clear();
    return;
  }
  int sleepMultiplier=1;
  while (this.peerClusterId == null) {
    this.peerClusterId=zkHelper.getPeerUUID(this.peerId);
    if (this.peerClusterId == null) {
      if (sleepForRetries("Cannot contact the peer's zk ensemble",sleepMultiplier)) {
        sleepMultiplier++;
      }
    }
  }
  sleepMultiplier=1;
  LOG.info("Replicating " + clusterId + " -> "+ peerClusterId);
  if (this.replicationQueueInfo.isQueueRecovered()) {
    try {
      this.repLogReader.setPosition(this.zkHelper.getHLogRepPosition(this.peerClusterZnode,this.queue.peek().getName()));
    }
 catch (    KeeperException e) {
      this.terminate("Couldn't get the position of this recovered queue " + this.peerClusterZnode,e);
    }
  }
  while (isActive()) {
    if (!isPeerEnabled()) {
      if (sleepForRetries("Replication is disabled",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    Path oldPath=getCurrentPath();
    boolean hasCurrentPath=getNextPath();
    if (getCurrentPath() != null && oldPath == null) {
      sleepMultiplier=1;
    }
    if (!hasCurrentPath) {
      if (sleepForRetries("No log to process",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    boolean currentWALisBeingWrittenTo=false;
    if (!this.replicationQueueInfo.isQueueRecovered() && queue.size() == 0) {
      currentWALisBeingWrittenTo=true;
    }
    if (!openReader(sleepMultiplier)) {
      sleepMultiplier=1;
      continue;
    }
    if (this.reader == null) {
      if (sleepForRetries("Unable to open a reader",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    boolean gotIOE=false;
    currentNbOperations=0;
    currentNbEntries=0;
    currentSize=0;
    try {
      if (readAllEntriesToReplicateOrNextFile(currentWALisBeingWrittenTo)) {
        continue;
      }
    }
 catch (    IOException ioe) {
      LOG.warn(this.peerClusterZnode + " Got: ",ioe);
      gotIOE=true;
      if (ioe.getCause() instanceof EOFException) {
        boolean considerDumping=false;
        if (this.replicationQueueInfo.isQueueRecovered()) {
          try {
            FileStatus stat=this.fs.getFileStatus(this.currentPath);
            if (stat.getLen() == 0) {
              LOG.warn(this.peerClusterZnode + " Got EOF and the file was empty");
            }
            considerDumping=true;
          }
 catch (          IOException e) {
            LOG.warn(this.peerClusterZnode + " Got while getting file size: ",e);
          }
        }
 else         if (currentNbEntries != 0) {
          LOG.warn(this.peerClusterZnode + " Got EOF while reading, " + "looks like this file is broken? "+ currentPath);
          considerDumping=true;
          currentNbEntries=0;
        }
        if (considerDumping && sleepMultiplier == this.maxRetriesMultiplier && processEndOfFile()) {
          continue;
        }
      }
    }
 finally {
      try {
        this.reader=null;
        this.repLogReader.closeReader();
      }
 catch (      IOException e) {
        gotIOE=true;
        LOG.warn("Unable to finalize the tailing of a file",e);
      }
    }
    if (this.isActive() && (gotIOE || currentNbEntries == 0)) {
      if (this.lastLoggedPosition != this.repLogReader.getPosition()) {
        this.manager.logPositionAndCleanOldLogs(this.currentPath,this.peerClusterZnode,this.repLogReader.getPosition(),this.replicationQueueInfo.isQueueRecovered(),currentWALisBeingWrittenTo);
        this.lastLoggedPosition=this.repLogReader.getPosition();
      }
      if (sleepForRetries("Nothing to replicate",sleepMultiplier)) {
        sleepMultiplier++;
      }
      continue;
    }
    sleepMultiplier=1;
    shipEdits(currentWALisBeingWrittenTo);
  }
  if (this.conn != null) {
    try {
      this.conn.close();
    }
 catch (    IOException e) {
      LOG.debug("Attempt to close connection failed",e);
    }
  }
  LOG.debug("Source exiting " + this.peerId);
  metrics.clear();
}
