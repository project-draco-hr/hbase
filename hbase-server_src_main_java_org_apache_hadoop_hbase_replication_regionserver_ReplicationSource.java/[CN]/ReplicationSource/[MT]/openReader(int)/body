{
  try {
    LOG.debug("Opening log for replication " + this.currentPath.getName() + " at "+ this.position);
    try {
      this.reader=null;
      this.reader=HLogFactory.createReader(this.fs,this.currentPath,this.conf);
    }
 catch (    FileNotFoundException fnfe) {
      if (this.queueRecovered) {
        LOG.info("NB dead servers : " + deadRegionServers.length);
        for (int i=this.deadRegionServers.length - 1; i >= 0; i--) {
          Path deadRsDirectory=new Path(manager.getLogDir().getParent(),this.deadRegionServers[i]);
          Path[] locs=new Path[]{new Path(deadRsDirectory,currentPath.getName()),new Path(deadRsDirectory.suffix(HLog.SPLITTING_EXT),currentPath.getName())};
          for (          Path possibleLogLocation : locs) {
            LOG.info("Possible location " + possibleLogLocation.toUri().toString());
            if (this.manager.getFs().exists(possibleLogLocation)) {
              LOG.info("Log " + this.currentPath + " still exists at "+ possibleLogLocation);
              return true;
            }
          }
        }
        throw new IOException("File from recovered queue is " + "nowhere to be found",fnfe);
      }
 else {
        Path archivedLogLocation=new Path(manager.getOldLogDir(),currentPath.getName());
        if (this.manager.getFs().exists(archivedLogLocation)) {
          currentPath=archivedLogLocation;
          LOG.info("Log " + this.currentPath + " was moved to "+ archivedLogLocation);
          this.openReader(sleepMultiplier);
        }
      }
    }
  }
 catch (  IOException ioe) {
    LOG.warn(peerClusterZnode + " Got: ",ioe);
    if (sleepMultiplier == this.maxRetriesMultiplier) {
      LOG.warn("Waited too long for this file, considering dumping");
      return !processEndOfFile();
    }
  }
  return true;
}
