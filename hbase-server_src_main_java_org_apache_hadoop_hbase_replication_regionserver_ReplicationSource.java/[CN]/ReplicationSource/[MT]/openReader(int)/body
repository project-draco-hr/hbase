{
  try {
    try {
      this.reader=repLogReader.openReader(this.currentPath);
    }
 catch (    FileNotFoundException fnfe) {
      if (this.replicationQueueInfo.isQueueRecovered()) {
        List<String> deadRegionServers=this.replicationQueueInfo.getDeadRegionServers();
        LOG.info("NB dead servers : " + deadRegionServers.size());
        for (        String curDeadServerName : deadRegionServers) {
          Path deadRsDirectory=new Path(manager.getLogDir().getParent(),curDeadServerName);
          Path[] locs=new Path[]{new Path(deadRsDirectory,currentPath.getName()),new Path(deadRsDirectory.suffix(HLog.SPLITTING_EXT),currentPath.getName())};
          for (          Path possibleLogLocation : locs) {
            LOG.info("Possible location " + possibleLogLocation.toUri().toString());
            if (this.manager.getFs().exists(possibleLogLocation)) {
              LOG.info("Log " + this.currentPath + " still exists at "+ possibleLogLocation);
              return true;
            }
          }
        }
        throw new IOException("File from recovered queue is " + "nowhere to be found",fnfe);
      }
 else {
        Path archivedLogLocation=new Path(manager.getOldLogDir(),currentPath.getName());
        if (this.manager.getFs().exists(archivedLogLocation)) {
          currentPath=archivedLogLocation;
          LOG.info("Log " + this.currentPath + " was moved to "+ archivedLogLocation);
          this.openReader(sleepMultiplier);
        }
      }
    }
  }
 catch (  IOException ioe) {
    if (ioe instanceof EOFException && isCurrentLogEmpty())     return true;
    LOG.warn(this.peerClusterZnode + " Got: ",ioe);
    this.reader=null;
    if (ioe.getCause() instanceof NullPointerException) {
      LOG.warn("Got NPE opening reader, will retry.");
    }
 else     if (sleepMultiplier == this.maxRetriesMultiplier) {
      LOG.warn("Waited too long for this file, considering dumping");
      return !processEndOfFile();
    }
  }
  return true;
}
