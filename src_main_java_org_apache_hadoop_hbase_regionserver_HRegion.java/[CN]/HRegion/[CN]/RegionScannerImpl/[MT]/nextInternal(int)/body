{
  while (true) {
    byte[] currentRow=peekRow();
    if (isStopRow(currentRow)) {
      if (filter != null && filter.hasFilterRow()) {
        filter.filterRow(results);
      }
      if (filter != null && filter.filterRow()) {
        results.clear();
      }
      return false;
    }
 else     if (filterRowKey(currentRow)) {
      nextRow(currentRow);
    }
 else {
      byte[] nextRow;
      do {
        this.storeHeap.next(results,limit - results.size());
        if (limit > 0 && results.size() == limit) {
          if (this.filter != null && filter.hasFilterRow()) {
            throw new IncompatibleFilterException("Filter with filterRow(List<KeyValue>) incompatible with scan with limit!");
          }
          return true;
        }
      }
 while (Bytes.equals(currentRow,nextRow=peekRow()));
      final boolean stopRow=isStopRow(nextRow);
      if (filter != null && filter.hasFilterRow()) {
        filter.filterRow(results);
      }
      if (results.isEmpty() || filterRow()) {
        nextRow(currentRow);
        if (!stopRow)         continue;
      }
      return !stopRow;
    }
  }
}
