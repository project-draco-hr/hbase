{
  final long startTime=EnvironmentEdgeManager.currentTimeMillis();
  this.lastFlushTime=startTime;
  if (this.memstoreSize.get() <= 0) {
    return false;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Started memstore flush for " + this + ", current region memstore size "+ StringUtils.humanReadableInt(this.memstoreSize.get())+ ((wal != null) ? "" : "; wal is null, using passed sequenceid=" + myseqid));
  }
  long sequenceId=-1L;
  long completeSequenceId=-1L;
  ReadWriteConsistencyControl.WriteEntry w=null;
  status.setStatus("Obtaining lock to block concurrent updates");
  this.updatesLock.writeLock().lock();
  status.setStatus("Preparing to flush by snapshotting stores");
  long currentMemStoreSize=0;
  List<StoreFlusher> storeFlushers=new ArrayList<StoreFlusher>(stores.size());
  try {
    w=rwcc.beginMemstoreInsert();
    rwcc.advanceMemstore(w);
    sequenceId=(wal == null) ? myseqid : wal.startCacheFlush(this.regionInfo.getEncodedNameAsBytes());
    completeSequenceId=this.getCompleteCacheFlushSequenceId(sequenceId);
    for (    Store s : stores.values()) {
      storeFlushers.add(s.getStoreFlusher(completeSequenceId));
    }
    for (    StoreFlusher flusher : storeFlushers) {
      flusher.prepare();
    }
  }
  finally {
    this.updatesLock.writeLock().unlock();
  }
  status.setStatus("Waiting for rwcc");
  LOG.debug("Finished snapshotting, commencing waiting for rwcc");
  rwcc.waitForRead(w);
  status.setStatus("Flushing stores");
  LOG.debug("Finished snapshotting, commencing flushing stores");
  boolean compactionRequested=false;
  try {
    for (    StoreFlusher flusher : storeFlushers) {
      flusher.flushCache(status);
    }
    for (    StoreFlusher flusher : storeFlushers) {
      boolean needsCompaction=flusher.commit(status);
      if (needsCompaction) {
        compactionRequested=true;
      }
    }
    storeFlushers.clear();
    currentMemStoreSize=this.addAndGetGlobalMemstoreSize(-this.memstoreSize.get());
  }
 catch (  Throwable t) {
    if (wal != null) {
      wal.abortCacheFlush(this.regionInfo.getEncodedNameAsBytes());
    }
    DroppedSnapshotException dse=new DroppedSnapshotException("region: " + Bytes.toStringBinary(getRegionName()));
    dse.initCause(t);
    status.abort("Flush failed: " + StringUtils.stringifyException(t));
    throw dse;
  }
  if (wal != null) {
    wal.completeCacheFlush(this.regionInfo.getEncodedNameAsBytes(),regionInfo.getTableName(),completeSequenceId,this.getRegionInfo().isMetaRegion());
  }
synchronized (this) {
    notifyAll();
  }
  long time=EnvironmentEdgeManager.currentTimeMillis() - startTime;
  String msg="Finished memstore flush of ~" + StringUtils.humanReadableInt(currentMemStoreSize) + " for region "+ this+ " in "+ time+ "ms, sequenceid="+ sequenceId+ ", compaction requested="+ compactionRequested+ ((wal == null) ? "; wal=null" : "");
  LOG.info(msg);
  status.setStatus(msg);
  this.recentFlushes.add(new Pair<Long,Long>(time / 1000,currentMemStoreSize));
  return compactionRequested;
}
