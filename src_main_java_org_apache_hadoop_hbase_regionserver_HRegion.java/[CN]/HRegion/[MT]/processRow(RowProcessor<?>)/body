{
  byte[] row=processor.getRow();
  checkRow(row,"processRow");
  if (!processor.readOnly()) {
    checkReadOnly();
  }
  checkResources();
  MultiVersionConsistencyControl.WriteEntry writeEntry=null;
  startRegionOperation();
  boolean locked=false;
  boolean walSyncSuccessful=false;
  Integer rowLockID=null;
  long addedSize=0;
  List<KeyValue> mutations=new ArrayList<KeyValue>();
  try {
    rowLockID=getLock(null,row,true);
    this.updatesLock.readLock().lock();
    locked=true;
    long now=EnvironmentEdgeManager.currentTimeMillis();
    try {
      WALEdit walEdits=new WALEdit();
      doProcessRowWithTimeout(processor,now,rowScanner,mutations,walEdits,rowProcessorTimeout);
      if (processor.readOnly() && !mutations.isEmpty()) {
        throw new IOException("Processor is readOnly but generating mutations on row:" + Bytes.toStringBinary(row));
      }
      if (!mutations.isEmpty()) {
        writeEntry=mvcc.beginMemstoreInsert();
        for (        KeyValue kv : mutations) {
          kv.setMemstoreTS(writeEntry.getWriteNumber());
          walEdits.add(kv);
          addedSize+=stores.get(kv.getFamily()).add(kv);
        }
        long txid=0;
        if (!walEdits.isEmpty()) {
          txid=this.log.appendNoSync(this.regionInfo,this.htableDescriptor.getName(),walEdits,processor.getClusterId(),now,this.htableDescriptor);
        }
        if (locked) {
          this.updatesLock.readLock().unlock();
          locked=false;
        }
        if (rowLockID != null) {
          releaseRowLock(rowLockID);
          rowLockID=null;
        }
        if (txid != 0) {
          this.log.sync(txid);
        }
        walSyncSuccessful=true;
      }
    }
  finally {
      if (!mutations.isEmpty() && !walSyncSuccessful) {
        LOG.warn("Wal sync failed. Roll back " + mutations.size() + " memstore keyvalues for row:"+ processor.getRow());
        for (        KeyValue kv : mutations) {
          stores.get(kv.getFamily()).rollback(kv);
        }
      }
      if (writeEntry != null) {
        mvcc.completeMemstoreInsert(writeEntry);
        writeEntry=null;
      }
      if (locked) {
        this.updatesLock.readLock().unlock();
        locked=false;
      }
      if (rowLockID != null) {
        releaseRowLock(rowLockID);
        rowLockID=null;
      }
    }
  }
  finally {
    closeRegionOperation();
    if (!mutations.isEmpty() && isFlushSize(this.addAndGetGlobalMemstoreSize(addedSize))) {
      requestFlush();
    }
  }
}
