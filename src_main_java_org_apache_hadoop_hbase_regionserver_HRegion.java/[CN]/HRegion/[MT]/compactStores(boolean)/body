{
  if (this.closing.get()) {
    LOG.debug("Skipping compaction on " + this + " because closing");
    return null;
  }
  lock.readLock().lock();
  this.lastCompactInfo=null;
  byte[] splitRow=null;
  try {
    if (this.closed.get()) {
      LOG.debug("Skipping compaction on " + this + " because closed");
      return null;
    }
    if (this.closed.get()) {
      return splitRow;
    }
    if (coprocessorHost != null) {
      coprocessorHost.preCompact(false);
    }
    try {
synchronized (writestate) {
        if (!writestate.compacting && writestate.writesEnabled) {
          writestate.compacting=true;
        }
 else {
          LOG.info("NOT compacting region " + this + ": compacting="+ writestate.compacting+ ", writesEnabled="+ writestate.writesEnabled);
          return splitRow;
        }
      }
      LOG.info("Starting" + (majorCompaction ? " major " : " ") + "compaction on region "+ this);
      long startTime=EnvironmentEdgeManager.currentTimeMillis();
      doRegionCompactionPrep();
      long lastCompactSize=0;
      long maxSize=-1;
      boolean completed=false;
      try {
        for (        Store store : stores.values()) {
          final Store.StoreSize ss=store.compact(majorCompaction);
          lastCompactSize+=store.getLastCompactSize();
          if (ss != null && ss.getSize() > maxSize) {
            maxSize=ss.getSize();
            splitRow=ss.getSplitRow();
          }
        }
        completed=true;
      }
 catch (      InterruptedIOException iioe) {
        LOG.info("compaction interrupted by user: ",iioe);
      }
 finally {
        long now=EnvironmentEdgeManager.currentTimeMillis();
        LOG.info(((completed) ? "completed" : "aborted") + " compaction on region " + this+ " after "+ StringUtils.formatTimeDiff(now,startTime));
        if (completed) {
          this.lastCompactInfo=new Pair<Long,Long>((now - startTime) / 1000,lastCompactSize);
        }
      }
    }
  finally {
synchronized (writestate) {
        writestate.compacting=false;
        writestate.notifyAll();
      }
    }
    if (coprocessorHost != null) {
      coprocessorHost.postCompact(splitRow != null);
    }
  }
  finally {
    lock.readLock().unlock();
  }
  return splitRow;
}
