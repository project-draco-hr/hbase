{
  MonitoredTask status=TaskMonitor.get().createStatus("Initializing region " + this);
  if (coprocessorHost != null) {
    status.setStatus("Running coprocessor pre-open hook");
    coprocessorHost.preOpen();
  }
  this.closing.set(false);
  this.closed.set(false);
  status.setStatus("Writing region info on filesystem");
  checkRegioninfoOnFilesystem();
  status.setStatus("Cleaning up temporary data from old regions");
  cleanupTmpDir();
  long minSeqId=-1;
  long maxSeqId=-1;
  long maxMemstoreTS=-1;
  for (  HColumnDescriptor c : this.htableDescriptor.getFamilies()) {
    status.setStatus("Instantiating store for column family " + c);
    Store store=instantiateHStore(this.tableDir,c);
    this.stores.put(c.getName(),store);
    long storeSeqId=store.getMaxSequenceId();
    if (minSeqId == -1 || storeSeqId < minSeqId) {
      minSeqId=storeSeqId;
    }
    if (maxSeqId == -1 || storeSeqId > maxSeqId) {
      maxSeqId=storeSeqId;
    }
    long maxStoreMemstoreTS=store.getMaxMemstoreTS();
    if (maxStoreMemstoreTS > maxMemstoreTS) {
      maxMemstoreTS=maxStoreMemstoreTS;
    }
  }
  rwcc.initialize(maxMemstoreTS + 1);
  maxSeqId=Math.max(maxSeqId,replayRecoveredEditsIfAny(this.regiondir,minSeqId,reporter,status));
  status.setStatus("Cleaning up detritus from prior splits");
  SplitTransaction.cleanupAnySplitDetritus(this);
  FSUtils.deleteDirectory(this.fs,new Path(regiondir,MERGEDIR));
  this.writestate.setReadOnly(this.htableDescriptor.isReadOnly());
  this.writestate.compacting=0;
  this.splitPolicy=RegionSplitPolicy.create(this,conf);
  this.lastFlushTime=EnvironmentEdgeManager.currentTimeMillis();
  long nextSeqid=maxSeqId + 1;
  LOG.info("Onlined " + this.toString() + "; next sequenceid="+ nextSeqid);
  if (coprocessorHost != null) {
    status.setStatus("Running coprocessor post-open hooks");
    coprocessorHost.postOpen();
  }
  status.markComplete("Region opened successfully");
  return nextSeqid;
}
