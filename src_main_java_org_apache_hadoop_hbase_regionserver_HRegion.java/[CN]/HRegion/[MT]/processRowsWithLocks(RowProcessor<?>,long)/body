{
  final long startNanoTime=System.nanoTime();
  String metricsName="rowprocessor." + processor.getName();
  for (  byte[] row : processor.getRowsToLock()) {
    checkRow(row,"processRowsWithLocks");
  }
  if (!processor.readOnly()) {
    checkReadOnly();
  }
  checkResources();
  startRegionOperation();
  WALEdit walEdit=new WALEdit();
  processor.preProcess(this,walEdit);
  if (processor.readOnly()) {
    try {
      long now=EnvironmentEdgeManager.currentTimeMillis();
      doProcessRowWithTimeout(processor,now,this,null,null,timeout);
      processor.postProcess(this,walEdit);
    }
 catch (    IOException e) {
      long endNanoTime=System.nanoTime();
      HRegion.incrTimeVaryingMetric(metricsName + ".error.nano",endNanoTime - startNanoTime);
      throw e;
    }
 finally {
      closeRegionOperation();
    }
    final long endNanoTime=System.nanoTime();
    HRegion.incrTimeVaryingMetric(metricsName + ".nano",endNanoTime - startNanoTime);
    return;
  }
  long lockedNanoTime, processDoneNanoTime, unlockedNanoTime=0;
  MultiVersionConsistencyControl.WriteEntry writeEntry=null;
  boolean locked=false;
  boolean walSyncSuccessful=false;
  List<Integer> acquiredLocks=null;
  long addedSize=0;
  List<KeyValue> mutations=new ArrayList<KeyValue>();
  Collection<byte[]> rowsToLock=processor.getRowsToLock();
  try {
    acquiredLocks=new ArrayList<Integer>(rowsToLock.size());
    for (    byte[] row : rowsToLock) {
      Integer lid=getLock(null,row,true);
      if (lid == null) {
        throw new IOException("Failed to acquire lock on " + Bytes.toStringBinary(row));
      }
      acquiredLocks.add(lid);
    }
    this.updatesLock.readLock().lock();
    locked=true;
    lockedNanoTime=System.nanoTime();
    long now=EnvironmentEdgeManager.currentTimeMillis();
    try {
      doProcessRowWithTimeout(processor,now,this,mutations,walEdit,timeout);
      processDoneNanoTime=System.nanoTime();
      if (!mutations.isEmpty()) {
        writeEntry=mvcc.beginMemstoreInsert();
        for (        KeyValue kv : mutations) {
          kv.setMemstoreTS(writeEntry.getWriteNumber());
          byte[] family=kv.getFamily();
          checkFamily(family);
          addedSize+=stores.get(family).add(kv);
        }
        long txid=0;
        if (!walEdit.isEmpty()) {
          txid=this.log.appendNoSync(this.regionInfo,this.htableDescriptor.getName(),walEdit,processor.getClusterId(),now,this.htableDescriptor);
        }
        if (locked) {
          this.updatesLock.readLock().unlock();
          locked=false;
        }
        unlockedNanoTime=System.nanoTime();
        if (acquiredLocks != null) {
          for (          Integer lid : acquiredLocks) {
            releaseRowLock(lid);
          }
          acquiredLocks=null;
        }
        if (txid != 0 && (this.regionInfo.isMetaRegion() || !this.htableDescriptor.isDeferredLogFlush())) {
          this.log.sync(txid);
        }
        walSyncSuccessful=true;
      }
    }
  finally {
      if (!mutations.isEmpty() && !walSyncSuccessful) {
        LOG.warn("Wal sync failed. Roll back " + mutations.size() + " memstore keyvalues for row(s):"+ processor.getRowsToLock().iterator().next()+ "...");
        for (        KeyValue kv : mutations) {
          stores.get(kv.getFamily()).rollback(kv);
        }
      }
      if (writeEntry != null) {
        mvcc.completeMemstoreInsert(writeEntry);
        writeEntry=null;
      }
      if (locked) {
        this.updatesLock.readLock().unlock();
        locked=false;
      }
      if (acquiredLocks != null) {
        for (        Integer lid : acquiredLocks) {
          releaseRowLock(lid);
        }
      }
      unlockedNanoTime=unlockedNanoTime == 0 ? System.nanoTime() : unlockedNanoTime;
    }
    processor.postProcess(this,walEdit);
  }
 catch (  IOException e) {
    long endNanoTime=System.nanoTime();
    HRegion.incrTimeVaryingMetric(metricsName + ".error.nano",endNanoTime - startNanoTime);
    throw e;
  }
 finally {
    closeRegionOperation();
    if (!mutations.isEmpty() && isFlushSize(this.addAndGetGlobalMemstoreSize(addedSize))) {
      requestFlush();
    }
  }
  long endNanoTime=System.nanoTime();
  HRegion.incrTimeVaryingMetric(metricsName + ".nano",endNanoTime - startNanoTime);
  HRegion.incrTimeVaryingMetric(metricsName + ".acquirelock.nano",lockedNanoTime - startNanoTime);
  HRegion.incrTimeVaryingMetric(metricsName + ".process.nano",processDoneNanoTime - lockedNanoTime);
  HRegion.incrTimeVaryingMetric(metricsName + ".occupylock.nano",unlockedNanoTime - lockedNanoTime);
  HRegion.incrTimeVaryingMetric(metricsName + ".sync.nano",endNanoTime - unlockedNanoTime);
}
