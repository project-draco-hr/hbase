{
  long seqid=minSeqId;
  NavigableSet<Path> files=HLog.getSplitEditFilesSorted(this.fs,regiondir);
  if (files == null || files.isEmpty())   return seqid;
  for (  Path edits : files) {
    if (edits == null || !this.fs.exists(edits)) {
      LOG.warn("Null or non-existent edits file: " + edits);
      continue;
    }
    if (isZeroLengthThenDelete(this.fs,edits))     continue;
    long maxSeqId=Long.MAX_VALUE;
    String fileName=edits.getName();
    maxSeqId=Math.abs(Long.parseLong(fileName));
    if (maxSeqId <= minSeqId) {
      String msg="Maximum sequenceid for this log is " + maxSeqId + " and minimum sequenceid for the region is "+ minSeqId+ ", skipped the whole file, path="+ edits;
      LOG.debug(msg);
      continue;
    }
    try {
      seqid=replayRecoveredEdits(edits,seqid,reporter);
    }
 catch (    IOException e) {
      boolean skipErrors=conf.getBoolean("hbase.skip.errors",false);
      if (skipErrors) {
        Path p=HLog.moveAsideBadEditsFile(fs,edits);
        LOG.error("hbase.skip.errors=true so continuing. Renamed " + edits + " as "+ p,e);
      }
 else {
        throw e;
      }
    }
    if (this.rsAccounting != null) {
      this.rsAccounting.clearRegionReplayEditsSize(this.regionInfo.getRegionName());
    }
  }
  if (seqid > minSeqId) {
    internalFlushcache(null,seqid,status);
  }
  for (  Path file : files) {
    if (!this.fs.delete(file,false)) {
      LOG.error("Failed delete of " + file);
    }
 else {
      LOG.debug("Deleted recovered.edits file=" + file);
    }
  }
  return seqid;
}
