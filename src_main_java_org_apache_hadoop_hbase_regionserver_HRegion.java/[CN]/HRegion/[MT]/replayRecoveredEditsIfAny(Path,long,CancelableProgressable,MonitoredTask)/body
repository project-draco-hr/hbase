{
  long seqid=minSeqId;
  NavigableSet<Path> files=HLog.getSplitEditFilesSorted(this.fs,regiondir);
  if (files == null || files.isEmpty())   return seqid;
  boolean checkSafeToSkip=true;
  for (  Path edits : files) {
    if (edits == null || !this.fs.exists(edits)) {
      LOG.warn("Null or non-existent edits file: " + edits);
      continue;
    }
    if (isZeroLengthThenDelete(this.fs,edits))     continue;
    if (checkSafeToSkip) {
      Path higher=files.higher(edits);
      long maxSeqId=Long.MAX_VALUE;
      if (higher != null) {
        String fileName=higher.getName();
        maxSeqId=Math.abs(Long.parseLong(fileName));
      }
      if (maxSeqId <= minSeqId) {
        String msg="Maximum possible sequenceid for this log is " + maxSeqId + ", skipped the whole file, path="+ edits;
        LOG.debug(msg);
        continue;
      }
 else {
        checkSafeToSkip=false;
      }
    }
    try {
      seqid=replayRecoveredEdits(edits,seqid,reporter);
    }
 catch (    IOException e) {
      boolean skipErrors=conf.getBoolean("hbase.skip.errors",false);
      if (skipErrors) {
        Path p=HLog.moveAsideBadEditsFile(fs,edits);
        LOG.error("hbase.skip.errors=true so continuing. Renamed " + edits + " as "+ p,e);
      }
 else {
        throw e;
      }
    }
  }
  if (seqid > minSeqId) {
    internalFlushcache(null,seqid,status);
  }
  for (  Path file : files) {
    if (!this.fs.delete(file,false)) {
      LOG.error("Failed delete of " + file);
    }
 else {
      LOG.debug("Deleted recovered.edits file=" + file);
    }
  }
  return seqid;
}
