{
  boolean flush=false;
  startRegionOperation();
  List<Integer> acquiredLocks=null;
  try {
    WALEdit walEdit=new WALEdit();
    if (coprocessorHost != null) {
      for (      Mutation m : mutations) {
        if (m instanceof Put) {
          if (coprocessorHost.prePut((Put)m,walEdit,m.getWriteToWAL())) {
            return;
          }
        }
 else         if (m instanceof Delete) {
          Delete d=(Delete)m;
          prepareDelete(d);
          if (coprocessorHost.preDelete(d,walEdit,d.getWriteToWAL())) {
            return;
          }
        }
      }
    }
    long txid=0;
    boolean walSyncSuccessful=false;
    boolean locked=false;
    acquiredLocks=new ArrayList<Integer>(rowsToLock.size());
    for (    byte[] row : rowsToLock) {
      Integer lid=getLock(null,row,true);
      if (lid == null) {
        throw new IOException("Failed to acquire lock on " + Bytes.toStringBinary(row));
      }
      acquiredLocks.add(lid);
    }
    this.updatesLock.readLock().lock();
    locked=true;
    MultiVersionConsistencyControl.WriteEntry w=mvcc.beginMemstoreInsert();
    long now=EnvironmentEdgeManager.currentTimeMillis();
    byte[] byteNow=Bytes.toBytes(now);
    try {
      for (      Mutation m : mutations) {
        if (m instanceof Put) {
          Map<byte[],List<KeyValue>> familyMap=m.getFamilyMap();
          checkFamilies(familyMap.keySet());
          checkTimestamps(familyMap,now);
          updateKVTimestamps(familyMap.values(),byteNow);
        }
 else         if (m instanceof Delete) {
          Delete d=(Delete)m;
          prepareDelete(d);
          prepareDeleteTimestamps(d,byteNow);
        }
 else {
          throw new DoNotRetryIOException("Action must be Put or Delete. But was: " + m.getClass().getName());
        }
        if (m.getWriteToWAL()) {
          addFamilyMapToWALEdit(m.getFamilyMap(),walEdit);
        }
      }
      if (walEdit.size() > 0) {
        txid=this.log.appendNoSync(regionInfo,this.htableDescriptor.getName(),walEdit,HConstants.DEFAULT_CLUSTER_ID,now,this.htableDescriptor);
      }
      long addedSize=0;
      for (      Mutation m : mutations) {
        addedSize+=applyFamilyMapToMemstore(m.getFamilyMap(),w);
      }
      flush=isFlushSize(this.addAndGetGlobalMemstoreSize(addedSize));
      this.updatesLock.readLock().unlock();
      locked=false;
      if (acquiredLocks != null) {
        for (        Integer lid : acquiredLocks) {
          releaseRowLock(lid);
        }
        acquiredLocks=null;
      }
      if (walEdit.size() > 0 && (this.regionInfo.isMetaRegion() || !this.htableDescriptor.isDeferredLogFlush())) {
        this.log.sync(txid);
      }
      walSyncSuccessful=true;
      mvcc.completeMemstoreInsert(w);
      w=null;
      if (coprocessorHost != null) {
        for (        Mutation m : mutations) {
          if (m instanceof Put) {
            coprocessorHost.postPut((Put)m,walEdit,m.getWriteToWAL());
          }
 else           if (m instanceof Delete) {
            coprocessorHost.postDelete((Delete)m,walEdit,m.getWriteToWAL());
          }
        }
      }
    }
  finally {
      if (!walSyncSuccessful) {
        int kvsRolledback=0;
        for (        Mutation m : mutations) {
          for (          Map.Entry<byte[],List<KeyValue>> e : m.getFamilyMap().entrySet()) {
            List<KeyValue> kvs=e.getValue();
            byte[] family=e.getKey();
            Store store=getStore(family);
            for (            KeyValue kv : kvs) {
              store.rollback(kv);
              kvsRolledback++;
            }
          }
        }
        LOG.info("mutateRowWithLocks: rolled back " + kvsRolledback + " KeyValues");
      }
      if (w != null) {
        mvcc.completeMemstoreInsert(w);
      }
      if (locked) {
        this.updatesLock.readLock().unlock();
      }
      if (acquiredLocks != null) {
        for (        Integer lid : acquiredLocks) {
          releaseRowLock(lid);
        }
      }
    }
  }
  finally {
    if (flush) {
      requestFlush();
    }
    closeRegionOperation();
  }
}
