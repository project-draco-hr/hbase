{
  Path oldLogFile=new Path(regiondir,HREGION_OLDLOGFILE_NAME);
  moveInitialFilesIntoPlace(this.fs,initialFiles,this.regiondir);
  checkRegioninfoOnFilesystem();
  long maxSeqId=-1;
  long minSeqIdToRecover=Integer.MAX_VALUE;
  for (  HColumnDescriptor c : this.regionInfo.getTableDesc().getFamilies()) {
    Store store=instantiateHStore(this.basedir,c,oldLogFile,reporter);
    this.stores.put(c.getName(),store);
    long storeSeqId=store.getMaxSequenceId();
    if (storeSeqId > maxSeqId) {
      maxSeqId=storeSeqId;
    }
    long storeSeqIdBeforeRecovery=store.getMaxSeqIdBeforeLogRecovery();
    if (storeSeqIdBeforeRecovery < minSeqIdToRecover) {
      minSeqIdToRecover=storeSeqIdBeforeRecovery;
    }
  }
  doReconstructionLog(oldLogFile,minSeqIdToRecover,maxSeqId,reporter);
  if (fs.exists(oldLogFile)) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Deleting old log file: " + oldLogFile);
    }
    fs.delete(oldLogFile,false);
  }
  this.minSequenceId=maxSeqId + 1;
  FSUtils.deleteDirectory(this.fs,new Path(regiondir,SPLITDIR));
  FSUtils.deleteDirectory(this.fs,new Path(regiondir,MERGEDIR));
  if (this.regionInfo.getTableDesc().isReadOnly()) {
    this.writestate.setReadOnly(true);
  }
  this.writestate.compacting=false;
  this.lastFlushTime=System.currentTimeMillis();
  LOG.info("region " + this + " available; sequence id is "+ this.minSequenceId);
}
