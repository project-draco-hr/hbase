{
  if (this.closing.get()) {
    LOG.debug("Skipping flush on " + this + " because closing");
    return false;
  }
  lock.readLock().lock();
  try {
    if (this.closed.get()) {
      LOG.debug("Skipping flush on " + this + " because closed");
      return false;
    }
    if (coprocessorHost != null) {
      coprocessorHost.preFlush();
    }
    try {
synchronized (writestate) {
        if (!writestate.flushing && writestate.writesEnabled) {
          this.writestate.flushing=true;
        }
 else {
          if (LOG.isDebugEnabled()) {
            LOG.debug("NOT flushing memstore for region " + this + ", flushing="+ writestate.flushing+ ", writesEnabled="+ writestate.writesEnabled);
          }
          return false;
        }
      }
      boolean result=internalFlushcache();
      if (coprocessorHost != null) {
        coprocessorHost.postFlush();
      }
      return result;
    }
  finally {
synchronized (writestate) {
        writestate.flushing=false;
        this.writestate.flushRequested=false;
        writestate.notifyAll();
      }
    }
  }
  finally {
    lock.readLock().unlock();
  }
}
