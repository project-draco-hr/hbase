{
  checkRow(row);
  boolean flush=false;
  boolean wrongLength=false;
  long result=amount;
  startRegionOperation();
  this.writeRequestsCount.increment();
  try {
    Integer lid=obtainRowLock(row);
    this.updatesLock.readLock().lock();
    try {
      Store store=stores.get(family);
      Get get=new Get(row);
      get.addColumn(family,qualifier);
      List<KeyValue> results=getLastIncrement(get);
      if (!results.isEmpty()) {
        KeyValue kv=results.get(0);
        if (kv.getValueLength() == 8) {
          byte[] buffer=kv.getBuffer();
          int valueOffset=kv.getValueOffset();
          result+=Bytes.toLong(buffer,valueOffset,Bytes.SIZEOF_LONG);
        }
 else {
          wrongLength=true;
        }
      }
      if (!wrongLength) {
        KeyValue newKv=new KeyValue(row,family,qualifier,EnvironmentEdgeManager.currentTimeMillis(),Bytes.toBytes(result));
        if (writeToWAL) {
          long now=EnvironmentEdgeManager.currentTimeMillis();
          WALEdit walEdit=new WALEdit();
          walEdit.add(newKv);
          this.log.append(regionInfo,this.htableDescriptor.getName(),walEdit,now,this.htableDescriptor);
        }
        long size=store.updateColumnValue(row,family,qualifier,result);
        size=this.addAndGetGlobalMemstoreSize(size);
        flush=isFlushSize(size);
      }
    }
  finally {
      this.updatesLock.readLock().unlock();
      releaseRowLock(lid);
    }
  }
  finally {
    closeRegionOperation();
  }
  if (flush) {
    requestFlush();
  }
  if (wrongLength) {
    throw new IOException("Attempted to increment field that isn't 64 bits wide");
  }
  return result;
}
