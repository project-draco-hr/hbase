{
  Map<byte[],List<KeyValue>> familyMap=delete.getFamilyMap();
  WALEdit walEdit=new WALEdit();
  if (coprocessorHost != null) {
    if (coprocessorHost.preDelete(delete,walEdit,writeToWAL)) {
      return;
    }
  }
  long now=EnvironmentEdgeManager.currentTimeMillis();
  byte[] byteNow=Bytes.toBytes(now);
  boolean flush=false;
  updatesLock.readLock().lock();
  try {
    prepareDeleteTimestamps(delete,byteNow);
    if (writeToWAL) {
      addFamilyMapToWALEdit(familyMap,walEdit);
      this.log.append(regionInfo,this.htableDescriptor.getName(),walEdit,clusterId,now,this.htableDescriptor);
    }
    long addedSize=applyFamilyMapToMemstore(familyMap,null);
    flush=isFlushSize(this.addAndGetGlobalMemstoreSize(addedSize));
  }
  finally {
    this.updatesLock.readLock().unlock();
  }
  if (coprocessorHost != null) {
    coprocessorHost.postDelete(delete,walEdit,writeToWAL);
  }
  final long after=EnvironmentEdgeManager.currentTimeMillis();
  final String metricPrefix=SchemaMetrics.generateSchemaMetricsPrefix(getTableDesc().getNameAsString(),familyMap.keySet());
  if (!metricPrefix.isEmpty()) {
    RegionMetricsStorage.incrTimeVaryingMetric(metricPrefix + "delete_",after - now);
  }
  if (flush) {
    requestFlush();
  }
}
