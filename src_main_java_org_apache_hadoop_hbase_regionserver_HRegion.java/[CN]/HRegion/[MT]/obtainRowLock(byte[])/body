{
  checkRow(row);
  splitsAndClosesLock.readLock().lock();
  try {
    if (this.closed.get()) {
      throw new NotServingRegionException(this + " is closed");
    }
synchronized (lockedRows) {
      while (lockedRows.contains(row)) {
        try {
          lockedRows.wait();
        }
 catch (        InterruptedException ie) {
        }
      }
      byte[] prev=null;
      Integer lockId=null;
      do {
        lockId=new Integer(lockIdGenerator++);
        prev=lockIds.put(lockId,row);
        if (prev != null) {
          lockIds.put(lockId,prev);
          lockIdGenerator=rand.nextInt();
        }
      }
 while (prev != null);
      lockedRows.add(row);
      lockedRows.notifyAll();
      return lockId;
    }
  }
  finally {
    splitsAndClosesLock.readLock().unlock();
  }
}
