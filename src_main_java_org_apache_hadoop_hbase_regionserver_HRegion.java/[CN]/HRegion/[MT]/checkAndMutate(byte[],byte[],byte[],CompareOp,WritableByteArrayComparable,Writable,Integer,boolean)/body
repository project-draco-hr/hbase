{
  checkReadOnly();
  checkResources();
  boolean isPut=w instanceof Put;
  if (!isPut && !(w instanceof Delete))   throw new DoNotRetryIOException("Action must be Put or Delete");
  Row r=(Row)w;
  if (!Bytes.equals(row,r.getRow())) {
    throw new DoNotRetryIOException("Action's getRow must match the passed row");
  }
  startRegionOperation();
  this.writeRequestsCount.increment();
  try {
    RowLock lock=isPut ? ((Put)w).getRowLock() : ((Delete)w).getRowLock();
    Get get=new Get(row,lock);
    checkFamily(family);
    get.addColumn(family,qualifier);
    Integer lid=getLock(lockId,get.getRow(),true);
    List<KeyValue> result=null;
    try {
      result=get(get,false);
      boolean valueIsNull=comparator.getValue() == null || comparator.getValue().length == 0;
      boolean matches=false;
      if (result.size() == 0 && valueIsNull) {
        matches=true;
      }
 else       if (result.size() > 0 && result.get(0).getValue().length == 0 && valueIsNull) {
        matches=true;
      }
 else       if (result.size() == 1 && !valueIsNull) {
        KeyValue kv=result.get(0);
        int compareResult=comparator.compareTo(kv.getBuffer(),kv.getValueOffset(),kv.getValueLength());
switch (compareOp) {
case LESS:
          matches=compareResult <= 0;
        break;
case LESS_OR_EQUAL:
      matches=compareResult < 0;
    break;
case EQUAL:
  matches=compareResult == 0;
break;
case NOT_EQUAL:
matches=compareResult != 0;
break;
case GREATER_OR_EQUAL:
matches=compareResult > 0;
break;
case GREATER:
matches=compareResult >= 0;
break;
default :
throw new RuntimeException("Unknown Compare op " + compareOp.name());
}
}
if (matches) {
if (isPut) {
internalPut(((Put)w),HConstants.DEFAULT_CLUSTER_ID,writeToWAL);
}
 else {
Delete d=(Delete)w;
prepareDelete(d);
internalDelete(d,HConstants.DEFAULT_CLUSTER_ID,writeToWAL);
}
return true;
}
return false;
}
  finally {
if (lockId == null) releaseRowLock(lid);
}
}
  finally {
closeRegionOperation();
}
}
