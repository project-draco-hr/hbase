{
  long currentEditSeqId=minSeqId;
  long firstSeqIdInLog=-1;
  long skippedEdits=0;
  long editsCount=0;
  HLog.Entry entry;
  Store store=null;
  int interval=this.conf.getInt("hbase.hstore.report.interval.edits",2000);
  while ((entry=reader.next()) != null) {
    HLogKey key=entry.getKey();
    WALEdit val=entry.getEdit();
    if (firstSeqIdInLog == -1) {
      firstSeqIdInLog=key.getLogSeqNum();
    }
    if (key.getLogSeqNum() <= currentEditSeqId) {
      skippedEdits++;
      continue;
    }
    currentEditSeqId=key.getLogSeqNum();
    boolean flush=false;
    for (    KeyValue kv : val.getKeyValues()) {
      if (kv.matchingFamily(HLog.METAFAMILY) || !Bytes.equals(key.getRegionName(),this.regionInfo.getRegionName())) {
        skippedEdits++;
        continue;
      }
      if (store == null || !kv.matchingFamily(store.getFamily().getName())) {
        store=this.stores.get(kv.getFamily());
      }
      if (store == null) {
        LOG.warn("No family for " + kv);
        skippedEdits++;
        continue;
      }
      flush=restoreEdit(store,kv);
      editsCount++;
    }
    if (flush)     internalFlushcache(null,currentEditSeqId);
    if (reporter != null && (editsCount % interval) == 0) {
      reporter.progress();
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Applied " + editsCount + ", skipped "+ skippedEdits+ ", firstSeqIdInLog="+ firstSeqIdInLog+ ", maxSeqIdInLog="+ currentEditSeqId);
  }
  return currentEditSeqId;
}
