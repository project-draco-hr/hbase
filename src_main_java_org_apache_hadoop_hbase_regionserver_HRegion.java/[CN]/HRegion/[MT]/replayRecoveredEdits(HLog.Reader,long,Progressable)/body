{
  long currentEditSeqId=-1;
  long firstSeqIdInLog=-1;
  long skippedEdits=0;
  long editsCount=0;
  HLog.Entry entry;
  Store store=null;
  Map<byte[],Long> familyToOriginalMaxSeqId=familyToMaxSeqId(this.stores);
  int interval=this.conf.getInt("hbase.hstore.report.interval.edits",2000);
  while ((entry=reader.next()) != null) {
    HLogKey key=entry.getKey();
    WALEdit val=entry.getEdit();
    if (firstSeqIdInLog == -1) {
      firstSeqIdInLog=key.getLogSeqNum();
    }
    currentEditSeqId=Math.max(currentEditSeqId,key.getLogSeqNum());
    if (key.getLogSeqNum() <= minSeqId) {
      skippedEdits++;
      continue;
    }
    for (    KeyValue kv : val.getKeyValues()) {
      if (kv.matchingFamily(HLog.METAFAMILY) || !Bytes.equals(key.getRegionName(),this.regionInfo.getRegionName())) {
        skippedEdits++;
        continue;
      }
      if (store == null || !kv.matchingFamily(store.getFamily().getName())) {
        store=this.stores.get(kv.getFamily());
      }
      if (store == null) {
        LOG.warn("No family for " + kv);
        skippedEdits++;
        continue;
      }
      long storeMaxSeqId=familyToOriginalMaxSeqId.get(store.getFamily().getName());
      if (currentEditSeqId < storeMaxSeqId) {
        skippedEdits++;
        continue;
      }
      restoreEdit(kv);
      editsCount++;
    }
    if (reporter != null && (editsCount % interval) == 0) {
      reporter.progress();
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Applied " + editsCount + ", skipped "+ skippedEdits+ ", firstSeqIdInLog="+ firstSeqIdInLog+ ", maxSeqIdInLog="+ currentEditSeqId);
  }
  return currentEditSeqId;
}
