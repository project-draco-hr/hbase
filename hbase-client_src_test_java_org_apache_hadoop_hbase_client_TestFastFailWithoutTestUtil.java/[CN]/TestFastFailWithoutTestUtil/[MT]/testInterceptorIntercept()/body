{
  Configuration conf=HBaseConfiguration.create();
  long CLEANUP_TIMEOUT=50;
  long FAST_FAIL_THRESHOLD=10;
  conf.setBoolean(HConstants.HBASE_CLIENT_FAST_FAIL_MODE_ENABLED,true);
  conf.setLong(HConstants.HBASE_CLIENT_FAST_FAIL_CLEANUP_MS_DURATION_MS,CLEANUP_TIMEOUT);
  conf.setLong(HConstants.HBASE_CLIENT_FAST_FAIL_THREASHOLD_MS,FAST_FAIL_THRESHOLD);
  PreemptiveFastFailInterceptor interceptor=TestFastFailWithoutTestUtil.createPreemptiveInterceptor(conf);
  FastFailInterceptorContext context=(FastFailInterceptorContext)interceptor.createEmptyContext();
  RetryingCallable<?> callable=getDummyRetryingCallable(getSomeServerName());
  int tries=0;
  context.prepare(callable,tries);
  interceptor.intercept(context);
  interceptor.handleFailure(context,new ConnectException("Failed to connect to server"));
  interceptor.updateFailureInfo(context);
  assertTrue("Interceptor should have updated didTry to true",context.didTry());
  assertTrue("The call shouldn't have been successful if there was a ConnectException",context.getCouldNotCommunicateWithServer().booleanValue());
  assertNull("Once a failure is identified, the first time the FailureInfo is generated for the server," + " but it is not assigned to the context yet. It would be assigned on the next" + " intercept.",context.getFailureInfo());
  assertEquals(context.getTries(),tries);
  assertFalse("We are still in the first attempt and so we dont set this variable to true yet.",context.isRetryDespiteFastFailMode());
  Thread.sleep(FAST_FAIL_THRESHOLD + 1);
  tries++;
  context.prepare(callable,tries);
  interceptor.intercept(context);
  interceptor.handleFailure(context,new ConnectException("Failed to connect to server"));
  interceptor.updateFailureInfo(context);
  assertTrue("didTru should remain true",context.didTry());
  assertTrue("The call shouldn't have been successful if there was a ConnectException",context.getCouldNotCommunicateWithServer().booleanValue());
  assertNotNull("The context this time is updated with a failureInfo, since we already gave it a try.",context.getFailureInfo());
  assertEquals(context.getTries(),tries);
  assertTrue("Since we are alone here we would be given the permission to retryDespiteFailures.",context.isRetryDespiteFastFailMode());
  context.clear();
  Thread.sleep(CLEANUP_TIMEOUT);
  tries++;
  context.clear();
  context.prepare(callable,tries);
  interceptor.occasionallyCleanupFailureInformation();
  assertNull("The cleanup should have cleared the server",interceptor.repeatedFailuresMap.get(context.getServer()));
  interceptor.intercept(context);
  interceptor.handleFailure(context,new ConnectException("Failed to connect to server"));
  interceptor.updateFailureInfo(context);
  assertTrue("didTru should remain true",context.didTry());
  assertTrue("The call shouldn't have been successful if there was a ConnectException",context.getCouldNotCommunicateWithServer().booleanValue());
  assertNull("The failureInfo is cleared off from the maps.",context.getFailureInfo());
  assertEquals(context.getTries(),tries);
  assertFalse("Since we are alone here we would be given the permission to retryDespiteFailures.",context.isRetryDespiteFastFailMode());
  context.clear();
}
