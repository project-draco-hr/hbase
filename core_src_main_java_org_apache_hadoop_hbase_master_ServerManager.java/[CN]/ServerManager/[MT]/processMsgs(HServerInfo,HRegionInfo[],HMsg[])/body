{
  ArrayList<HMsg> returnMsgs=new ArrayList<HMsg>();
  if (serverInfo.getServerAddress() == null) {
    throw new NullPointerException("Server address cannot be null; " + "hbase-958 debugging");
  }
  int openingCount=0;
  for (int i=0; i < incomingMsgs.length; i++) {
    HRegionInfo region=incomingMsgs[i].getRegionInfo();
    LOG.info("Processing " + incomingMsgs[i] + " from "+ serverInfo.getServerName()+ "; "+ (i + 1)+ " of "+ incomingMsgs.length);
switch (incomingMsgs[i].getType()) {
case MSG_REPORT_PROCESS_OPEN:
      openingCount++;
    break;
case MSG_REPORT_OPEN:
  processRegionOpen(serverInfo,region,returnMsgs);
break;
case MSG_REPORT_CLOSE:
processRegionClose(region);
break;
case MSG_REPORT_SPLIT:
processSplitRegion(region,incomingMsgs[++i].getRegionInfo(),incomingMsgs[++i].getRegionInfo());
break;
case MSG_REPORT_SPLIT_INCLUDES_DAUGHTERS:
processSplitRegion(region,incomingMsgs[i].getDaughterA(),incomingMsgs[i].getDaughterB());
break;
default :
LOG.warn("Impossible state during message processing. Instruction: " + incomingMsgs[i].getType());
}
}
synchronized (this.master.getRegionManager()) {
for (HRegionInfo i : this.master.getRegionManager().getMarkedToClose(serverInfo.getServerName())) {
returnMsgs.add(new HMsg(HMsg.Type.MSG_REGION_CLOSE,i));
this.master.getRegionManager().setPendingClose(i.getRegionNameAsString());
}
if (openingCount < this.nobalancingCount) {
this.master.getRegionManager().assignRegions(serverInfo,mostLoadedRegions,returnMsgs);
}
this.master.getRegionManager().applyActions(serverInfo,returnMsgs);
}
return returnMsgs.toArray(new HMsg[returnMsgs.size()]);
}
