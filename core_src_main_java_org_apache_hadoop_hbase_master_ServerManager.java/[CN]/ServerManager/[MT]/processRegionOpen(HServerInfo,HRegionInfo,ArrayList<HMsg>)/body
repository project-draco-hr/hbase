{
  boolean duplicateAssignment=false;
synchronized (master.getRegionManager()) {
    if (!this.master.getRegionManager().isUnassigned(region) && !this.master.getRegionManager().isPendingOpen(region.getRegionNameAsString())) {
      if (region.isRootRegion()) {
        HServerAddress rootServer=this.master.getRegionManager().getRootRegionLocation();
        if (rootServer != null) {
          if (rootServer.compareTo(serverInfo.getServerAddress()) == 0) {
            return;
          }
          duplicateAssignment=true;
        }
      }
 else {
        if (this.master.getRegionManager().isPendingOpen(region.getRegionNameAsString())) {
          return;
        }
        duplicateAssignment=true;
      }
    }
    if (duplicateAssignment) {
      LOG.warn("region server " + serverInfo.getServerAddress().toString() + " should not have opened region "+ Bytes.toString(region.getRegionName()));
      returnMsgs.add(new HMsg(HMsg.Type.MSG_REGION_CLOSE_WITHOUT_REPORT,region,"Duplicate assignment".getBytes()));
    }
 else {
      if (region.isRootRegion()) {
        this.master.getRegionManager().removeRegion(region);
        HServerAddress rootServer=serverInfo.getServerAddress();
        this.master.getServerConnection().setRootRegionLocation(new HRegionLocation(region,rootServer));
        this.master.getRegionManager().setRootRegionLocation(rootServer);
      }
 else {
        this.master.getRegionManager().setOpen(region.getRegionNameAsString());
        this.master.queue(new ProcessRegionOpen(master,serverInfo,region));
      }
    }
  }
}
