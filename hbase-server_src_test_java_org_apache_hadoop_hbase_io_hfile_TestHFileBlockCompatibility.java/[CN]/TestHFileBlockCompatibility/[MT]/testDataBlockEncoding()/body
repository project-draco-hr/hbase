{
  if (includesTag) {
    TEST_UTIL.getConfiguration().setInt("hfile.format.version",3);
  }
  final int numBlocks=5;
  for (  Compression.Algorithm algo : COMPRESSION_ALGORITHMS) {
    for (    boolean pread : new boolean[]{false,true}) {
      for (      DataBlockEncoding encoding : DataBlockEncoding.values()) {
        LOG.info("testDataBlockEncoding algo " + algo + " pread = "+ pread+ " encoding "+ encoding);
        Path path=new Path(TEST_UTIL.getDataTestDir(),"blocks_v2_" + algo + "_"+ encoding.toString());
        FSDataOutputStream os=fs.create(path);
        HFileDataBlockEncoder dataBlockEncoder=(encoding != DataBlockEncoding.NONE) ? new HFileDataBlockEncoderImpl(encoding) : NoOpDataBlockEncoder.INSTANCE;
        TestHFileBlockCompatibility.Writer hbw=new TestHFileBlockCompatibility.Writer(algo,dataBlockEncoder,includesMemstoreTS,includesTag);
        long totalSize=0;
        final List<Integer> encodedSizes=new ArrayList<Integer>();
        final List<ByteBuffer> encodedBlocks=new ArrayList<ByteBuffer>();
        for (int blockId=0; blockId < numBlocks; ++blockId) {
          hbw.startWriting(BlockType.DATA);
          TestHFileBlock.writeTestKeyValues(hbw,blockId,pread,includesTag);
          hbw.writeHeaderAndData(os);
          int headerLen=HConstants.HFILEBLOCK_HEADER_SIZE_NO_CHECKSUM;
          byte[] encodedResultWithHeader=hbw.getUncompressedDataWithHeader();
          final int encodedSize=encodedResultWithHeader.length - headerLen;
          if (encoding != DataBlockEncoding.NONE) {
            headerLen+=DataBlockEncoding.ID_SIZE;
          }
          byte[] encodedDataSection=new byte[encodedResultWithHeader.length - headerLen];
          System.arraycopy(encodedResultWithHeader,headerLen,encodedDataSection,0,encodedDataSection.length);
          final ByteBuffer encodedBuf=ByteBuffer.wrap(encodedDataSection);
          encodedSizes.add(encodedSize);
          encodedBlocks.add(encodedBuf);
          totalSize+=hbw.getOnDiskSizeWithHeader();
        }
        os.close();
        FSDataInputStream is=fs.open(path);
        HFileContext meta=new HFileContextBuilder().withHBaseCheckSum(false).withIncludesMvcc(includesMemstoreTS).withIncludesTags(includesTag).withCompression(algo).build();
        HFileBlock.FSReaderImpl hbr=new HFileBlock.FSReaderImpl(new FSDataInputStreamWrapper(is),totalSize,fs,path,meta);
        hbr.setDataBlockEncoder(dataBlockEncoder);
        hbr.setIncludesMemstoreTS(includesMemstoreTS);
        HFileBlock b;
        int pos=0;
        for (int blockId=0; blockId < numBlocks; ++blockId) {
          b=hbr.readBlockData(pos,-1,-1,pread);
          b.sanityCheck();
          if (meta.isCompressedOrEncrypted()) {
            assertFalse(b.isUnpacked());
            b=b.unpack(meta,hbr);
          }
          pos+=b.getOnDiskSizeWithHeader();
          assertEquals((int)encodedSizes.get(blockId),b.getUncompressedSizeWithoutHeader());
          ByteBuff actualBuffer=b.getBufferWithoutHeader();
          if (encoding != DataBlockEncoding.NONE) {
            assertEquals(0,actualBuffer.get(0));
            assertEquals(encoding.getId(),actualBuffer.get(1));
            actualBuffer.position(2);
            actualBuffer=actualBuffer.slice();
          }
          ByteBuffer expectedBuffer=encodedBlocks.get(blockId);
          expectedBuffer.rewind();
          TestHFileBlock.assertBuffersEqual(new SingleByteBuff(expectedBuffer),actualBuffer,algo,encoding,pread);
        }
        is.close();
      }
    }
  }
}
