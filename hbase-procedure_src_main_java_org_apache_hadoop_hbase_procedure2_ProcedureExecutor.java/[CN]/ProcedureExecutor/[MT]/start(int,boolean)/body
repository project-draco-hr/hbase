{
  if (running.getAndSet(true)) {
    LOG.warn("Already running");
    return;
  }
  threads=new Thread[numThreads + 1];
  LOG.info("Starting procedure executor threads=" + threads.length);
  for (int i=0; i < numThreads; ++i) {
    threads[i]=new Thread("ProcedureExecutor-" + i){
      @Override public void run(){
        execLoop();
      }
    }
;
  }
  threads[numThreads]=new Thread("ProcedureExecutorTimeoutThread"){
    @Override public void run(){
      timeoutLoop();
    }
  }
;
  long st, et;
  st=EnvironmentEdgeManager.currentTime();
  store.recoverLease();
  et=EnvironmentEdgeManager.currentTime();
  LOG.info(String.format("recover procedure store (%s) lease: %s",store.getClass().getSimpleName(),StringUtils.humanTimeDiff(et - st)));
  st=EnvironmentEdgeManager.currentTime();
  load(abortOnCorruption);
  et=EnvironmentEdgeManager.currentTime();
  LOG.info(String.format("load procedure store (%s): %s",store.getClass().getSimpleName(),StringUtils.humanTimeDiff(et - st)));
  for (int i=0; i < threads.length; ++i) {
    threads[i].start();
  }
  addChore(new CompletedProcedureCleaner(conf,store,completed,nonceKeysToProcIdsMap));
}
