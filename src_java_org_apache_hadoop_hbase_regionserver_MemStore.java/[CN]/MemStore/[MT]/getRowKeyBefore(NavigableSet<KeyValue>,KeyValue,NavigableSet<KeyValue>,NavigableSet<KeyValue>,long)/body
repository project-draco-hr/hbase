{
  NavigableSet<KeyValue> head=set.headSet(search,false);
  if (head.isEmpty()) {
    return;
  }
  if (candidates.isEmpty()) {
    KeyValue lastFound=null;
    for (Iterator<KeyValue> i=head.descendingIterator(); i.hasNext(); ) {
      KeyValue found=i.next();
      boolean deleted=found.isDeleteType();
      if (lastFound != null && this.comparator.matchingRows(lastFound,found) && !deleted) {
        break;
      }
      if (!deleted) {
        if (Store.notExpiredAndNotInDeletes(this.ttl,found,now,deletes)) {
          lastFound=found;
          candidates.add(found);
        }
 else {
          Store.expiredOrDeleted(set,found);
        }
      }
 else {
        if (Store.handleDeletes(found,candidates,deletes)) {
          remove(set,found);
        }
      }
    }
  }
 else {
    SortedSet<KeyValue> rowTail=head.tailSet(head.last().cloneRow(HConstants.LATEST_TIMESTAMP));
    Iterator<KeyValue> i=rowTail.iterator();
    do {
      KeyValue found=i.next();
      if (found.isDeleteType()) {
        Store.handleDeletes(found,candidates,deletes);
      }
 else {
        if (ttl == HConstants.FOREVER || now < found.getTimestamp() + ttl || !deletes.contains(found)) {
          candidates.add(found);
        }
 else {
          Store.expiredOrDeleted(set,found);
        }
      }
    }
 while (i.hasNext());
  }
}
