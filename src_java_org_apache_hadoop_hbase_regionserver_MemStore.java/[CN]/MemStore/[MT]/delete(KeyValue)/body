{
  long size=0;
  this.lock.readLock().lock();
  try {
    boolean notpresent=false;
    List<KeyValue> deletes=new ArrayList<KeyValue>();
    SortedMap<KeyValue,Object> tail=this.memstore.tailMap(delete);
    byte[] deleteBuffer=delete.getBuffer();
    int deleteOffset=delete.getOffset();
    int deleteKeyLen=Bytes.toInt(deleteBuffer,deleteOffset);
    deleteOffset+=Bytes.SIZEOF_INT + Bytes.SIZEOF_INT;
    short deleteRowLen=Bytes.toShort(deleteBuffer,deleteOffset);
    deleteOffset+=Bytes.SIZEOF_SHORT;
    int deleteRowOffset=deleteOffset;
    deleteOffset+=deleteRowLen;
    byte deleteFamLen=deleteBuffer[deleteOffset];
    deleteOffset+=Bytes.SIZEOF_BYTE + deleteFamLen;
    int deleteQualifierOffset=deleteOffset;
    int deleteQualifierLen=deleteKeyLen - deleteRowLen - deleteFamLen- Bytes.SIZEOF_SHORT- Bytes.SIZEOF_BYTE- Bytes.SIZEOF_LONG- Bytes.SIZEOF_BYTE;
    deleteOffset+=deleteQualifierLen;
    int deleteTimestampOffset=deleteOffset;
    deleteOffset+=Bytes.SIZEOF_LONG;
    byte deleteType=deleteBuffer[deleteOffset];
    for (    Map.Entry<KeyValue,?> entry : tail.entrySet()) {
      DeleteCode res=DeleteCompare.deleteCompare(entry.getKey(),deleteBuffer,deleteRowOffset,deleteRowLen,deleteQualifierOffset,deleteQualifierLen,deleteTimestampOffset,deleteType,comparator.getRawComparator());
      if (res == DeleteCode.DONE) {
        break;
      }
 else       if (res == DeleteCode.DELETE) {
        deletes.add(entry.getKey());
      }
    }
    for (    KeyValue del : deletes) {
      notpresent=this.memstore.remove(del) == null;
      size-=heapSize(del,notpresent);
    }
    size+=heapSize(delete,this.memstore.put(delete,NULL) == null);
  }
  finally {
    this.lock.readLock().unlock();
  }
  return size;
}
